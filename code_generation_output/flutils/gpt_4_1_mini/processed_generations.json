{"task_id": 125, "project": "test-apps/flutils", "module": "flutils.packages", "predictions": ["from typing import Optional, Union, Tuple, List, cast\nfrom distutils.version import StrictVersion\n\n# Constants (as from file content)\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\nclass _VersionPart(tuple):\n    # Re-create NamedTuple like class for _VersionPart here for type clarity\n    # but here we just use tuple with named fields for easier access\n    # We won't use this class explicitly, but will in yield from _each_version_part\n    pass\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> 'List[_VersionPart]':\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    parts = []\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        parts.append(_VersionPart(\n            kwargs['pos'],\n            kwargs['txt'],\n            kwargs['num'],\n            kwargs['pre_txt'],\n            kwargs['pre_num'],\n            kwargs['name'],\n        ))\n    return parts\n\nclass _VersionPart(tuple):\n    def __new__(cls, pos, txt, num, pre_txt, pre_num, name):\n        return tuple.__new__(cls, (pos, txt, num, pre_txt, pre_num, name))\n\n    @property\n    def pos(self):\n        return self[0]\n    @property\n    def txt(self):\n        return self[1]\n    @property\n    def num(self):\n        return self[2]\n    @property\n    def pre_txt(self):\n        return self[3]\n    @property\n    def pre_num(self):\n        return self[4]\n    @property\n    def name(self):\n        return self[5]\n\nclass _VersionInfo(tuple):\n    def __new__(cls,\n                version: str,\n                major: _VersionPart,\n                minor: _VersionPart,\n                patch: _VersionPart,\n                pre_pos: int):\n        return tuple.__new__(cls, (version, major, minor, patch, pre_pos))\n\n    @property\n    def version(self):\n        return self[0]\n    @property\n    def major(self):\n        return self[1]\n    @property\n    def minor(self):\n        return self[2]\n    @property\n    def patch(self):\n        return self[3]\n    @property\n    def pre_pos(self):\n        return self[4]\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    parts = _each_version_part(ver_obj)\n    for part in parts:\n        if part.pre_txt:\n            pre_pos = part.pos\n    return _VersionInfo(version, parts[0], parts[1], parts[2], pre_pos)\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index\n    pos = _build_version_bump_position(position)\n\n    # Build version info (parsing the version)\n    ver_info = _build_version_info(version)\n\n    # Determine bump type from position and pre_release\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract original version parts for ease\n    major = ver_info.major\n    minor = ver_info.minor\n    patch = ver_info.patch\n    pre_pos = ver_info.pre_pos  # Position of pre-release part if any (-1 if none)\n\n    # Prepare components to modify\n    new_major = major.num\n    new_minor = minor.num\n    new_patch = patch.num\n\n    # Flags for prerelease bump\n    bump_prerelease = pre_release is not None and pre_release != ''\n    pre_rel_str = None\n    pre_rel_num = -1\n\n    # Existing pre-release info to be potentially modified\n    existing_pre_txt = None\n    existing_pre_num = -1\n    existing_pre_pos = -1\n\n    # Identify current prerelease info based on version info\n    if pre_pos >= 0:\n        if pre_pos == 1:\n            existing_pre_txt = minor.pre_txt\n            existing_pre_num = minor.pre_num\n            existing_pre_pos = pre_pos\n        elif pre_pos == 2:\n            existing_pre_txt = patch.pre_txt\n            existing_pre_num = patch.pre_num\n            existing_pre_pos = pre_pos\n\n    # Clear prerelease if pre_release argument is None or empty string\n    if not bump_prerelease:\n        # If original version has prerelease, but no pre_release parameter provided,\n        # bumping just removes the prerelease (resets to normal version)\n        if pre_pos >= 0:\n            # If bumping major or minor or patch, remove prerelease by just clearing it\n            # If bumping part below pre_pos, then the pre-release part gone.\n            pass  # no prerelease in result\n    else:\n        pre_release_lower = pre_release.strip().lower()\n\n        # Determine prerelease string and number to set\n        # Decide correct pre_release string according to bump_type:\n        if bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA):\n            pre_rel_str = 'a'\n        elif bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA):\n            pre_rel_str = 'b'\n        else:\n            # Should not happen, _build_version_bump_type already raises in major with prerelease\n            raise ValueError(f\"Invalid prerelease bump type deduced: {bump_type}\")\n\n    # Bump version numbers and handle prerelease accordingly\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Bump major: increase major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # prerelease removed (if any)\n        pre_rel_str = None\n        pre_rel_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Bump minor: increase minor, reset patch, no prerelease (unless pre_release passed)\n        new_minor += 1\n        new_patch = 0\n        # prerelease removed if any and no pre_release passed (else handled later)\n        if not bump_prerelease:\n            pre_rel_str = None\n            pre_rel_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Bump patch: increase patch, no prerelease (unless pre_release passed)\n        new_patch += 1\n        # prerelease removed if any and no pre_release passed\n        if not bump_prerelease:\n            pre_rel_str = None\n            pre_rel_num = -1\n\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA,\n                       _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Prerelease bumps for minor or patch\n\n        # Determine if bump is minor or patch prerelease\n        is_minor_pre = bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA)\n        is_patch_pre = bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA)\n\n        # Set version numbers accordingly\n        if is_minor_pre:\n            new_minor += 1\n            new_patch = 0\n        elif is_patch_pre:\n            new_patch += 1\n\n        # If original version already has prerelease on the same position and same pre_txt,\n        # increase pre_num by 1 if pre_release matches existing pre_txt,\n        # else reset pre_num to 0 and set new pre_txt\n\n        if existing_pre_pos == (1 if is_minor_pre else 2):\n            if existing_pre_txt == pre_rel_str:\n                pre_rel_num = existing_pre_num + 1\n            else:\n                pre_rel_num = 0\n        else:\n            # No existing prerelease or on different position\n            pre_rel_num = 0\n\n    else:\n        # Should not happen as _build_version_bump_type covers all cases\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # If no prerelease (pre_rel_str is None), make sure to clear prerelease info\n    # Compose the version string accordingly\n\n    # Compose version string parts\n    # Major always shown\n    if new_patch == 0 and pos <= 1:\n        # When patch==0 and position being bumped is major or minor,\n        # omit patch part (as in examples: '1.3' from 1.2.3 with position=1 bump)\n        version_parts = [str(new_major), str(new_minor)]\n    else:\n        version_parts = [str(new_major), str(new_minor), str(new_patch)]\n\n    # Append prerelease if present\n    if pre_rel_str is not None:\n        version_str = ''.join(version_parts)  # initial join to combine parts, but no dots?\n        # Actually we want to join with dots except prerelease at last part\n        version_str = '.'.join(version_parts)\n        version_str += f\"{pre_rel_str}{pre_rel_num}\"\n    else:\n        version_str = '.'.join(version_parts)\n\n    return version_str", "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _each_version_part,\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n\n    # Determine bump type (major/minor/patch/alpha/beta)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Parse current version info\n    ver_info = _build_version_info(version)\n\n    # Extract numeric version parts, ignoring pre-release suffix for base numbers\n    major_num = ver_info.major.num\n    minor_num = ver_info.minor.num\n    patch_num = ver_info.patch.num\n\n    # Current pre-release info, if any, and position\n    pre_pos = ver_info.pre_pos\n    pre_txt = ''\n    pre_num = -1\n    if pre_pos != -1:\n        # Get the VersionPart corresponding to pre-release\n        parts = [ver_info.major, ver_info.minor, ver_info.patch]\n        vpre_part = parts[pre_pos]\n        pre_txt = vpre_part.pre_txt\n        pre_num = vpre_part.pre_num\n\n    def new_version_str(major: int, minor: int, patch: int, pre_txt_: str = '', pre_num_: int = -1) -> str:\n        \"\"\"Format the version string accordingly:\n        - If patch is zero and position >= 1, omit patch,\n          unless pre-release is attached to patch.\n        - If pre-release present, append pre_txt and pre_num.\n        \"\"\"\n        version_core = ''\n        if patch == 0 and pos <= 1:\n            # If patch zero and we're bumping major or minor, omit patch\n            version_core = f\"{major}.{minor}\"\n        else:\n            version_core = f\"{major}.{minor}.{patch}\"\n\n        # Append pre-release suffix if present\n        if pre_txt_ and pre_num_ >= 0:\n            version_core += f\"{pre_txt_}{pre_num_}\"\n        return version_core\n\n    # Now handle bump logic by bump_type\n    # Refs for constants:\n    # _BUMP_VERSION_MAJOR = 0\n    # _BUMP_VERSION_MINOR = 1\n    # _BUMP_VERSION_PATCH = 2\n    # _BUMP_VERSION_MINOR_ALPHA = 3\n    # _BUMP_VERSION_MINOR_BETA = 4\n    # _BUMP_VERSION_PATCH_ALPHA = 5\n    # _BUMP_VERSION_PATCH_BETA = 6\n\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Major bump: increment major, reset minor and patch to zero, drop pre-release\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        return f\"{major_num}.0\"\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Minor bump: increment minor, reset patch to zero, drop pre-release\n        minor_num += 1\n        patch_num = 0\n        return f\"{major_num}.{minor_num}\"\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Patch bump: increment patch, drop pre-release\n        patch_num += 1\n        return f\"{major_num}.{minor_num}.{patch_num}\"\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Minor alpha or beta bump\n        minor_pre_type = 'a' if bump_type == _BUMP_VERSION_MINOR_ALPHA else 'b'\n        # If prerelease exists on minor part, increment it\n        if pre_pos == 1 and pre_txt == minor_pre_type:\n            new_pre_num = pre_num + 1\n            major_num_str = str(major_num)\n            return f\"{major_num}.{minor_num}{minor_pre_type}{new_pre_num}\"\n        # If prerelease exists on patch (pos=2), strip it and bump minor and add pre_release suffix 0\n        if pre_pos == 2:\n            # Strip patch pre-release to normal patch number first\n            # We increase minor and start pre-release with 0\n            minor_num += 1\n            return f\"{major_num}.{minor_num}{minor_pre_type}0\"\n        # No or different pre-release: bump minor and add pre-release 0\n        minor_num += 1\n        return f\"{major_num}.{minor_num}{minor_pre_type}0\"\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Patch alpha or beta bump\n        patch_pre_type = 'a' if bump_type == _BUMP_VERSION_PATCH_ALPHA else 'b'\n        # Cases:\n        if pre_pos == 2 and pre_txt == patch_pre_type:\n            # Same prerelease at patch position, increment pre_num\n            new_pre_num = pre_num + 1\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}{new_pre_num}\"\n        elif pre_pos == 2 and pre_txt != patch_pre_type:\n            # Different prerelease at patch, reset to new pre-release type at zero\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}0\"\n        elif pre_pos != 2:\n            # No prerelease or prerelease at other position\n            # If patch is zero and pre_pos -1 (no prerelease), bump patch to 0 for prerelease\n            # Based on example bump_version('1.2.3', prerelease='a') => '1.2.4a0'\n            # So we bump patch by 1 and add prerelease a0/b0\n            patch_num += 1\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}0\"\n    else:\n        # Should not reach here, but as fallback, raise\n        raise ValueError(\"Invalid bump type computed.\")\n\n    # Fallback return original version if no changes made,\n    # but logic should never reach here\n    return version", "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _build_version_info,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize and validate position to a positive index 0..2\n    pos = _build_version_bump_position(position)\n\n    # Convert version string to StrictVersion to validate\n    try:\n        ver_obj = StrictVersion(version)\n    except Exception as ex:\n        raise ValueError(f\"Invalid version number: {version!r}\") from ex\n\n    # Build detailed version info with our utility\n    version_info = _build_version_info(version)\n\n    # Determine the bump type (major, minor, patch, or prerelease variants)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current version parts: major, minor, patch\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Current prerelease info at the bump position (if any)\n    pre_txt = ''\n    pre_num = -1\n    # Determine if the current version has prerelease on the bump position\n    if version_info.pre_pos == pos:\n        # Get the _VersionPart matching pos: major=0, minor=1, patch=2\n        # We have them in version_info attributes: major, minor, patch\n        if pos == 0:\n            pre_txt = version_info.major.pre_txt\n            pre_num = version_info.major.pre_num\n        elif pos == 1:\n            pre_txt = version_info.minor.pre_txt\n            pre_num = version_info.minor.pre_num\n        else:\n            pre_txt = version_info.patch.pre_txt\n            pre_num = version_info.patch.pre_num\n\n    # Based on bump type, calculate new values:\n    # Constants for bump types representing each case, from file content:\n    _BUMP_VERSION_MAJOR = 0\n    _BUMP_VERSION_MINOR = 1\n    _BUMP_VERSION_PATCH = 2\n    _BUMP_VERSION_MINOR_ALPHA = 3\n    _BUMP_VERSION_MINOR_BETA = 4\n    _BUMP_VERSION_PATCH_ALPHA = 5\n    _BUMP_VERSION_PATCH_BETA = 6\n\n    # Initialize new version numbers\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n    new_pre_txt = ''\n    new_pre_num = -1\n\n    # Clear prerelease if bump type is plain major, minor, patch\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increase major by 1, reset minor and patch to 0\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # No prerelease in major bump\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increase minor by 1, reset patch to 0\n        new_minor += 1\n        new_patch = 0\n        # Clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increase patch by 1\n        new_patch += 1\n        # Clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n        # minor alpha prerelease bump\n        # Increase minor if bump position is 1, and prerelease 'a'\n        # If current version is already minor with alpha prerelease increment pre_num, else reset to 0\n        if pos != 1:\n            # This should not happen, as per bump_type definition, but guard\n            raise ValueError(\"Minor alpha bump must be position 1 (minor)\")\n\n        new_minor += 0  # stay the same minor number if prerelease bumps patch?\n        new_patch = 0   # patch reset\n\n        if pos == version_info.pre_pos and pre_txt in ('a', 'alpha'):\n            # already alpha prerelease on minor, increment pre_num\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            # starting alpha prerelease at 0\n            new_pre_num = 0\n\n        new_pre_txt = 'a'\n        # The minor number must be increased by 1 if current version's minor is different?\n        # Actually, example '2.1.3', position=1, pre_release='a' -> '2.2a0'\n        # so minor increments by 1 and prerelease sets to a0\n        # So increase minor by 1, reset patch to 0, prerelease a0\n        new_minor += 1\n        new_patch = 0\n\n    elif bump_type == _BUMP_VERSION_MINOR_BETA:\n        # Similar to minor alpha, but beta prerelease\n        if pos != 1:\n            raise ValueError(\"Minor beta bump must be position 1 (minor)\")\n\n        new_minor += 1\n        new_patch = 0\n\n        if pos == version_info.pre_pos and pre_txt in ('b', 'beta'):\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            new_pre_num = 0\n\n        new_pre_txt = 'b'\n\n    elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n        # patch alpha prerelease bump\n        # patch increments if prerelease not already patch alpha\n        # else increments prerelease number\n        if pos != 2:\n            raise ValueError(\"Patch alpha bump must be position 2 (patch)\")\n\n        if pos == version_info.pre_pos and pre_txt in ('a', 'alpha'):\n            # same prerelease bump\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            # new patch prerelease alpha means patch bump if prerelease is different\n            if pos == version_info.pre_pos:\n                # prerelease exists but different type: reset pre_num 0\n                new_pre_num = 0\n            else:\n                # bump patch\n                new_patch += 1\n                new_pre_num = 0\n\n        new_pre_txt = 'a'\n        new_major = major_num\n        new_minor = minor_num\n\n    elif bump_type == _BUMP_VERSION_PATCH_BETA:\n        # patch beta prerelease bump, similar to patch alpha\n        if pos != 2:\n            raise ValueError(\"Patch beta bump must be position 2 (patch)\")\n\n        if pos == version_info.pre_pos and pre_txt in ('b', 'beta'):\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            if pos == version_info.pre_pos:\n                new_pre_num = 0\n            else:\n                new_patch += 1\n                new_pre_num = 0\n\n        new_pre_txt = 'b'\n        new_major = major_num\n        new_minor = minor_num\n\n    else:\n        raise ValueError(f\"Invalid bump type: {bump_type}\")\n\n    # If pre_release is None or empty string -> clear prerelease\n    if pre_release is None or (isinstance(pre_release, str) and pre_release.strip() == ''):\n        # If the version had a prerelease, but bump was plain, clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    # Assemble version string parts\n    # Rules from _each_version_part and examples:\n    # - Major always shown\n    # - Minor omitted if 0 patch and 0 minor? StrictVersion expects major.minor.patch\n    # - But examples always show at least major.minor\n    # - Patch shown only if >0 or prerelease on patch or position >= 2\n    # - Prerelease suffix is attached to the field\n    #   E.g. '4a0', '4b0', etc.\n\n    # From examples:\n    # bump_version('1.2.3', position=1) -> '1.3'  (patch omitted if 0)\n    # bump_version('1.3.4', position=0) -> '2.0'  (minor zero)\n    # bump_version('1.2.3', prerelease='a') -> '1.2.4a0'\n\n    # Decide how to format version string:\n\n    # We will output:\n    # major.minor[prerelease][.patch[prerelease]]\n    # But patch can be omitted if zero and position < 2 and no patch prerelease\n\n    # Compose version parts with prerelease as suffix on the bumped position\n\n    # We'll assign prerelease suffix only where pre_txt and pre_num exist on that position.\n\n    # The prerelease suffix belongs on the part where prerelease was applied\n    # We determine where the prerelease is: new_pre_txt and new_pre_num\n    # If new_pre_txt is empty, no prerelease suffix.\n\n    def part_version(num: int, pr_txt: str, pr_num: int) -> str:\n        if num == 0:\n            base = '0'\n        else:\n            base = str(num)\n        if pr_txt and pr_num >= 0:\n            return f\"{base}{pr_txt}{pr_num}\"\n        return base\n\n    # We only place prerelease suffix on the part being bumped for prereleases,\n    # but from the examples it looks like the prerelease suffix goes on the bumped part.\n\n    # Determine prerelease suffix position: it is on the bumped position\n    # So we add prerelease suffix only on bumped position:\n    major_str = str(new_major)\n    minor_str = str(new_minor)\n    patch_str = str(new_patch) if new_patch != 0 else ''\n\n    # Attach prerelease suffix to the bumped position only\n    if new_pre_txt and new_pre_num >= 0:\n        if pos == 0:\n            major_str += f\"{new_pre_txt}{new_pre_num}\"\n            # If patch or minor were reset to zero, we respect the examples and omit patch if zero\n            # Minor and patch shown normally\n        elif pos == 1:\n            minor_str += f\"{new_pre_txt}{new_pre_num}\"\n        elif pos == 2:\n            patch_str += f\"{new_pre_txt}{new_pre_num}\"\n\n    # Format output\n    # Apply rules for omission of patch if zero and no prerelease on patch\n    if patch_str == '':\n        # if patch is zero and no prerelease on patch\n        return f\"{major_str}.{minor_str}\"\n    else:\n        return f\"{major_str}.{minor_str}.{patch_str}\"", "from typing import Optional\nfrom distutils.version import StrictVersion\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _each_version_part,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize and validate position\n    pos = _build_version_bump_position(position)\n\n    # Determine bump type from position and prerelease argument\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Parse version string into parts and info\n    try:\n        ver_info = _build_version_info(version)\n    except Exception as e:\n        # Convert any parsing error to ValueError explicitly\n        raise ValueError(f\"Invalid version string {version!r}: {e}\") from e\n\n    # Extract current parts for easy access\n    parts = {part.pos: part for part in (ver_info.major, ver_info.minor, ver_info.patch)}\n\n    # Determine current bump context parameters\n    # Position corresponds to 0=major,1=minor,2=patch\n\n    # Base version numbers\n    major_num = parts.get(0, None)\n    minor_num = parts.get(1, None)\n    patch_num = parts.get(2, None)\n\n    # For safety, if any part missing, fill with 0\n    major = major_num.num if major_num is not None else 0\n    minor = minor_num.num if minor_num is not None else 0\n    patch = patch_num.num if patch_num is not None else 0\n\n    # Current pre-release info at each position (if any)\n    # We'll also note where current prerelease is\n\n    pre_pos = ver_info.pre_pos  # -1 if no pre-release\n\n    # Helper to check if currently prerelease at given pos\n    def is_prerelease_at(pos):\n        if pre_pos != pos:\n            return False\n        part = parts[pos]\n        return part.pre_txt != '' and part.pre_num >= 0\n\n    # Implementation depending on bump_type:\n    # The bump_types map to:\n    # _BUMP_VERSION_MAJOR = 0\n    # _BUMP_VERSION_MINOR = 1\n    # _BUMP_VERSION_PATCH = 2\n    # _BUMP_VERSION_MINOR_ALPHA = 3\n    # _BUMP_VERSION_MINOR_BETA = 4\n    # _BUMP_VERSION_PATCH_ALPHA = 5\n    # _BUMP_VERSION_PATCH_BETA = 6\n\n    # We will build final version as a list/tuple of strings to join.\n\n    # Increment logic:\n\n    # Start with the base version as list [major, minor, patch]\n    new_major = major\n    new_minor = minor\n    new_patch = patch\n\n    # Determine how to bump or reset parts based on bump_type\n    # The \"position\" parameter determines which part to increase/reset.\n    # If bump is major (0):\n    #   major += 1\n    #   minor = 0\n    #   patch = 0\n    #   no pre-release allowed\n\n    # If bump is minor:\n    #   minor += 1\n    #   patch = 0\n    #   remove pre-release unless alpha/beta bumping minor\n\n    # If bump is patch:\n    #   patch += 1\n    #   remove pre-release unless alpha/beta bumping patch\n\n    # For alpha/beta bumps, we check if existing pre-release is the same type and increment the numeric suffix.\n    # If not, start a new pre-release numeric suffix at 0.\n\n    # if no pre_release given and current version has prerelease, strip it (set clean).\n\n    # Compose final version string accordingly.\n\n    # Implementation:\n\n    # Remove pre-release text if no pre_release argument given (clean bump)\n    # unless bump_type indicates prerelease bump (alpha/beta)\n\n    is_alpha_bump = bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA)\n    is_beta_bump = bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA)\n    is_prerelease_bump = is_alpha_bump or is_beta_bump\n\n    pre_txt = ''\n    pre_num = -1\n\n    # Process bump based on bump_type\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # major bump: increment major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # minor bump: increment minor, reset patch, remove prerelease\n        new_minor += 1\n        new_patch = 0\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # patch bump: increment patch, remove prerelease\n        new_patch += 1\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # minor alpha or beta bump\n        # increment minor, reset patch\n        new_minor += 1\n        new_patch = 0\n        pre_txt = 'a' if is_alpha_bump else 'b'\n        pre_num = 0\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # patch alpha or beta bump\n        new_patch += 1\n        pre_txt = 'a' if is_alpha_bump else 'b'\n        pre_num = 0\n    else:\n        # Unknown bump type (should not happen)\n        raise ValueError(f\"Unknown bump type {bump_type}\")\n\n    # Now, handle the case when we are bumping a prerelease (alpha/beta) but the version already has a prerelease at bump pos\n    # We want to increment the pre_num for the same pre_txt (alpha or beta).\n    # If pre_release is None, and version currently has prerelease, remove it.\n\n    # If bump expects a prerelease bump (alpha or beta), but the current part at bump pos has the same pre_txt,\n    # then increment pre_num instead of resetting it.\n\n    if is_prerelease_bump:\n        # Check if current prerelease is at the bumped position with same pre_txt\n        if is_prerelease_at(pos) and parts[pos].pre_txt == pre_txt:\n            # Increment pre_num from current pre_num\n            pre_num = parts[pos].pre_num + 1\n        # Else, pre_num remains as 0 (just initialized above)\n    else:\n        # If no prerelease bump, but version currently has prerelease, remove it\n        # Only if bump_type is a clean bump (_BUMP_VERSION_MAJOR/MINOR/PATCH)\n        if ver_info.pre_pos != -1:\n            # We have to remove prerelease info by ignoring it on output\n            pre_txt = ''\n            pre_num = -1\n\n        # Exception: if version had prerelease at a different position than bump pos,\n        # that prerelease should be removed since we bump different position.\n\n    # Compose the final version string\n\n    # For major bump (pos=0), if minor and patch are zero, output as \"X.0\"\n    # For minor bump (pos=1), if patch is zero, output as \"X.Y\"\n    # For patch bump, output full \"X.Y.Z\"\n\n    # The original _each_version_part handles patch=0 by returning empty string, but we must handle here.\n\n    # Construct the version parts:\n\n    # major part always included\n    parts_str = [str(new_major)]\n\n    # minor part included if minor > 0 or position < 2 (patch)\n    # From examples, if position=1, patch is omitted if 0\n    # Examples:\n    # bump_version('1.2.3', position=1) -> '1.3' (patch omitted)\n    # bump_version('1.2.3', position=0) -> '2.0' (patch omitted)\n    # bump_version('1.2b0', position=2) -> '1.2.1' (patch included)\n\n    # So, if minor or position <= 1 include minor\n    if (new_minor > 0) or (pos <= 1):\n        parts_str.append(str(new_minor))\n\n    # patch included if position ==2 or patch > 0\n    if (pos == 2) or (new_patch > 0):\n        parts_str.append(str(new_patch))\n\n    # Join main version string\n    base_version = '.'.join(parts_str)\n\n    # Append prerelease if any\n    if pre_txt and pre_num >= 0:\n        base_version += f\"{pre_txt}{pre_num}\"\n\n    return base_version", "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index and validate\n    pos = _build_version_bump_position(position)\n\n    # Parse current version and parts info\n    try:\n        vinfo = _build_version_info(version)\n    except Exception as e:\n        raise ValueError(f\"Invalid version number {version!r}: {e}\")\n\n    # Determine bump type based on position and prerelease option\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current parts as mutable variables\n    major_num = vinfo.major.num\n    minor_num = vinfo.minor.num\n    patch_num = vinfo.patch.num\n    major_pre_txt = vinfo.major.pre_txt\n    major_pre_num = vinfo.major.pre_num\n    minor_pre_txt = vinfo.minor.pre_txt\n    minor_pre_num = vinfo.minor.pre_num\n    patch_pre_txt = vinfo.patch.pre_txt\n    patch_pre_num = vinfo.patch.pre_num\n\n    # Currently existing pre-release info and positions\n    current_pre_pos = vinfo.pre_pos\n\n    # Helper to clear prerelease info from a part\n    def clear_prerelease(pos):\n        if pos == 0:\n            nonlocal major_pre_txt, major_pre_num\n            major_pre_txt, major_pre_num = '', -1\n        elif pos == 1:\n            nonlocal minor_pre_txt, minor_pre_num\n            minor_pre_txt, minor_pre_num = '', -1\n        elif pos == 2:\n            nonlocal patch_pre_txt, patch_pre_num\n            patch_pre_txt, patch_pre_num = '', -1\n\n    # Helper to set prerelease info for a part\n    def set_prerelease(pos, pre_txt, pre_num):\n        if pos == 0:\n            nonlocal major_pre_txt, major_pre_num\n            major_pre_txt, major_pre_num = pre_txt, pre_num\n        elif pos == 1:\n            nonlocal minor_pre_txt, minor_pre_num\n            minor_pre_txt, minor_pre_num = pre_txt, pre_num\n        elif pos == 2:\n            nonlocal patch_pre_txt, patch_pre_num\n            patch_pre_txt, patch_pre_num = pre_txt, pre_num\n\n    # Bump logic by bump_type\n    if bump_type == 0:  # _BUMP_VERSION_MAJOR = 0\n        # Increase major, reset minor & patch and clear pre-releases\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        clear_prerelease(0)\n        clear_prerelease(1)\n        clear_prerelease(2)\n        result = f'{major_num}.0'\n        # Patch and minor 0 omitted when patch == 0 in StrictVersion style\n\n    elif bump_type == 1:  # _BUMP_VERSION_MINOR = 1\n        major_num = major_num  # no change\n        minor_num += 1\n        patch_num = 0\n        clear_prerelease(1)\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}'\n        # patch=0 omitted for trailing version\n\n    elif bump_type == 2:  # _BUMP_VERSION_PATCH = 2\n        major_num = major_num\n        minor_num = minor_num if minor_num is not None else 0\n        patch_num += 1\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}.{patch_num}'\n\n    elif bump_type == 3:  # _BUMP_VERSION_MINOR_ALPHA = 3\n        # position must be 1, create or increment minor alpha\n        # Clear other pre-release pos if any\n        if current_pre_pos != 1:\n            # start at alpha0\n            set_prerelease(1, 'a', 0)\n        else:\n            # if already minor alpha, increment pre_num\n            new_num = minor_pre_num + 1 if minor_pre_num >= 0 else 0\n            set_prerelease(1, 'a', new_num)\n        # bump minor if not changed? Actually if prerelease exists, minor already bumped?\n        minor_num += 1 if (current_pre_pos != 1) else 0\n        patch_num = 0\n        # clear patch prerelease\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}a{minor_pre_num if minor_pre_num != -1 else 0}'\n\n    elif bump_type == 4:  # _BUMP_VERSION_MINOR_BETA = 4\n        # Same as minor alpha but with 'b'\n        if current_pre_pos != 1:\n            set_prerelease(1, 'b', 0)\n        else:\n            new_num = minor_pre_num + 1 if minor_pre_num >= 0 else 0\n            set_prerelease(1, 'b', new_num)\n        minor_num += 1 if (current_pre_pos != 1) else 0\n        patch_num = 0\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}b{minor_pre_num if minor_pre_num != -1 else 0}'\n\n    elif bump_type == 5:  # _BUMP_VERSION_PATCH_ALPHA = 5\n        # Patch alpha prerelease\n        if current_pre_pos != 2:\n            set_prerelease(2, 'a', 0)\n        else:\n            new_num = patch_pre_num + 1 if patch_pre_num >= 0 else 0\n            set_prerelease(2, 'a', new_num)\n        # bump patch if not already patch prerelease\n        patch_num += 1 if (current_pre_pos != 2) else 0\n        result = f'{major_num}.{minor_num}.{patch_num}a{patch_pre_num if patch_pre_num != -1 else 0}'\n\n    elif bump_type == 6:  # _BUMP_VERSION_PATCH_BETA = 6\n        # Patch beta prerelease\n        if current_pre_pos != 2:\n            set_prerelease(2, 'b', 0)\n        else:\n            new_num = patch_pre_num + 1 if patch_pre_num >= 0 else 0\n            set_prerelease(2, 'b', new_num)\n        patch_num += 1 if (current_pre_pos != 2) else 0\n        result = f'{major_num}.{minor_num}.{patch_num}b{patch_pre_num if patch_pre_num != -1 else 0}'\n\n    else:\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # Special handling if no prerelease requested and current version has a prerelease but bumping same position:\n    # then remove prerelease (final release)\n    # But only if no explicit pre_release is specified (None)\n    # and bump is at the same pre_pos.\n    # According to examples:\n    # This means bump_version('1.2.4a1') -> '1.2.4' if no pre_release given\n    # Only if bumping patch in that case (default)\n    if pre_release is None:\n        # If current version had prerelease and bumping that prerelease position, drop prerelease\n        if current_pre_pos == pos:\n            # Compose version without prerelease\n            if pos == 0:\n                # Major, no prerelease, no minor or patch in StrictVersion format? Use 'major.0'\n                result = f'{major_num}.0'\n            elif pos == 1:\n                # Minor bump: major.minor no patch as patch=0 omited\n                result = f'{major_num}.{minor_num}'\n            elif pos == 2:\n                result = f'{major_num}.{minor_num}.{patch_num}'\n\n    return result"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional, Union, Tuple, List, cast\nfrom distutils.version import StrictVersion\n\n# Constants (as from file content)\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\nclass _VersionPart(tuple):\n    # Re-create NamedTuple like class for _VersionPart here for type clarity\n    # but here we just use tuple with named fields for easier access\n    # We won't use this class explicitly, but will in yield from _each_version_part\n    pass\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> 'List[_VersionPart]':\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    parts = []\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        parts.append(_VersionPart(\n            kwargs['pos'],\n            kwargs['txt'],\n            kwargs['num'],\n            kwargs['pre_txt'],\n            kwargs['pre_num'],\n            kwargs['name'],\n        ))\n    return parts\n\nclass _VersionPart(tuple):\n    def __new__(cls, pos, txt, num, pre_txt, pre_num, name):\n        return tuple.__new__(cls, (pos, txt, num, pre_txt, pre_num, name))\n\n    @property\n    def pos(self):\n        return self[0]\n    @property\n    def txt(self):\n        return self[1]\n    @property\n    def num(self):\n        return self[2]\n    @property\n    def pre_txt(self):\n        return self[3]\n    @property\n    def pre_num(self):\n        return self[4]\n    @property\n    def name(self):\n        return self[5]\n\nclass _VersionInfo(tuple):\n    def __new__(cls,\n                version: str,\n                major: _VersionPart,\n                minor: _VersionPart,\n                patch: _VersionPart,\n                pre_pos: int):\n        return tuple.__new__(cls, (version, major, minor, patch, pre_pos))\n\n    @property\n    def version(self):\n        return self[0]\n    @property\n    def major(self):\n        return self[1]\n    @property\n    def minor(self):\n        return self[2]\n    @property\n    def patch(self):\n        return self[3]\n    @property\n    def pre_pos(self):\n        return self[4]\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    parts = _each_version_part(ver_obj)\n    for part in parts:\n        if part.pre_txt:\n            pre_pos = part.pos\n    return _VersionInfo(version, parts[0], parts[1], parts[2], pre_pos)\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index\n    pos = _build_version_bump_position(position)\n\n    # Build version info (parsing the version)\n    ver_info = _build_version_info(version)\n\n    # Determine bump type from position and pre_release\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract original version parts for ease\n    major = ver_info.major\n    minor = ver_info.minor\n    patch = ver_info.patch\n    pre_pos = ver_info.pre_pos  # Position of pre-release part if any (-1 if none)\n\n    # Prepare components to modify\n    new_major = major.num\n    new_minor = minor.num\n    new_patch = patch.num\n\n    # Flags for prerelease bump\n    bump_prerelease = pre_release is not None and pre_release != ''\n    pre_rel_str = None\n    pre_rel_num = -1\n\n    # Existing pre-release info to be potentially modified\n    existing_pre_txt = None\n    existing_pre_num = -1\n    existing_pre_pos = -1\n\n    # Identify current prerelease info based on version info\n    if pre_pos >= 0:\n        if pre_pos == 1:\n            existing_pre_txt = minor.pre_txt\n            existing_pre_num = minor.pre_num\n            existing_pre_pos = pre_pos\n        elif pre_pos == 2:\n            existing_pre_txt = patch.pre_txt\n            existing_pre_num = patch.pre_num\n            existing_pre_pos = pre_pos\n\n    # Clear prerelease if pre_release argument is None or empty string\n    if not bump_prerelease:\n        # If original version has prerelease, but no pre_release parameter provided,\n        # bumping just removes the prerelease (resets to normal version)\n        if pre_pos >= 0:\n            # If bumping major or minor or patch, remove prerelease by just clearing it\n            # If bumping part below pre_pos, then the pre-release part gone.\n            pass  # no prerelease in result\n    else:\n        pre_release_lower = pre_release.strip().lower()\n\n        # Determine prerelease string and number to set\n        # Decide correct pre_release string according to bump_type:\n        if bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA):\n            pre_rel_str = 'a'\n        elif bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA):\n            pre_rel_str = 'b'\n        else:\n            # Should not happen, _build_version_bump_type already raises in major with prerelease\n            raise ValueError(f\"Invalid prerelease bump type deduced: {bump_type}\")\n\n    # Bump version numbers and handle prerelease accordingly\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Bump major: increase major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # prerelease removed (if any)\n        pre_rel_str = None\n        pre_rel_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Bump minor: increase minor, reset patch, no prerelease (unless pre_release passed)\n        new_minor += 1\n        new_patch = 0\n        # prerelease removed if any and no pre_release passed (else handled later)\n        if not bump_prerelease:\n            pre_rel_str = None\n            pre_rel_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Bump patch: increase patch, no prerelease (unless pre_release passed)\n        new_patch += 1\n        # prerelease removed if any and no pre_release passed\n        if not bump_prerelease:\n            pre_rel_str = None\n            pre_rel_num = -1\n\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA,\n                       _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Prerelease bumps for minor or patch\n\n        # Determine if bump is minor or patch prerelease\n        is_minor_pre = bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA)\n        is_patch_pre = bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA)\n\n        # Set version numbers accordingly\n        if is_minor_pre:\n            new_minor += 1\n            new_patch = 0\n        elif is_patch_pre:\n            new_patch += 1\n\n        # If original version already has prerelease on the same position and same pre_txt,\n        # increase pre_num by 1 if pre_release matches existing pre_txt,\n        # else reset pre_num to 0 and set new pre_txt\n\n        if existing_pre_pos == (1 if is_minor_pre else 2):\n            if existing_pre_txt == pre_rel_str:\n                pre_rel_num = existing_pre_num + 1\n            else:\n                pre_rel_num = 0\n        else:\n            # No existing prerelease or on different position\n            pre_rel_num = 0\n\n    else:\n        # Should not happen as _build_version_bump_type covers all cases\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # If no prerelease (pre_rel_str is None), make sure to clear prerelease info\n    # Compose the version string accordingly\n\n    # Compose version string parts\n    # Major always shown\n    if new_patch == 0 and pos <= 1:\n        # When patch==0 and position being bumped is major or minor,\n        # omit patch part (as in examples: '1.3' from 1.2.3 with position=1 bump)\n        version_parts = [str(new_major), str(new_minor)]\n    else:\n        version_parts = [str(new_major), str(new_minor), str(new_patch)]\n\n    # Append prerelease if present\n    if pre_rel_str is not None:\n        version_str = ''.join(version_parts)  # initial join to combine parts, but no dots?\n        # Actually we want to join with dots except prerelease at last part\n        version_str = '.'.join(version_parts)\n        version_str += f\"{pre_rel_str}{pre_rel_num}\"\n    else:\n        version_str = '.'.join(version_parts)\n\n    return version_str\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _each_version_part,\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n\n    # Determine bump type (major/minor/patch/alpha/beta)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Parse current version info\n    ver_info = _build_version_info(version)\n\n    # Extract numeric version parts, ignoring pre-release suffix for base numbers\n    major_num = ver_info.major.num\n    minor_num = ver_info.minor.num\n    patch_num = ver_info.patch.num\n\n    # Current pre-release info, if any, and position\n    pre_pos = ver_info.pre_pos\n    pre_txt = ''\n    pre_num = -1\n    if pre_pos != -1:\n        # Get the VersionPart corresponding to pre-release\n        parts = [ver_info.major, ver_info.minor, ver_info.patch]\n        vpre_part = parts[pre_pos]\n        pre_txt = vpre_part.pre_txt\n        pre_num = vpre_part.pre_num\n\n    def new_version_str(major: int, minor: int, patch: int, pre_txt_: str = '', pre_num_: int = -1) -> str:\n        \"\"\"Format the version string accordingly:\n        - If patch is zero and position >= 1, omit patch,\n          unless pre-release is attached to patch.\n        - If pre-release present, append pre_txt and pre_num.\n        \"\"\"\n        version_core = ''\n        if patch == 0 and pos <= 1:\n            # If patch zero and we're bumping major or minor, omit patch\n            version_core = f\"{major}.{minor}\"\n        else:\n            version_core = f\"{major}.{minor}.{patch}\"\n\n        # Append pre-release suffix if present\n        if pre_txt_ and pre_num_ >= 0:\n            version_core += f\"{pre_txt_}{pre_num_}\"\n        return version_core\n\n    # Now handle bump logic by bump_type\n    # Refs for constants:\n    # _BUMP_VERSION_MAJOR = 0\n    # _BUMP_VERSION_MINOR = 1\n    # _BUMP_VERSION_PATCH = 2\n    # _BUMP_VERSION_MINOR_ALPHA = 3\n    # _BUMP_VERSION_MINOR_BETA = 4\n    # _BUMP_VERSION_PATCH_ALPHA = 5\n    # _BUMP_VERSION_PATCH_BETA = 6\n\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Major bump: increment major, reset minor and patch to zero, drop pre-release\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        return f\"{major_num}.0\"\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Minor bump: increment minor, reset patch to zero, drop pre-release\n        minor_num += 1\n        patch_num = 0\n        return f\"{major_num}.{minor_num}\"\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Patch bump: increment patch, drop pre-release\n        patch_num += 1\n        return f\"{major_num}.{minor_num}.{patch_num}\"\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Minor alpha or beta bump\n        minor_pre_type = 'a' if bump_type == _BUMP_VERSION_MINOR_ALPHA else 'b'\n        # If prerelease exists on minor part, increment it\n        if pre_pos == 1 and pre_txt == minor_pre_type:\n            new_pre_num = pre_num + 1\n            major_num_str = str(major_num)\n            return f\"{major_num}.{minor_num}{minor_pre_type}{new_pre_num}\"\n        # If prerelease exists on patch (pos=2), strip it and bump minor and add pre_release suffix 0\n        if pre_pos == 2:\n            # Strip patch pre-release to normal patch number first\n            # We increase minor and start pre-release with 0\n            minor_num += 1\n            return f\"{major_num}.{minor_num}{minor_pre_type}0\"\n        # No or different pre-release: bump minor and add pre-release 0\n        minor_num += 1\n        return f\"{major_num}.{minor_num}{minor_pre_type}0\"\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Patch alpha or beta bump\n        patch_pre_type = 'a' if bump_type == _BUMP_VERSION_PATCH_ALPHA else 'b'\n        # Cases:\n        if pre_pos == 2 and pre_txt == patch_pre_type:\n            # Same prerelease at patch position, increment pre_num\n            new_pre_num = pre_num + 1\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}{new_pre_num}\"\n        elif pre_pos == 2 and pre_txt != patch_pre_type:\n            # Different prerelease at patch, reset to new pre-release type at zero\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}0\"\n        elif pre_pos != 2:\n            # No prerelease or prerelease at other position\n            # If patch is zero and pre_pos -1 (no prerelease), bump patch to 0 for prerelease\n            # Based on example bump_version('1.2.3', prerelease='a') => '1.2.4a0'\n            # So we bump patch by 1 and add prerelease a0/b0\n            patch_num += 1\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}0\"\n    else:\n        # Should not reach here, but as fallback, raise\n        raise ValueError(\"Invalid bump type computed.\")\n\n    # Fallback return original version if no changes made,\n    # but logic should never reach here\n    return version\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _build_version_info,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize and validate position to a positive index 0..2\n    pos = _build_version_bump_position(position)\n\n    # Convert version string to StrictVersion to validate\n    try:\n        ver_obj = StrictVersion(version)\n    except Exception as ex:\n        raise ValueError(f\"Invalid version number: {version!r}\") from ex\n\n    # Build detailed version info with our utility\n    version_info = _build_version_info(version)\n\n    # Determine the bump type (major, minor, patch, or prerelease variants)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current version parts: major, minor, patch\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Current prerelease info at the bump position (if any)\n    pre_txt = ''\n    pre_num = -1\n    # Determine if the current version has prerelease on the bump position\n    if version_info.pre_pos == pos:\n        # Get the _VersionPart matching pos: major=0, minor=1, patch=2\n        # We have them in version_info attributes: major, minor, patch\n        if pos == 0:\n            pre_txt = version_info.major.pre_txt\n            pre_num = version_info.major.pre_num\n        elif pos == 1:\n            pre_txt = version_info.minor.pre_txt\n            pre_num = version_info.minor.pre_num\n        else:\n            pre_txt = version_info.patch.pre_txt\n            pre_num = version_info.patch.pre_num\n\n    # Based on bump type, calculate new values:\n    # Constants for bump types representing each case, from file content:\n    _BUMP_VERSION_MAJOR = 0\n    _BUMP_VERSION_MINOR = 1\n    _BUMP_VERSION_PATCH = 2\n    _BUMP_VERSION_MINOR_ALPHA = 3\n    _BUMP_VERSION_MINOR_BETA = 4\n    _BUMP_VERSION_PATCH_ALPHA = 5\n    _BUMP_VERSION_PATCH_BETA = 6\n\n    # Initialize new version numbers\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n    new_pre_txt = ''\n    new_pre_num = -1\n\n    # Clear prerelease if bump type is plain major, minor, patch\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increase major by 1, reset minor and patch to 0\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # No prerelease in major bump\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increase minor by 1, reset patch to 0\n        new_minor += 1\n        new_patch = 0\n        # Clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increase patch by 1\n        new_patch += 1\n        # Clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n        # minor alpha prerelease bump\n        # Increase minor if bump position is 1, and prerelease 'a'\n        # If current version is already minor with alpha prerelease increment pre_num, else reset to 0\n        if pos != 1:\n            # This should not happen, as per bump_type definition, but guard\n            raise ValueError(\"Minor alpha bump must be position 1 (minor)\")\n\n        new_minor += 0  # stay the same minor number if prerelease bumps patch?\n        new_patch = 0   # patch reset\n\n        if pos == version_info.pre_pos and pre_txt in ('a', 'alpha'):\n            # already alpha prerelease on minor, increment pre_num\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            # starting alpha prerelease at 0\n            new_pre_num = 0\n\n        new_pre_txt = 'a'\n        # The minor number must be increased by 1 if current version's minor is different?\n        # Actually, example '2.1.3', position=1, pre_release='a' -> '2.2a0'\n        # so minor increments by 1 and prerelease sets to a0\n        # So increase minor by 1, reset patch to 0, prerelease a0\n        new_minor += 1\n        new_patch = 0\n\n    elif bump_type == _BUMP_VERSION_MINOR_BETA:\n        # Similar to minor alpha, but beta prerelease\n        if pos != 1:\n            raise ValueError(\"Minor beta bump must be position 1 (minor)\")\n\n        new_minor += 1\n        new_patch = 0\n\n        if pos == version_info.pre_pos and pre_txt in ('b', 'beta'):\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            new_pre_num = 0\n\n        new_pre_txt = 'b'\n\n    elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n        # patch alpha prerelease bump\n        # patch increments if prerelease not already patch alpha\n        # else increments prerelease number\n        if pos != 2:\n            raise ValueError(\"Patch alpha bump must be position 2 (patch)\")\n\n        if pos == version_info.pre_pos and pre_txt in ('a', 'alpha'):\n            # same prerelease bump\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            # new patch prerelease alpha means patch bump if prerelease is different\n            if pos == version_info.pre_pos:\n                # prerelease exists but different type: reset pre_num 0\n                new_pre_num = 0\n            else:\n                # bump patch\n                new_patch += 1\n                new_pre_num = 0\n\n        new_pre_txt = 'a'\n        new_major = major_num\n        new_minor = minor_num\n\n    elif bump_type == _BUMP_VERSION_PATCH_BETA:\n        # patch beta prerelease bump, similar to patch alpha\n        if pos != 2:\n            raise ValueError(\"Patch beta bump must be position 2 (patch)\")\n\n        if pos == version_info.pre_pos and pre_txt in ('b', 'beta'):\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            if pos == version_info.pre_pos:\n                new_pre_num = 0\n            else:\n                new_patch += 1\n                new_pre_num = 0\n\n        new_pre_txt = 'b'\n        new_major = major_num\n        new_minor = minor_num\n\n    else:\n        raise ValueError(f\"Invalid bump type: {bump_type}\")\n\n    # If pre_release is None or empty string -> clear prerelease\n    if pre_release is None or (isinstance(pre_release, str) and pre_release.strip() == ''):\n        # If the version had a prerelease, but bump was plain, clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    # Assemble version string parts\n    # Rules from _each_version_part and examples:\n    # - Major always shown\n    # - Minor omitted if 0 patch and 0 minor? StrictVersion expects major.minor.patch\n    # - But examples always show at least major.minor\n    # - Patch shown only if >0 or prerelease on patch or position >= 2\n    # - Prerelease suffix is attached to the field\n    #   E.g. '4a0', '4b0', etc.\n\n    # From examples:\n    # bump_version('1.2.3', position=1) -> '1.3'  (patch omitted if 0)\n    # bump_version('1.3.4', position=0) -> '2.0'  (minor zero)\n    # bump_version('1.2.3', prerelease='a') -> '1.2.4a0'\n\n    # Decide how to format version string:\n\n    # We will output:\n    # major.minor[prerelease][.patch[prerelease]]\n    # But patch can be omitted if zero and position < 2 and no patch prerelease\n\n    # Compose version parts with prerelease as suffix on the bumped position\n\n    # We'll assign prerelease suffix only where pre_txt and pre_num exist on that position.\n\n    # The prerelease suffix belongs on the part where prerelease was applied\n    # We determine where the prerelease is: new_pre_txt and new_pre_num\n    # If new_pre_txt is empty, no prerelease suffix.\n\n    def part_version(num: int, pr_txt: str, pr_num: int) -> str:\n        if num == 0:\n            base = '0'\n        else:\n            base = str(num)\n        if pr_txt and pr_num >= 0:\n            return f\"{base}{pr_txt}{pr_num}\"\n        return base\n\n    # We only place prerelease suffix on the part being bumped for prereleases,\n    # but from the examples it looks like the prerelease suffix goes on the bumped part.\n\n    # Determine prerelease suffix position: it is on the bumped position\n    # So we add prerelease suffix only on bumped position:\n    major_str = str(new_major)\n    minor_str = str(new_minor)\n    patch_str = str(new_patch) if new_patch != 0 else ''\n\n    # Attach prerelease suffix to the bumped position only\n    if new_pre_txt and new_pre_num >= 0:\n        if pos == 0:\n            major_str += f\"{new_pre_txt}{new_pre_num}\"\n            # If patch or minor were reset to zero, we respect the examples and omit patch if zero\n            # Minor and patch shown normally\n        elif pos == 1:\n            minor_str += f\"{new_pre_txt}{new_pre_num}\"\n        elif pos == 2:\n            patch_str += f\"{new_pre_txt}{new_pre_num}\"\n\n    # Format output\n    # Apply rules for omission of patch if zero and no prerelease on patch\n    if patch_str == '':\n        # if patch is zero and no prerelease on patch\n        return f\"{major_str}.{minor_str}\"\n    else:\n        return f\"{major_str}.{minor_str}.{patch_str}\"\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional\nfrom distutils.version import StrictVersion\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _each_version_part,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize and validate position\n    pos = _build_version_bump_position(position)\n\n    # Determine bump type from position and prerelease argument\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Parse version string into parts and info\n    try:\n        ver_info = _build_version_info(version)\n    except Exception as e:\n        # Convert any parsing error to ValueError explicitly\n        raise ValueError(f\"Invalid version string {version!r}: {e}\") from e\n\n    # Extract current parts for easy access\n    parts = {part.pos: part for part in (ver_info.major, ver_info.minor, ver_info.patch)}\n\n    # Determine current bump context parameters\n    # Position corresponds to 0=major,1=minor,2=patch\n\n    # Base version numbers\n    major_num = parts.get(0, None)\n    minor_num = parts.get(1, None)\n    patch_num = parts.get(2, None)\n\n    # For safety, if any part missing, fill with 0\n    major = major_num.num if major_num is not None else 0\n    minor = minor_num.num if minor_num is not None else 0\n    patch = patch_num.num if patch_num is not None else 0\n\n    # Current pre-release info at each position (if any)\n    # We'll also note where current prerelease is\n\n    pre_pos = ver_info.pre_pos  # -1 if no pre-release\n\n    # Helper to check if currently prerelease at given pos\n    def is_prerelease_at(pos):\n        if pre_pos != pos:\n            return False\n        part = parts[pos]\n        return part.pre_txt != '' and part.pre_num >= 0\n\n    # Implementation depending on bump_type:\n    # The bump_types map to:\n    # _BUMP_VERSION_MAJOR = 0\n    # _BUMP_VERSION_MINOR = 1\n    # _BUMP_VERSION_PATCH = 2\n    # _BUMP_VERSION_MINOR_ALPHA = 3\n    # _BUMP_VERSION_MINOR_BETA = 4\n    # _BUMP_VERSION_PATCH_ALPHA = 5\n    # _BUMP_VERSION_PATCH_BETA = 6\n\n    # We will build final version as a list/tuple of strings to join.\n\n    # Increment logic:\n\n    # Start with the base version as list [major, minor, patch]\n    new_major = major\n    new_minor = minor\n    new_patch = patch\n\n    # Determine how to bump or reset parts based on bump_type\n    # The \"position\" parameter determines which part to increase/reset.\n    # If bump is major (0):\n    #   major += 1\n    #   minor = 0\n    #   patch = 0\n    #   no pre-release allowed\n\n    # If bump is minor:\n    #   minor += 1\n    #   patch = 0\n    #   remove pre-release unless alpha/beta bumping minor\n\n    # If bump is patch:\n    #   patch += 1\n    #   remove pre-release unless alpha/beta bumping patch\n\n    # For alpha/beta bumps, we check if existing pre-release is the same type and increment the numeric suffix.\n    # If not, start a new pre-release numeric suffix at 0.\n\n    # if no pre_release given and current version has prerelease, strip it (set clean).\n\n    # Compose final version string accordingly.\n\n    # Implementation:\n\n    # Remove pre-release text if no pre_release argument given (clean bump)\n    # unless bump_type indicates prerelease bump (alpha/beta)\n\n    is_alpha_bump = bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA)\n    is_beta_bump = bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA)\n    is_prerelease_bump = is_alpha_bump or is_beta_bump\n\n    pre_txt = ''\n    pre_num = -1\n\n    # Process bump based on bump_type\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # major bump: increment major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # minor bump: increment minor, reset patch, remove prerelease\n        new_minor += 1\n        new_patch = 0\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # patch bump: increment patch, remove prerelease\n        new_patch += 1\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # minor alpha or beta bump\n        # increment minor, reset patch\n        new_minor += 1\n        new_patch = 0\n        pre_txt = 'a' if is_alpha_bump else 'b'\n        pre_num = 0\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # patch alpha or beta bump\n        new_patch += 1\n        pre_txt = 'a' if is_alpha_bump else 'b'\n        pre_num = 0\n    else:\n        # Unknown bump type (should not happen)\n        raise ValueError(f\"Unknown bump type {bump_type}\")\n\n    # Now, handle the case when we are bumping a prerelease (alpha/beta) but the version already has a prerelease at bump pos\n    # We want to increment the pre_num for the same pre_txt (alpha or beta).\n    # If pre_release is None, and version currently has prerelease, remove it.\n\n    # If bump expects a prerelease bump (alpha or beta), but the current part at bump pos has the same pre_txt,\n    # then increment pre_num instead of resetting it.\n\n    if is_prerelease_bump:\n        # Check if current prerelease is at the bumped position with same pre_txt\n        if is_prerelease_at(pos) and parts[pos].pre_txt == pre_txt:\n            # Increment pre_num from current pre_num\n            pre_num = parts[pos].pre_num + 1\n        # Else, pre_num remains as 0 (just initialized above)\n    else:\n        # If no prerelease bump, but version currently has prerelease, remove it\n        # Only if bump_type is a clean bump (_BUMP_VERSION_MAJOR/MINOR/PATCH)\n        if ver_info.pre_pos != -1:\n            # We have to remove prerelease info by ignoring it on output\n            pre_txt = ''\n            pre_num = -1\n\n        # Exception: if version had prerelease at a different position than bump pos,\n        # that prerelease should be removed since we bump different position.\n\n    # Compose the final version string\n\n    # For major bump (pos=0), if minor and patch are zero, output as \"X.0\"\n    # For minor bump (pos=1), if patch is zero, output as \"X.Y\"\n    # For patch bump, output full \"X.Y.Z\"\n\n    # The original _each_version_part handles patch=0 by returning empty string, but we must handle here.\n\n    # Construct the version parts:\n\n    # major part always included\n    parts_str = [str(new_major)]\n\n    # minor part included if minor > 0 or position < 2 (patch)\n    # From examples, if position=1, patch is omitted if 0\n    # Examples:\n    # bump_version('1.2.3', position=1) -> '1.3' (patch omitted)\n    # bump_version('1.2.3', position=0) -> '2.0' (patch omitted)\n    # bump_version('1.2b0', position=2) -> '1.2.1' (patch included)\n\n    # So, if minor or position <= 1 include minor\n    if (new_minor > 0) or (pos <= 1):\n        parts_str.append(str(new_minor))\n\n    # patch included if position ==2 or patch > 0\n    if (pos == 2) or (new_patch > 0):\n        parts_str.append(str(new_patch))\n\n    # Join main version string\n    base_version = '.'.join(parts_str)\n\n    # Append prerelease if any\n    if pre_txt and pre_num >= 0:\n        base_version += f\"{pre_txt}{pre_num}\"\n\n    return base_version\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index and validate\n    pos = _build_version_bump_position(position)\n\n    # Parse current version and parts info\n    try:\n        vinfo = _build_version_info(version)\n    except Exception as e:\n        raise ValueError(f\"Invalid version number {version!r}: {e}\")\n\n    # Determine bump type based on position and prerelease option\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current parts as mutable variables\n    major_num = vinfo.major.num\n    minor_num = vinfo.minor.num\n    patch_num = vinfo.patch.num\n    major_pre_txt = vinfo.major.pre_txt\n    major_pre_num = vinfo.major.pre_num\n    minor_pre_txt = vinfo.minor.pre_txt\n    minor_pre_num = vinfo.minor.pre_num\n    patch_pre_txt = vinfo.patch.pre_txt\n    patch_pre_num = vinfo.patch.pre_num\n\n    # Currently existing pre-release info and positions\n    current_pre_pos = vinfo.pre_pos\n\n    # Helper to clear prerelease info from a part\n    def clear_prerelease(pos):\n        if pos == 0:\n            nonlocal major_pre_txt, major_pre_num\n            major_pre_txt, major_pre_num = '', -1\n        elif pos == 1:\n            nonlocal minor_pre_txt, minor_pre_num\n            minor_pre_txt, minor_pre_num = '', -1\n        elif pos == 2:\n            nonlocal patch_pre_txt, patch_pre_num\n            patch_pre_txt, patch_pre_num = '', -1\n\n    # Helper to set prerelease info for a part\n    def set_prerelease(pos, pre_txt, pre_num):\n        if pos == 0:\n            nonlocal major_pre_txt, major_pre_num\n            major_pre_txt, major_pre_num = pre_txt, pre_num\n        elif pos == 1:\n            nonlocal minor_pre_txt, minor_pre_num\n            minor_pre_txt, minor_pre_num = pre_txt, pre_num\n        elif pos == 2:\n            nonlocal patch_pre_txt, patch_pre_num\n            patch_pre_txt, patch_pre_num = pre_txt, pre_num\n\n    # Bump logic by bump_type\n    if bump_type == 0:  # _BUMP_VERSION_MAJOR = 0\n        # Increase major, reset minor & patch and clear pre-releases\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        clear_prerelease(0)\n        clear_prerelease(1)\n        clear_prerelease(2)\n        result = f'{major_num}.0'\n        # Patch and minor 0 omitted when patch == 0 in StrictVersion style\n\n    elif bump_type == 1:  # _BUMP_VERSION_MINOR = 1\n        major_num = major_num  # no change\n        minor_num += 1\n        patch_num = 0\n        clear_prerelease(1)\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}'\n        # patch=0 omitted for trailing version\n\n    elif bump_type == 2:  # _BUMP_VERSION_PATCH = 2\n        major_num = major_num\n        minor_num = minor_num if minor_num is not None else 0\n        patch_num += 1\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}.{patch_num}'\n\n    elif bump_type == 3:  # _BUMP_VERSION_MINOR_ALPHA = 3\n        # position must be 1, create or increment minor alpha\n        # Clear other pre-release pos if any\n        if current_pre_pos != 1:\n            # start at alpha0\n            set_prerelease(1, 'a', 0)\n        else:\n            # if already minor alpha, increment pre_num\n            new_num = minor_pre_num + 1 if minor_pre_num >= 0 else 0\n            set_prerelease(1, 'a', new_num)\n        # bump minor if not changed? Actually if prerelease exists, minor already bumped?\n        minor_num += 1 if (current_pre_pos != 1) else 0\n        patch_num = 0\n        # clear patch prerelease\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}a{minor_pre_num if minor_pre_num != -1 else 0}'\n\n    elif bump_type == 4:  # _BUMP_VERSION_MINOR_BETA = 4\n        # Same as minor alpha but with 'b'\n        if current_pre_pos != 1:\n            set_prerelease(1, 'b', 0)\n        else:\n            new_num = minor_pre_num + 1 if minor_pre_num >= 0 else 0\n            set_prerelease(1, 'b', new_num)\n        minor_num += 1 if (current_pre_pos != 1) else 0\n        patch_num = 0\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}b{minor_pre_num if minor_pre_num != -1 else 0}'\n\n    elif bump_type == 5:  # _BUMP_VERSION_PATCH_ALPHA = 5\n        # Patch alpha prerelease\n        if current_pre_pos != 2:\n            set_prerelease(2, 'a', 0)\n        else:\n            new_num = patch_pre_num + 1 if patch_pre_num >= 0 else 0\n            set_prerelease(2, 'a', new_num)\n        # bump patch if not already patch prerelease\n        patch_num += 1 if (current_pre_pos != 2) else 0\n        result = f'{major_num}.{minor_num}.{patch_num}a{patch_pre_num if patch_pre_num != -1 else 0}'\n\n    elif bump_type == 6:  # _BUMP_VERSION_PATCH_BETA = 6\n        # Patch beta prerelease\n        if current_pre_pos != 2:\n            set_prerelease(2, 'b', 0)\n        else:\n            new_num = patch_pre_num + 1 if patch_pre_num >= 0 else 0\n            set_prerelease(2, 'b', new_num)\n        patch_num += 1 if (current_pre_pos != 2) else 0\n        result = f'{major_num}.{minor_num}.{patch_num}b{patch_pre_num if patch_pre_num != -1 else 0}'\n\n    else:\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # Special handling if no prerelease requested and current version has a prerelease but bumping same position:\n    # then remove prerelease (final release)\n    # But only if no explicit pre_release is specified (None)\n    # and bump is at the same pre_pos.\n    # According to examples:\n    # This means bump_version('1.2.4a1') -> '1.2.4' if no pre_release given\n    # Only if bumping patch in that case (default)\n    if pre_release is None:\n        # If current version had prerelease and bumping that prerelease position, drop prerelease\n        if current_pre_pos == pos:\n            # Compose version without prerelease\n            if pos == 0:\n                # Major, no prerelease, no minor or patch in StrictVersion format? Use 'major.0'\n                result = f'{major_num}.0'\n            elif pos == 1:\n                # Minor bump: major.minor no patch as patch=0 omited\n                result = f'{major_num}.{minor_num}'\n            elif pos == 2:\n                result = f'{major_num}.{minor_num}.{patch_num}'\n\n    return result\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n"]}
{"task_id": 126, "project": "test-apps/flutils", "module": "flutils.namedtupleutils", "predictions": ["from collections import (\n    namedtuple,\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, Tuple, List, Any\nfrom flutils.validators import validate_identifier\nfrom flutils.namedtupleutils import _to_namedtuple\nfrom flutils.objutils import is_subclass_of_any\nimport keyword\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>` keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper: validate identifier (no leading underscore, valid identifier)\n    def _is_valid_key(key: Any) -> bool:\n        # key must be string type and:\n        # - not start with underscore\n        # - be a valid identifier (including no keyword or builtin names)\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        try:\n            validate_identifier(key, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    # Recursive conversion\n    if obj is None:\n        return obj\n\n    # If obj is a NamedTuple instance or tuple subclass but NOT a dict or list\n    # Note: We want to treat NamedTuple instances as NamedTuple, converting their fields.\n    # But careful: NamedTuple is a subclass of tuple.\n    # We must handle NamedTuple/tuple separately.\n\n    # Check if obj is a NamedTuple instance:\n    # NamedTuple is a subclass of tuple with _fields attribute\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # Convert each element recursively\n        converted_values = tuple(to_namedtuple(v) for v in obj)\n        # Construct same NamedTuple type with converted values\n        return type(obj)(*converted_values)\n\n    # Handle lists and tuples: convert each item recursively\n    if isinstance(obj, list):\n        # Return a new list with converted elements\n        return [to_namedtuple(item) for item in obj]\n\n    if isinstance(obj, tuple):\n        # Return a new tuple with converted elements\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # Handle SimpleNamespace: convert its __dict__ (attributes)\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes dict\n        attribute_dict = vars(obj)\n        # Filter valid keys sorted alphabetically\n        keys = sorted(k for k in attribute_dict if _is_valid_key(k))\n        # Recursively convert values\n        values = [to_namedtuple(attribute_dict[k]) for k in keys]\n        # Create namedtuple with sorted keys\n        NamedTupleClass = namedtuple('NamedTuple', keys)\n        return NamedTupleClass(*values)\n\n    # Handle mappings (dict and subclasses)\n    if isinstance(obj, Mapping):\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_key(k)]\n        else:\n            keys = sorted(k for k in obj.keys() if _is_valid_key(k))\n        values = [to_namedtuple(obj[k]) for k in keys]\n        if keys:\n            NamedTupleClass = namedtuple('NamedTuple', keys)\n            return NamedTupleClass(*values)\n        else:\n            # Empty namedtuple\n            EmptyClass = namedtuple('NamedTuple', '')\n            return EmptyClass()\n\n    # For any other type, return as-is (base types like int, str, etc.)\n    return obj", "from collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, Mapping, Sequence, cast\n\nfrom flutils.validators import validate_identifier\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Recursive helper for mappings\n    def _convert_mapping(mapping: Mapping) -> Any:\n        # Collect valid keys (str and valid identifiers without leading underscore)\n        if isinstance(mapping, OrderedDict):\n            keys = list(mapping.keys())\n            # Filter keys that are valid identifiers and don't start with underscore\n            valid_keys = []\n            for key in keys:\n                if isinstance(key, str):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                    except Exception:\n                        continue\n                    valid_keys.append(key)\n        else:\n            # For dict or other mappings, sort keys alphabetically\n            valid_keys = []\n            for key in mapping.keys():\n                if isinstance(key, str):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                    except Exception:\n                        continue\n                    valid_keys.append(key)\n            valid_keys = tuple(sorted(valid_keys))\n\n        # Recursively convert each valid key's value\n        converted_values = []\n        for key in valid_keys:\n            val = mapping[key]\n            val = to_namedtuple(val)\n            converted_values.append(val)\n\n        # Create namedtuple class with collected keys\n        if valid_keys:\n            tuple_class = namedtuple('NamedTuple', valid_keys)\n            return tuple_class(*converted_values)\n        else:\n            # Return empty namedtuple (no fields)\n            empty_nt = namedtuple('NamedTuple', '')\n            return empty_nt()\n\n    # Start of main function logic\n    # Handle NamedTuple input - no conversion, but we must recursively convert its items\n    # NamedTuple is a subclass of tuple, but has _fields attribute\n    if hasattr(obj, '_fields') and isinstance(obj, tuple):\n        # Convert each item recursively, build new namedtuple of same class\n        values = [to_namedtuple(item) for item in obj]\n        return type(obj)(*values)\n\n    # Handle SimpleNamespace: treat like dict with attributes sorted alphabetically\n    if isinstance(obj, SimpleNamespace):\n        # Get attribute dict, filter keys like dict keys\n        attrs = vars(obj)\n        # Sort keys alphabetically to match docstring\n        sorted_keys = sorted(\n            k for k in attrs.keys()\n            if isinstance(k, str) and not k.startswith('_')\n        )\n        # Validate keys\n        valid_keys = []\n        for key in sorted_keys:\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except Exception:\n                continue\n            valid_keys.append(key)\n\n        values = [to_namedtuple(attrs[k]) for k in valid_keys]\n\n        if valid_keys:\n            tuple_class = namedtuple('NamedTuple', valid_keys)\n            return tuple_class(*values)\n        else:\n            empty_nt = namedtuple('NamedTuple', '')\n            return empty_nt()\n\n    # Handle Mapping (dict or OrderedDict or other Mapping)\n    if isinstance(obj, Mapping):\n        return _convert_mapping(obj)\n\n    # Handle list: return new list with recursively converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuple (without _fields i.e. not namedtuple): return new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # For other types, return as is\n    return obj", "from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nimport keyword\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>` keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper inner function to check if a key is a valid attribute name\n    def _is_valid_attr_name(name: Any) -> bool:\n        if not isinstance(name, str):\n            return False\n        if name.startswith('_'):\n            return False\n        try:\n            validate_identifier(name, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    # Handle Mappings (dict-like objects)\n    if isinstance(obj, Mapping):\n        # Determine keys order\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_attr_name(k)]\n        else:\n            # Sort keys alphabetically (only those valid)\n            keys = sorted(k for k in obj.keys() if _is_valid_attr_name(k))\n\n        values = []\n        for key in keys:\n            val = obj[key]\n            val_converted = to_namedtuple(val)\n            values.append(val_converted)\n\n        # Create namedtuple class and instantiate\n        if keys:\n            NTClass = namedtuple('NamedTuple', keys)\n            return NTClass(*values)\n        else:\n            # Empty namedtuple with no fields\n            NTClass = namedtuple('NamedTuple', [])\n            return NTClass()\n\n    # Handle SimpleNamespace (like an object with attributes)\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes as dict and sort keys alphabetically\n        attrs = {k: v for k, v in vars(obj).items() if _is_valid_attr_name(k)}\n        keys = sorted(attrs.keys())\n        values = [to_namedtuple(attrs[k]) for k in keys]\n\n        if keys:\n            NTClass = namedtuple('NamedTuple', keys)\n            return NTClass(*values)\n        else:\n            NTClass = namedtuple('NamedTuple', [])\n            return NTClass()\n\n    # Handle lists: return new list with converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuples: return new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj]\n\n    # If not any of above types, return as is\n    return obj", "from collections import namedtuple, OrderedDict\nfrom collections.abc import Mapping\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, List, Tuple, Any\n\nfrom flutils.validators import validate_identifier\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Helper function to recursively convert an object to namedtuple if possible\n    def _convert(obj: Any) -> Any:\n        # Handle Mapping (dict, OrderedDict, etc)\n        if isinstance(obj, Mapping):\n            # Determine keys to use as attributes:\n            if isinstance(obj, OrderedDict):\n                keys = [k for k in obj.keys()\n                        if (isinstance(k, str)\n                            and not k.startswith('_')\n                            and k.isidentifier())]\n            else:\n                # For all other mappings, keys that are valid identifiers,\n                # not starting with underscore, sorted alphabetically.\n                keys = []\n                for k in obj.keys():\n                    if isinstance(k, str) and not k.startswith('_'):\n                        # use validate_identifier to ensure correctness\n                        try:\n                            validate_identifier(k, allow_underscore=False)\n                            keys.append(k)\n                        except (SyntaxError, TypeError):\n                            continue\n                keys = tuple(sorted(keys))\n\n            # Recursively convert each value for valid keys\n            values = []\n            for key in keys:\n                val = obj[key]\n                try:\n                    val = _convert(val)\n                except Exception:\n                    # if cannot convert, keep original value\n                    pass\n                values.append(val)\n\n            # Create namedtuple class\n            NamedTupleCls = namedtuple('NamedTuple', keys)\n            return NamedTupleCls(*values)\n\n        # Handle SimpleNamespace\n        if isinstance(obj, SimpleNamespace):\n            # Get attributes dictionary\n            attrs = vars(obj)\n            keys = []\n            for key in attrs.keys():\n                if isinstance(key, str) and not key.startswith('_'):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                        keys.append(key)\n                    except (SyntaxError, TypeError):\n                        continue\n            # Sort keys alphabetically\n            keys = tuple(sorted(keys))\n\n            values = []\n            for key in keys:\n                val = attrs[key]\n                try:\n                    val = _convert(val)\n                except Exception:\n                    pass\n                values.append(val)\n\n            NamedTupleCls = namedtuple('NamedTuple', keys)\n            return NamedTupleCls(*values)\n\n        # Handle list: return a new list with items converted recursively if possible\n        if isinstance(obj, list):\n            new_list = []\n            for item in obj:\n                try:\n                    item_conv = _convert(item)\n                except Exception:\n                    item_conv = item\n                new_list.append(item_conv)\n            return new_list\n\n        # Handle tuple: return a tuple with items converted recursively if possible\n        if isinstance(obj, tuple):\n            new_tuple = []\n            for item in obj:\n                try:\n                    item_conv = _convert(item)\n                except Exception:\n                    item_conv = item\n                new_tuple.append(item_conv)\n            return tuple(new_tuple)\n\n        # For other types, return as is\n        return obj\n\n    return _convert(obj)", "import keyword\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, cast\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    def _is_valid_key(key: Any) -> bool:\n        \"\"\"Return True if key is a string identifier not starting with underscore.\"\"\"\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        try:\n            validate_identifier(key, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    if isinstance(obj, Mapping):\n        # Extract keys that are valid identifiers and do not start with underscore\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_key(k)]\n        else:\n            # Sort keys alphabetically if not OrderedDict\n            keys = sorted(k for k in obj.keys() if _is_valid_key(k))\n\n        values = []\n        for key in keys:\n            val = obj[key]\n            try:\n                val_conv = to_namedtuple(val)\n            except Exception:\n                val_conv = val\n            values.append(val_conv)\n\n        if keys:\n            MakeNamedTuple = namedtuple('NamedTuple', keys)\n            return MakeNamedTuple(*values)\n        else:\n            # No valid keys -> return empty namedtuple\n            MakeEmpty = namedtuple('NamedTuple', '')\n            return MakeEmpty()\n\n    elif isinstance(obj, SimpleNamespace):\n        # Extract attributes, filter valid keys (no underscore start) and sort alphabetically\n        attrs = vars(obj)\n        keys = sorted(k for k in attrs.keys() if _is_valid_key(k))\n        values = []\n        for key in keys:\n            val = attrs[key]\n            try:\n                val_conv = to_namedtuple(val)\n            except Exception:\n                val_conv = val\n            values.append(val_conv)\n        if keys:\n            MakeNamedTuple = namedtuple('NamedTuple', keys)\n            return MakeNamedTuple(*values)\n        else:\n            MakeEmpty = namedtuple('NamedTuple', '')\n            return MakeEmpty()\n\n    elif isinstance(obj, list):\n        # Return a new list with each value converted recursively\n        converted_list = []\n        for item in obj:\n            try:\n                converted_list.append(to_namedtuple(item))\n            except Exception:\n                converted_list.append(item)\n        return converted_list\n\n    elif isinstance(obj, tuple):\n        # Return a new tuple with each value converted recursively\n        converted_tuple = []\n        for item in obj:\n            try:\n                converted_tuple.append(to_namedtuple(item))\n            except Exception:\n                converted_tuple.append(item)\n        return tuple(converted_tuple)\n\n    else:\n        # For other types (including NamedTuple) return as is\n        return obj"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    namedtuple,\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, Tuple, List, Any\nfrom flutils.validators import validate_identifier\nfrom flutils.namedtupleutils import _to_namedtuple\nfrom flutils.objutils import is_subclass_of_any\nimport keyword\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>` keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper: validate identifier (no leading underscore, valid identifier)\n    def _is_valid_key(key: Any) -> bool:\n        # key must be string type and:\n        # - not start with underscore\n        # - be a valid identifier (including no keyword or builtin names)\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        try:\n            validate_identifier(key, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    # Recursive conversion\n    if obj is None:\n        return obj\n\n    # If obj is a NamedTuple instance or tuple subclass but NOT a dict or list\n    # Note: We want to treat NamedTuple instances as NamedTuple, converting their fields.\n    # But careful: NamedTuple is a subclass of tuple.\n    # We must handle NamedTuple/tuple separately.\n\n    # Check if obj is a NamedTuple instance:\n    # NamedTuple is a subclass of tuple with _fields attribute\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # Convert each element recursively\n        converted_values = tuple(to_namedtuple(v) for v in obj)\n        # Construct same NamedTuple type with converted values\n        return type(obj)(*converted_values)\n\n    # Handle lists and tuples: convert each item recursively\n    if isinstance(obj, list):\n        # Return a new list with converted elements\n        return [to_namedtuple(item) for item in obj]\n\n    if isinstance(obj, tuple):\n        # Return a new tuple with converted elements\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # Handle SimpleNamespace: convert its __dict__ (attributes)\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes dict\n        attribute_dict = vars(obj)\n        # Filter valid keys sorted alphabetically\n        keys = sorted(k for k in attribute_dict if _is_valid_key(k))\n        # Recursively convert values\n        values = [to_namedtuple(attribute_dict[k]) for k in keys]\n        # Create namedtuple with sorted keys\n        NamedTupleClass = namedtuple('NamedTuple', keys)\n        return NamedTupleClass(*values)\n\n    # Handle mappings (dict and subclasses)\n    if isinstance(obj, Mapping):\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_key(k)]\n        else:\n            keys = sorted(k for k in obj.keys() if _is_valid_key(k))\n        values = [to_namedtuple(obj[k]) for k in keys]\n        if keys:\n            NamedTupleClass = namedtuple('NamedTuple', keys)\n            return NamedTupleClass(*values)\n        else:\n            # Empty namedtuple\n            EmptyClass = namedtuple('NamedTuple', '')\n            return EmptyClass()\n\n    # For any other type, return as-is (base types like int, str, etc.)\n    return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, Mapping, Sequence, cast\n\nfrom flutils.validators import validate_identifier\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Recursive helper for mappings\n    def _convert_mapping(mapping: Mapping) -> Any:\n        # Collect valid keys (str and valid identifiers without leading underscore)\n        if isinstance(mapping, OrderedDict):\n            keys = list(mapping.keys())\n            # Filter keys that are valid identifiers and don't start with underscore\n            valid_keys = []\n            for key in keys:\n                if isinstance(key, str):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                    except Exception:\n                        continue\n                    valid_keys.append(key)\n        else:\n            # For dict or other mappings, sort keys alphabetically\n            valid_keys = []\n            for key in mapping.keys():\n                if isinstance(key, str):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                    except Exception:\n                        continue\n                    valid_keys.append(key)\n            valid_keys = tuple(sorted(valid_keys))\n\n        # Recursively convert each valid key's value\n        converted_values = []\n        for key in valid_keys:\n            val = mapping[key]\n            val = to_namedtuple(val)\n            converted_values.append(val)\n\n        # Create namedtuple class with collected keys\n        if valid_keys:\n            tuple_class = namedtuple('NamedTuple', valid_keys)\n            return tuple_class(*converted_values)\n        else:\n            # Return empty namedtuple (no fields)\n            empty_nt = namedtuple('NamedTuple', '')\n            return empty_nt()\n\n    # Start of main function logic\n    # Handle NamedTuple input - no conversion, but we must recursively convert its items\n    # NamedTuple is a subclass of tuple, but has _fields attribute\n    if hasattr(obj, '_fields') and isinstance(obj, tuple):\n        # Convert each item recursively, build new namedtuple of same class\n        values = [to_namedtuple(item) for item in obj]\n        return type(obj)(*values)\n\n    # Handle SimpleNamespace: treat like dict with attributes sorted alphabetically\n    if isinstance(obj, SimpleNamespace):\n        # Get attribute dict, filter keys like dict keys\n        attrs = vars(obj)\n        # Sort keys alphabetically to match docstring\n        sorted_keys = sorted(\n            k for k in attrs.keys()\n            if isinstance(k, str) and not k.startswith('_')\n        )\n        # Validate keys\n        valid_keys = []\n        for key in sorted_keys:\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except Exception:\n                continue\n            valid_keys.append(key)\n\n        values = [to_namedtuple(attrs[k]) for k in valid_keys]\n\n        if valid_keys:\n            tuple_class = namedtuple('NamedTuple', valid_keys)\n            return tuple_class(*values)\n        else:\n            empty_nt = namedtuple('NamedTuple', '')\n            return empty_nt()\n\n    # Handle Mapping (dict or OrderedDict or other Mapping)\n    if isinstance(obj, Mapping):\n        return _convert_mapping(obj)\n\n    # Handle list: return new list with recursively converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuple (without _fields i.e. not namedtuple): return new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # For other types, return as is\n    return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nimport keyword\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>` keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper inner function to check if a key is a valid attribute name\n    def _is_valid_attr_name(name: Any) -> bool:\n        if not isinstance(name, str):\n            return False\n        if name.startswith('_'):\n            return False\n        try:\n            validate_identifier(name, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    # Handle Mappings (dict-like objects)\n    if isinstance(obj, Mapping):\n        # Determine keys order\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_attr_name(k)]\n        else:\n            # Sort keys alphabetically (only those valid)\n            keys = sorted(k for k in obj.keys() if _is_valid_attr_name(k))\n\n        values = []\n        for key in keys:\n            val = obj[key]\n            val_converted = to_namedtuple(val)\n            values.append(val_converted)\n\n        # Create namedtuple class and instantiate\n        if keys:\n            NTClass = namedtuple('NamedTuple', keys)\n            return NTClass(*values)\n        else:\n            # Empty namedtuple with no fields\n            NTClass = namedtuple('NamedTuple', [])\n            return NTClass()\n\n    # Handle SimpleNamespace (like an object with attributes)\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes as dict and sort keys alphabetically\n        attrs = {k: v for k, v in vars(obj).items() if _is_valid_attr_name(k)}\n        keys = sorted(attrs.keys())\n        values = [to_namedtuple(attrs[k]) for k in keys]\n\n        if keys:\n            NTClass = namedtuple('NamedTuple', keys)\n            return NTClass(*values)\n        else:\n            NTClass = namedtuple('NamedTuple', [])\n            return NTClass()\n\n    # Handle lists: return new list with converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuples: return new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj]\n\n    # If not any of above types, return as is\n    return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import namedtuple, OrderedDict\nfrom collections.abc import Mapping\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, List, Tuple, Any\n\nfrom flutils.validators import validate_identifier\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Helper function to recursively convert an object to namedtuple if possible\n    def _convert(obj: Any) -> Any:\n        # Handle Mapping (dict, OrderedDict, etc)\n        if isinstance(obj, Mapping):\n            # Determine keys to use as attributes:\n            if isinstance(obj, OrderedDict):\n                keys = [k for k in obj.keys()\n                        if (isinstance(k, str)\n                            and not k.startswith('_')\n                            and k.isidentifier())]\n            else:\n                # For all other mappings, keys that are valid identifiers,\n                # not starting with underscore, sorted alphabetically.\n                keys = []\n                for k in obj.keys():\n                    if isinstance(k, str) and not k.startswith('_'):\n                        # use validate_identifier to ensure correctness\n                        try:\n                            validate_identifier(k, allow_underscore=False)\n                            keys.append(k)\n                        except (SyntaxError, TypeError):\n                            continue\n                keys = tuple(sorted(keys))\n\n            # Recursively convert each value for valid keys\n            values = []\n            for key in keys:\n                val = obj[key]\n                try:\n                    val = _convert(val)\n                except Exception:\n                    # if cannot convert, keep original value\n                    pass\n                values.append(val)\n\n            # Create namedtuple class\n            NamedTupleCls = namedtuple('NamedTuple', keys)\n            return NamedTupleCls(*values)\n\n        # Handle SimpleNamespace\n        if isinstance(obj, SimpleNamespace):\n            # Get attributes dictionary\n            attrs = vars(obj)\n            keys = []\n            for key in attrs.keys():\n                if isinstance(key, str) and not key.startswith('_'):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                        keys.append(key)\n                    except (SyntaxError, TypeError):\n                        continue\n            # Sort keys alphabetically\n            keys = tuple(sorted(keys))\n\n            values = []\n            for key in keys:\n                val = attrs[key]\n                try:\n                    val = _convert(val)\n                except Exception:\n                    pass\n                values.append(val)\n\n            NamedTupleCls = namedtuple('NamedTuple', keys)\n            return NamedTupleCls(*values)\n\n        # Handle list: return a new list with items converted recursively if possible\n        if isinstance(obj, list):\n            new_list = []\n            for item in obj:\n                try:\n                    item_conv = _convert(item)\n                except Exception:\n                    item_conv = item\n                new_list.append(item_conv)\n            return new_list\n\n        # Handle tuple: return a tuple with items converted recursively if possible\n        if isinstance(obj, tuple):\n            new_tuple = []\n            for item in obj:\n                try:\n                    item_conv = _convert(item)\n                except Exception:\n                    item_conv = item\n                new_tuple.append(item_conv)\n            return tuple(new_tuple)\n\n        # For other types, return as is\n        return obj\n\n    return _convert(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nimport keyword\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, cast\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    def _is_valid_key(key: Any) -> bool:\n        \"\"\"Return True if key is a string identifier not starting with underscore.\"\"\"\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        try:\n            validate_identifier(key, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    if isinstance(obj, Mapping):\n        # Extract keys that are valid identifiers and do not start with underscore\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_key(k)]\n        else:\n            # Sort keys alphabetically if not OrderedDict\n            keys = sorted(k for k in obj.keys() if _is_valid_key(k))\n\n        values = []\n        for key in keys:\n            val = obj[key]\n            try:\n                val_conv = to_namedtuple(val)\n            except Exception:\n                val_conv = val\n            values.append(val_conv)\n\n        if keys:\n            MakeNamedTuple = namedtuple('NamedTuple', keys)\n            return MakeNamedTuple(*values)\n        else:\n            # No valid keys -> return empty namedtuple\n            MakeEmpty = namedtuple('NamedTuple', '')\n            return MakeEmpty()\n\n    elif isinstance(obj, SimpleNamespace):\n        # Extract attributes, filter valid keys (no underscore start) and sort alphabetically\n        attrs = vars(obj)\n        keys = sorted(k for k in attrs.keys() if _is_valid_key(k))\n        values = []\n        for key in keys:\n            val = attrs[key]\n            try:\n                val_conv = to_namedtuple(val)\n            except Exception:\n                val_conv = val\n            values.append(val_conv)\n        if keys:\n            MakeNamedTuple = namedtuple('NamedTuple', keys)\n            return MakeNamedTuple(*values)\n        else:\n            MakeEmpty = namedtuple('NamedTuple', '')\n            return MakeEmpty()\n\n    elif isinstance(obj, list):\n        # Return a new list with each value converted recursively\n        converted_list = []\n        for item in obj:\n            try:\n                converted_list.append(to_namedtuple(item))\n            except Exception:\n                converted_list.append(item)\n        return converted_list\n\n    elif isinstance(obj, tuple):\n        # Return a new tuple with each value converted recursively\n        converted_tuple = []\n        for item in obj:\n            try:\n                converted_tuple.append(to_namedtuple(item))\n            except Exception:\n                converted_tuple.append(item)\n        return tuple(converted_tuple)\n\n    else:\n        # For other types (including NamedTuple) return as is\n        return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n"]}
{"task_id": 127, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["from typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom collections import namedtuple\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # The foreign_name format can be one of:\n    # 1. \"attr_name=mod_name.mod_attr_name\"\n    # 2. \"attr_name=mod_name\"\n    # 3. \"mod_name.mod_attr_name\"\n    # 4. \"mod_name\"\n    # We need to parse these forms and extract attr_name, mod_name, mod_attr_name accordingly.\n\n    # First, split by '=', maxsplit=1\n    if '=' in foreign_name:\n        attr_name_part, rhs = foreign_name.split('=', 1)\n        attr_name = _validate_attr_identifier(attr_name_part.strip(), foreign_name)\n        remainder = rhs.strip()\n    else:\n        attr_name = ''\n        remainder = foreign_name.strip()\n\n    # Now parse remainder which is of form: mod_name or mod_name.mod_attr_name\n    if '.' in remainder:\n        mod_name_part, mod_attr_name_part = remainder.split('.', 1)\n        mod_name = mod_name_part.strip()\n        mod_attr_name = mod_attr_name_part.strip()\n        # If attr_name is empty (not explicitly set), then attr_name = mod_attr_name\n        if attr_name == '':\n            attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n        else:\n            _validate_attr_identifier(mod_attr_name, foreign_name)\n    else:\n        mod_name = remainder\n        mod_attr_name = ''\n        # If attr_name is empty (not explicitly set), then attr_name = last component of mod_name\n        if attr_name == '':\n            # attr_name should be the last component of mod_name split by '.'\n            attr_name_candidate = mod_name.rsplit('.', 1)[-1]\n            attr_name = _validate_attr_identifier(attr_name_candidate, foreign_name)\n\n    # Validate mod_name should not be empty\n    if not mod_name:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"The module name cannot be empty.\"\n        )\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=foreign_name\n    )", "from typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom types import ModuleType\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    line = foreign_name.strip()\n    if line == '':\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid empty item.\"\n        )\n\n    # Split the foreign_name on '=' if present\n    # Format can be either:\n    # - \"attr_name=mod_name.mod_attr_name\" or\n    # - \"mod_name.mod_attr_name\" or\n    # - \"mod_name\" (just module named)\n    if '=' in line:\n        attr_name_part, module_part = line.split('=', 1)\n        attr_name = attr_name_part.strip()\n        module_part = module_part.strip()\n        if attr_name == '':\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {line!r}. \"\n                f\"Missing attribute name before '='.\"\n            )\n    else:\n        attr_name = ''\n        module_part = line\n\n    # Now parse module_part for mod_name and optional mod_attr_name\n    # That is split on last '.' if any\n    mod_name = module_part\n    mod_attr_name = ''\n    if '.' in module_part:\n        # Split on last dot\n        last_dot_index = module_part.rfind('.')\n        mod_name = module_part[:last_dot_index]\n        mod_attr_name = module_part[last_dot_index+1:]\n        if mod_attr_name == '':\n            # Trailing dot is invalid\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {line!r}. \"\n                f\"Trailing '.' in module attribute part.\"\n            )\n    else:\n        mod_name = module_part\n        mod_attr_name = ''\n\n    # Validate attr_name if present (non-empty)\n    # If attr_name is empty, we treat that the entire module is exported as attribute\n    if attr_name != '':\n        # Validate attribute name using _validate_attr_identifier\n        attr_name = _validate_attr_identifier(attr_name, line)\n\n    # Validate mod_name is non-empty\n    # Also allow mod_name to be a valid dotted module path, so validate parts separately\n    if not mod_name:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"Missing module name.\"\n        )\n    for part in mod_name.split('.'):\n        _validate_attr_identifier(part, line)\n\n    # Validate mod_attr_name if present (non-empty)\n    if mod_attr_name != '':\n        mod_attr_name = mod_attr_name.strip()\n        if mod_attr_name == '':\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {line!r}. \"\n                f\"Empty attribute after last '.'\"\n            )\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=line\n    )", "from typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom collections import namedtuple\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # The expected formats for foreign_name are:\n    # 1. \"attr_name=mod_name.mod_attr_name\"\n    # 2. \"attr_name=mod_name\"\n    # 3. \"mod_name.mod_attr_name\"\n    # 4. \"mod_name\"\n    #\n    # We need to parse accordingly:\n    # If there is an '=', then left side is attr_name, right side is the rest.\n    # If no '=', then the entire string is mod_name[.mod_attr_name], attr_name is mod_attr_name or mod_name\n    \n    line = foreign_name.strip()\n    \n    # Initially set default values\n    attr_name = ''\n    mod_name = ''\n    mod_attr_name = ''\n    \n    if '=' in line:\n        # Split into attr_name and the right hand side\n        left, right = line.split('=', 1)\n        attr_name = left.strip()\n        right = right.strip()\n    else:\n        right = line\n    \n    # Now parse right for mod_name and optional mod_attr_name separated by last '.'\n    if '.' in right:\n        # Split on last dot\n        last_dot_index = right.rfind('.')\n        mod_name = right[:last_dot_index].strip()\n        mod_attr_name = right[last_dot_index+1:].strip()\n    else:\n        mod_name = right\n        mod_attr_name = ''\n    \n    # If attr_name is empty (no '=' in original), then attr_name is mod_attr_name if present else mod_name\n    if attr_name == '':\n        if mod_attr_name:\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name\n    \n    # Validate identifiers for attr_name and mod_attr_name if present\n    # mod_name is a module name: can contain dots and is not an identifier necessarily, so do not validate it as an identifier\n    # attr_name and mod_attr_name should be valid attribute names (identifiers)\n    attr_name = _validate_attr_identifier(attr_name, line)\n    if mod_attr_name != '':\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n    \n    return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name, item=line)", "from typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom types import UserString\nimport keyword\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n\n    # Strip whitespace for safety\n    line = foreign_name.strip()\n\n    # Parse the format:\n    # Possible formats:\n    #  1) \"mod_name\" — just a module name with no attr_name or mod_attr_name,\n    #     so attr_name == mod_attr_name == '' except mod_name\n    #  2) \"attr_name = mod_name\" — attr_name is set on cherry-picking module,\n    #     mod_name is a module (or maybe a module.attr), mod_attr_name empty\n    #  3) \"attr_name = mod_name.mod_attr_name\" — attr_name on cherry-picking,\n    #     mod_name is module fullname, mod_attr_name is an attribute of mod_name\n\n    # First, attempt to split on the first '='\n    if '=' in line:\n        left, right = line.split('=', 1)\n        attr_name = left.strip()\n        rhs = right.strip()\n    else:\n        # No '=', so attr_name is '', mod_name = entire line\n        attr_name = ''\n        rhs = line\n\n    # Now interpret rhs\n    # rhs might be something like \"module.submodule.attr\"\n    # if attr_name is '', then mod_name = rhs, mod_attr_name = ''\n    # else:\n    #    mod_name = the part of rhs except the last segment,\n    #    mod_attr_name = last segment,\n    #    unless rhs has no dot, then mod_name=rhs, mod_attr_name = ''\n\n    if attr_name == '':\n        mod_name = rhs\n        mod_attr_name = ''\n    else:\n        parts = rhs.split('.')\n        if len(parts) == 1:\n            # RHS has no dot, so mod_name=rhs, mod_attr_name=''\n            mod_name = rhs\n            mod_attr_name = ''\n        else:\n            mod_name = \".\".join(parts[:-1])\n            mod_attr_name = parts[-1]\n\n    # Validate attr_name if it is not empty (and treat UserString too)\n    if attr_name != '':\n        # Use the context _validate_attr_identifier for attr_name validation\n        attr_name = _validate_attr_identifier(attr_name, foreign_name)\n\n    # Validate mod_attr_name if not empty\n    if mod_attr_name != '':\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n\n    # mod_name is a module name, can contain dots but should be stripped\n    mod_name = mod_name.strip()\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name, foreign_name)", "from typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom types import UserString\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Strip whitespace\n    line = foreign_name.strip()\n\n    # Split by ':', at most once, to separate attr_name and the rest\n    if ':' in line:\n        attr_name_part, rest = line.split(':', 1)\n        attr_name_part = attr_name_part.strip()\n    else:\n        # No colon means attr_name is the same as mod_attr_name or only mod_name\n        attr_name_part = ''\n        rest = line\n\n    # Now split rest by '.' at most once to separate mod_name and mod_attr_name\n    if '.' in rest:\n        mod_name_part, mod_attr_name_part = rest.split('.', 1)\n        mod_name_part = mod_name_part.strip()\n        mod_attr_name_part = mod_attr_name_part.strip()\n    else:\n        mod_name_part = rest.strip()\n        mod_attr_name_part = ''\n\n    # Determine attr_name based on presence of attr_name_part\n    # If attr_name_part is empty, then:\n    # - if mod_attr_name_part is empty: attr_name = mod_name_part (binding whole module)\n    # - else: attr_name = mod_attr_name_part (binding attribute with same name)\n    # If attr_name_part is given, use as attr_name\n\n    if attr_name_part == '' and mod_attr_name_part == '':\n        # e.g. \"packagename\" - attr_name = mod_name_part, mod_attr_name is empty\n        attr_name = mod_name_part\n        mod_name = mod_name_part\n        mod_attr_name = ''\n    elif attr_name_part == '':\n        # e.g. \"packagename.attr\" means attr_name = attr, mod_name = packagename, mod_attr_name = attr\n        attr_name = mod_attr_name_part\n        mod_name = mod_name_part\n        mod_attr_name = mod_attr_name_part\n    else:\n        # Explicit attr_name provided\n        attr_name = attr_name_part\n        mod_name = mod_name_part\n        mod_attr_name = mod_attr_name_part\n\n    # Validate attr_name if not empty\n    if attr_name != '':\n        # Use _validate_attr_identifier for validation with the original foreign_name line as context\n        attr_name = _validate_attr_identifier(attr_name, foreign_name)\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name, foreign_name)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom collections import namedtuple\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # The foreign_name format can be one of:\n    # 1. \"attr_name=mod_name.mod_attr_name\"\n    # 2. \"attr_name=mod_name\"\n    # 3. \"mod_name.mod_attr_name\"\n    # 4. \"mod_name\"\n    # We need to parse these forms and extract attr_name, mod_name, mod_attr_name accordingly.\n\n    # First, split by '=', maxsplit=1\n    if '=' in foreign_name:\n        attr_name_part, rhs = foreign_name.split('=', 1)\n        attr_name = _validate_attr_identifier(attr_name_part.strip(), foreign_name)\n        remainder = rhs.strip()\n    else:\n        attr_name = ''\n        remainder = foreign_name.strip()\n\n    # Now parse remainder which is of form: mod_name or mod_name.mod_attr_name\n    if '.' in remainder:\n        mod_name_part, mod_attr_name_part = remainder.split('.', 1)\n        mod_name = mod_name_part.strip()\n        mod_attr_name = mod_attr_name_part.strip()\n        # If attr_name is empty (not explicitly set), then attr_name = mod_attr_name\n        if attr_name == '':\n            attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n        else:\n            _validate_attr_identifier(mod_attr_name, foreign_name)\n    else:\n        mod_name = remainder\n        mod_attr_name = ''\n        # If attr_name is empty (not explicitly set), then attr_name = last component of mod_name\n        if attr_name == '':\n            # attr_name should be the last component of mod_name split by '.'\n            attr_name_candidate = mod_name.rsplit('.', 1)[-1]\n            attr_name = _validate_attr_identifier(attr_name_candidate, foreign_name)\n\n    # Validate mod_name should not be empty\n    if not mod_name:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"The module name cannot be empty.\"\n        )\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom types import ModuleType\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    line = foreign_name.strip()\n    if line == '':\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid empty item.\"\n        )\n\n    # Split the foreign_name on '=' if present\n    # Format can be either:\n    # - \"attr_name=mod_name.mod_attr_name\" or\n    # - \"mod_name.mod_attr_name\" or\n    # - \"mod_name\" (just module named)\n    if '=' in line:\n        attr_name_part, module_part = line.split('=', 1)\n        attr_name = attr_name_part.strip()\n        module_part = module_part.strip()\n        if attr_name == '':\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {line!r}. \"\n                f\"Missing attribute name before '='.\"\n            )\n    else:\n        attr_name = ''\n        module_part = line\n\n    # Now parse module_part for mod_name and optional mod_attr_name\n    # That is split on last '.' if any\n    mod_name = module_part\n    mod_attr_name = ''\n    if '.' in module_part:\n        # Split on last dot\n        last_dot_index = module_part.rfind('.')\n        mod_name = module_part[:last_dot_index]\n        mod_attr_name = module_part[last_dot_index+1:]\n        if mod_attr_name == '':\n            # Trailing dot is invalid\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {line!r}. \"\n                f\"Trailing '.' in module attribute part.\"\n            )\n    else:\n        mod_name = module_part\n        mod_attr_name = ''\n\n    # Validate attr_name if present (non-empty)\n    # If attr_name is empty, we treat that the entire module is exported as attribute\n    if attr_name != '':\n        # Validate attribute name using _validate_attr_identifier\n        attr_name = _validate_attr_identifier(attr_name, line)\n\n    # Validate mod_name is non-empty\n    # Also allow mod_name to be a valid dotted module path, so validate parts separately\n    if not mod_name:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"Missing module name.\"\n        )\n    for part in mod_name.split('.'):\n        _validate_attr_identifier(part, line)\n\n    # Validate mod_attr_name if present (non-empty)\n    if mod_attr_name != '':\n        mod_attr_name = mod_attr_name.strip()\n        if mod_attr_name == '':\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {line!r}. \"\n                f\"Empty attribute after last '.'\"\n            )\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=line\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom collections import namedtuple\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # The expected formats for foreign_name are:\n    # 1. \"attr_name=mod_name.mod_attr_name\"\n    # 2. \"attr_name=mod_name\"\n    # 3. \"mod_name.mod_attr_name\"\n    # 4. \"mod_name\"\n    #\n    # We need to parse accordingly:\n    # If there is an '=', then left side is attr_name, right side is the rest.\n    # If no '=', then the entire string is mod_name[.mod_attr_name], attr_name is mod_attr_name or mod_name\n    \n    line = foreign_name.strip()\n    \n    # Initially set default values\n    attr_name = ''\n    mod_name = ''\n    mod_attr_name = ''\n    \n    if '=' in line:\n        # Split into attr_name and the right hand side\n        left, right = line.split('=', 1)\n        attr_name = left.strip()\n        right = right.strip()\n    else:\n        right = line\n    \n    # Now parse right for mod_name and optional mod_attr_name separated by last '.'\n    if '.' in right:\n        # Split on last dot\n        last_dot_index = right.rfind('.')\n        mod_name = right[:last_dot_index].strip()\n        mod_attr_name = right[last_dot_index+1:].strip()\n    else:\n        mod_name = right\n        mod_attr_name = ''\n    \n    # If attr_name is empty (no '=' in original), then attr_name is mod_attr_name if present else mod_name\n    if attr_name == '':\n        if mod_attr_name:\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name\n    \n    # Validate identifiers for attr_name and mod_attr_name if present\n    # mod_name is a module name: can contain dots and is not an identifier necessarily, so do not validate it as an identifier\n    # attr_name and mod_attr_name should be valid attribute names (identifiers)\n    attr_name = _validate_attr_identifier(attr_name, line)\n    if mod_attr_name != '':\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n    \n    return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name, item=line)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom types import UserString\nimport keyword\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n\n    # Strip whitespace for safety\n    line = foreign_name.strip()\n\n    # Parse the format:\n    # Possible formats:\n    #  1) \"mod_name\" — just a module name with no attr_name or mod_attr_name,\n    #     so attr_name == mod_attr_name == '' except mod_name\n    #  2) \"attr_name = mod_name\" — attr_name is set on cherry-picking module,\n    #     mod_name is a module (or maybe a module.attr), mod_attr_name empty\n    #  3) \"attr_name = mod_name.mod_attr_name\" — attr_name on cherry-picking,\n    #     mod_name is module fullname, mod_attr_name is an attribute of mod_name\n\n    # First, attempt to split on the first '='\n    if '=' in line:\n        left, right = line.split('=', 1)\n        attr_name = left.strip()\n        rhs = right.strip()\n    else:\n        # No '=', so attr_name is '', mod_name = entire line\n        attr_name = ''\n        rhs = line\n\n    # Now interpret rhs\n    # rhs might be something like \"module.submodule.attr\"\n    # if attr_name is '', then mod_name = rhs, mod_attr_name = ''\n    # else:\n    #    mod_name = the part of rhs except the last segment,\n    #    mod_attr_name = last segment,\n    #    unless rhs has no dot, then mod_name=rhs, mod_attr_name = ''\n\n    if attr_name == '':\n        mod_name = rhs\n        mod_attr_name = ''\n    else:\n        parts = rhs.split('.')\n        if len(parts) == 1:\n            # RHS has no dot, so mod_name=rhs, mod_attr_name=''\n            mod_name = rhs\n            mod_attr_name = ''\n        else:\n            mod_name = \".\".join(parts[:-1])\n            mod_attr_name = parts[-1]\n\n    # Validate attr_name if it is not empty (and treat UserString too)\n    if attr_name != '':\n        # Use the context _validate_attr_identifier for attr_name validation\n        attr_name = _validate_attr_identifier(attr_name, foreign_name)\n\n    # Validate mod_attr_name if not empty\n    if mod_attr_name != '':\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n\n    # mod_name is a module name, can contain dots but should be stripped\n    mod_name = mod_name.strip()\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name, foreign_name)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\nfrom types import UserString\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Strip whitespace\n    line = foreign_name.strip()\n\n    # Split by ':', at most once, to separate attr_name and the rest\n    if ':' in line:\n        attr_name_part, rest = line.split(':', 1)\n        attr_name_part = attr_name_part.strip()\n    else:\n        # No colon means attr_name is the same as mod_attr_name or only mod_name\n        attr_name_part = ''\n        rest = line\n\n    # Now split rest by '.' at most once to separate mod_name and mod_attr_name\n    if '.' in rest:\n        mod_name_part, mod_attr_name_part = rest.split('.', 1)\n        mod_name_part = mod_name_part.strip()\n        mod_attr_name_part = mod_attr_name_part.strip()\n    else:\n        mod_name_part = rest.strip()\n        mod_attr_name_part = ''\n\n    # Determine attr_name based on presence of attr_name_part\n    # If attr_name_part is empty, then:\n    # - if mod_attr_name_part is empty: attr_name = mod_name_part (binding whole module)\n    # - else: attr_name = mod_attr_name_part (binding attribute with same name)\n    # If attr_name_part is given, use as attr_name\n\n    if attr_name_part == '' and mod_attr_name_part == '':\n        # e.g. \"packagename\" - attr_name = mod_name_part, mod_attr_name is empty\n        attr_name = mod_name_part\n        mod_name = mod_name_part\n        mod_attr_name = ''\n    elif attr_name_part == '':\n        # e.g. \"packagename.attr\" means attr_name = attr, mod_name = packagename, mod_attr_name = attr\n        attr_name = mod_attr_name_part\n        mod_name = mod_name_part\n        mod_attr_name = mod_attr_name_part\n    else:\n        # Explicit attr_name provided\n        attr_name = attr_name_part\n        mod_name = mod_name_part\n        mod_attr_name = mod_attr_name_part\n\n    # Validate attr_name if not empty\n    if attr_name != '':\n        # Use _validate_attr_identifier for validation with the original foreign_name line as context\n        attr_name = _validate_attr_identifier(attr_name, foreign_name)\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name, foreign_name)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()"]}
{"task_id": 128, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)", "from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping  # Assuming _AttrMapping is imported for typing\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)", "from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)", "from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)", "from typing import Tuple, Generator\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping  # Assuming _AttrMapping is imported for typing\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Tuple, Generator\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n"]}
{"task_id": 129, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["import base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Convert the input text to a plain string if it is a UserString instance\n    if isinstance(text, UserString):\n        text = str(text)\n    else:\n        # If it's not a string at all (should be str or UserString), convert\n        text = str(text)\n    \n    # Remove all whitespace characters from the text (including newlines and spaces)\n    # because base64 input can span many lines and be indented.\n    # Base64 ignores whitespace.\n    cleaned_text = ''.join(text.split())\n\n    # Decode the cleaned base64 string into bytes\n    decoded_bytes = base64.b64decode(cleaned_text)\n\n    # Return the decoded bytes and its length\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Convert text to str if it is a UserString\n    if isinstance(text, UserString):\n        text_str = str(text)\n    else:\n        text_str = text\n\n    # Remove all whitespace characters to deal with multi-line and indented input\n    cleaned_text = ''.join(text_str.split())\n\n    # Decode the cleaned base64 string\n    decoded_bytes = base64.b64decode(cleaned_text)\n\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # 'text' may be UserString; convert to str to safely process\n    text_str = str(text)\n\n    # Remove whitespace characters (including newlines and spaces)\n    stripped_text = ''.join(text_str.split())\n\n    # Decode the base64 string into bytes\n    decoded_bytes = base64.b64decode(stripped_text, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Convert UserString or other _STR types to plain string\n    b64_string = str(text).strip()\n\n    # Remove all whitespace (including spaces, new lines, tabs)\n    # because base64 allows line breaks and spaces in some inputs\n    b64_string = ''.join(b64_string.split())\n\n    # Decode base64 string to bytes\n    decoded_bytes = base64.b64decode(b64_string, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize input to str if needed (UserString)\n    if isinstance(text, UserString):\n        text_str = str(text)\n    else:\n        text_str = text\n\n    # Remove all whitespace characters since input can be multiline and indented\n    # This is a common requirement for base64-decoding inputs with arbitrary spaces/newlines\n    filtered_text = ''.join(text_str.split())\n\n    # Decode the filtered base64 string into bytes\n    decoded_bytes = base64.b64decode(filtered_text, validate=False)\n\n    # Return decoded bytes and their length\n    return decoded_bytes, len(decoded_bytes)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Convert the input text to a plain string if it is a UserString instance\n    if isinstance(text, UserString):\n        text = str(text)\n    else:\n        # If it's not a string at all (should be str or UserString), convert\n        text = str(text)\n    \n    # Remove all whitespace characters from the text (including newlines and spaces)\n    # because base64 input can span many lines and be indented.\n    # Base64 ignores whitespace.\n    cleaned_text = ''.join(text.split())\n\n    # Decode the cleaned base64 string into bytes\n    decoded_bytes = base64.b64decode(cleaned_text)\n\n    # Return the decoded bytes and its length\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Convert text to str if it is a UserString\n    if isinstance(text, UserString):\n        text_str = str(text)\n    else:\n        text_str = text\n\n    # Remove all whitespace characters to deal with multi-line and indented input\n    cleaned_text = ''.join(text_str.split())\n\n    # Decode the cleaned base64 string\n    decoded_bytes = base64.b64decode(cleaned_text)\n\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # 'text' may be UserString; convert to str to safely process\n    text_str = str(text)\n\n    # Remove whitespace characters (including newlines and spaces)\n    stripped_text = ''.join(text_str.split())\n\n    # Decode the base64 string into bytes\n    decoded_bytes = base64.b64decode(stripped_text, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Convert UserString or other _STR types to plain string\n    b64_string = str(text).strip()\n\n    # Remove all whitespace (including spaces, new lines, tabs)\n    # because base64 allows line breaks and spaces in some inputs\n    b64_string = ''.join(b64_string.split())\n\n    # Decode base64 string to bytes\n    decoded_bytes = base64.b64decode(b64_string, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize input to str if needed (UserString)\n    if isinstance(text, UserString):\n        text_str = str(text)\n    else:\n        text_str = text\n\n    # Remove all whitespace characters since input can be multiline and indented\n    # This is a common requirement for base64-decoding inputs with arbitrary spaces/newlines\n    filtered_text = ''.join(text_str.split())\n\n    # Decode the filtered base64 string into bytes\n    decoded_bytes = base64.b64decode(filtered_text, validate=False)\n\n    # Return decoded bytes and their length\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()"]}
{"task_id": 130, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["import base64\nfrom typing import ByteString as _ByteString, Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the binary data to a base64 encoded bytes object\n    encoded_bytes = base64.encodebytes(data)\n\n    # Convert bytes to string\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # Remove trailing whitespace/newlines which base64.encodebytes adds\n    encoded_str = encoded_str.strip()\n\n    # Return the base64 string and the length of the input data consumed\n    return encoded_str, len(data)", "import base64\nfrom typing import Tuple, Union, ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the input bytes into base64-encoded bytes\n    b64_bytes = base64.encodebytes(data)\n\n    # Convert base64 bytes to string (utf-8)\n    b64_str = b64_bytes.decode('utf-8')\n\n    # Cleanup whitespace - remove trailing newline added by encodebytes\n    # and any trailing spaces, but preserve the base64 format (which\n    # may include internal newlines)\n    b64_str = b64_str.rstrip('\\n')\n\n    return b64_str, len(data)", "import base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64 encodebytes to get b64 bytes including line breaks\n    b64_bytes = base64.encodebytes(data)\n    # Decode the bytes to str using ascii (base64 only uses ascii chars)\n    b64_str = b64_bytes.decode('ascii')\n    # Strip trailing whitespace/newlines to make the returned string clean\n    b64_str = b64_str.strip()\n    return b64_str, len(data)", "import base64\nfrom typing import ByteString as _ByteString, Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the bytes into base64 bytes\n    encoded_bytes = base64.encodebytes(data)\n    # Convert the base64 bytes into string\n    encoded_str = encoded_bytes.decode('utf-8')\n    return encoded_str, len(data)", "import base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the bytes input into base64 bytes\n    b64_bytes = base64.encodebytes(data)\n    # decode base64 bytes to UTF-8 string\n    b64_str = b64_bytes.decode('utf-8')\n    # Cleanup: strip trailing whitespace/newlines\n    b64_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), b64_str.strip().splitlines())\n        )\n    )\n    return b64_str, len(data)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import ByteString as _ByteString, Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the binary data to a base64 encoded bytes object\n    encoded_bytes = base64.encodebytes(data)\n\n    # Convert bytes to string\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # Remove trailing whitespace/newlines which base64.encodebytes adds\n    encoded_str = encoded_str.strip()\n\n    # Return the base64 string and the length of the input data consumed\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the input bytes into base64-encoded bytes\n    b64_bytes = base64.encodebytes(data)\n\n    # Convert base64 bytes to string (utf-8)\n    b64_str = b64_bytes.decode('utf-8')\n\n    # Cleanup whitespace - remove trailing newline added by encodebytes\n    # and any trailing spaces, but preserve the base64 format (which\n    # may include internal newlines)\n    b64_str = b64_str.rstrip('\\n')\n\n    return b64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64 encodebytes to get b64 bytes including line breaks\n    b64_bytes = base64.encodebytes(data)\n    # Decode the bytes to str using ascii (base64 only uses ascii chars)\n    b64_str = b64_bytes.decode('ascii')\n    # Strip trailing whitespace/newlines to make the returned string clean\n    b64_str = b64_str.strip()\n    return b64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import ByteString as _ByteString, Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the bytes into base64 bytes\n    encoded_bytes = base64.encodebytes(data)\n    # Convert the base64 bytes into string\n    encoded_str = encoded_bytes.decode('utf-8')\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the bytes input into base64 bytes\n    b64_bytes = base64.encodebytes(data)\n    # decode base64 bytes to UTF-8 string\n    b64_str = b64_bytes.decode('utf-8')\n    # Cleanup: strip trailing whitespace/newlines\n    b64_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), b64_str.strip().splitlines())\n        )\n    )\n    return b64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n"]}
{"task_id": 131, "project": "test-apps/flutils", "module": "flutils.txtutils", "predictions": ["import re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove all ANSI sequences and return length of the remaining string\n        return len(_ANSI_RE.sub('', seq))\n    else:\n        # Assume sequence of strings: sum the len_without_ansi of each element\n        return sum(len_without_ansi(s) for s in seq)", "import re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile(r'(\\x1b\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove ANSI sequences from the string and return its length\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # seq is a sequence of strings (list or tuple)\n        length = 0\n        for item in seq:\n            if not isinstance(item, str):\n                raise TypeError(\"All elements of the sequence must be strings\")\n            cleaned = _ANSI_RE.sub('', item)\n            length += len(cleaned)\n        return length", "import re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove ANSI escape sequences and return the length of the visible characters.\n        clean_str = _ANSI_RE.sub('', seq)\n        return len(clean_str)\n    elif isinstance(seq, (list, tuple)):\n        # If it's a list/tuple of strings, sum the lengths after removing ANSI escape sequences from each element.\n        total_length = 0\n        for item in seq:\n            if not isinstance(item, str):\n                # Defensive: ignoring or raising could be considered, but here we skip if not string.\n                continue\n            clean_str = _ANSI_RE.sub('', item)\n            total_length += len(clean_str)\n        return total_length\n    else:\n        # Defensive fallback: try to convert to string and measure.\n        clean_str = _ANSI_RE.sub('', str(seq))\n        return len(clean_str)", "import re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, (list, tuple)):\n        # Join elements if sequence of strings\n        joined = ''.join(seq)\n    else:\n        # Assume it's a string-like\n        joined = seq\n\n    # Remove all ANSI escape sequences\n    cleaned = _ANSI_RE.sub('', joined)\n\n    # Return length of visible characters\n    return len(cleaned)", "import re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    # If the input is a string, remove ANSI sequences and return length\n    if isinstance(seq, str):\n        # Remove all ANSI escape sequences\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    # If the input is a sequence of strings, sum lengths of each element without ANSI\n    try:\n        # Ensure each item in the sequence is str\n        return sum(len_without_ansi(item) for item in seq)\n    except TypeError:\n        # If seq is not iterable or contains non-str elements, fallback\n        # Treat everything as string representation\n        cleaned = _ANSI_RE.sub('', str(seq))\n        return len(cleaned)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove all ANSI sequences and return length of the remaining string\n        return len(_ANSI_RE.sub('', seq))\n    else:\n        # Assume sequence of strings: sum the len_without_ansi of each element\n        return sum(len_without_ansi(s) for s in seq)\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile(r'(\\x1b\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove ANSI sequences from the string and return its length\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # seq is a sequence of strings (list or tuple)\n        length = 0\n        for item in seq:\n            if not isinstance(item, str):\n                raise TypeError(\"All elements of the sequence must be strings\")\n            cleaned = _ANSI_RE.sub('', item)\n            length += len(cleaned)\n        return length\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove ANSI escape sequences and return the length of the visible characters.\n        clean_str = _ANSI_RE.sub('', seq)\n        return len(clean_str)\n    elif isinstance(seq, (list, tuple)):\n        # If it's a list/tuple of strings, sum the lengths after removing ANSI escape sequences from each element.\n        total_length = 0\n        for item in seq:\n            if not isinstance(item, str):\n                # Defensive: ignoring or raising could be considered, but here we skip if not string.\n                continue\n            clean_str = _ANSI_RE.sub('', item)\n            total_length += len(clean_str)\n        return total_length\n    else:\n        # Defensive fallback: try to convert to string and measure.\n        clean_str = _ANSI_RE.sub('', str(seq))\n        return len(clean_str)\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, (list, tuple)):\n        # Join elements if sequence of strings\n        joined = ''.join(seq)\n    else:\n        # Assume it's a string-like\n        joined = seq\n\n    # Remove all ANSI escape sequences\n    cleaned = _ANSI_RE.sub('', joined)\n\n    # Return length of visible characters\n    return len(cleaned)\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    # If the input is a string, remove ANSI sequences and return length\n    if isinstance(seq, str):\n        # Remove all ANSI escape sequences\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    # If the input is a sequence of strings, sum lengths of each element without ANSI\n    try:\n        # Ensure each item in the sequence is str\n        return sum(len_without_ansi(item) for item in seq)\n    except TypeError:\n        # If seq is not iterable or contains non-str elements, fallback\n        # Treat everything as string representation\n        cleaned = _ANSI_RE.sub('', str(seq))\n        return len(cleaned)\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n"]}
{"task_id": 132, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_unicode_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        code = ord(ch)\n        if code <= 0xFF:\n            # Use \\xHH\n            escaped = f'\\\\x{code:02x}'\n        elif code <= 0xFFFF:\n            # Use \\uHHHH\n            escaped = f'\\\\u{code:04x}'\n        else:\n            # Use \\UHHHHHHHH\n            escaped = f'\\\\U{code:08x}'\n        # Escape the backslash to output literal backslashes\n        result.append(escaped.replace('\\\\', '\\\\\\\\'))\n    return ''.join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escape_char(c):\n        code = ord(c)\n        if code <= 0xFF:\n            # Use \\xHH\n            return f'\\\\x{code:02x}'\n        elif code <= 0xFFFF:\n            # Use \\uHHHH\n            return f'\\\\u{code:04x}'\n        else:\n            # Use \\UHHHHHHHH\n            return f'\\\\U{code:08x}'\n\n    return ''.join(escape_char(c) for c in text)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0xFF:\n            # \\xHH (2 hex digits)\n            result.append(f'\\\\x{codepoint:02x}')\n        elif codepoint <= 0xFFFF:\n            # \\uHHHH (4 hex digits)\n            result.append(f'\\\\u{codepoint:04x}')\n        else:\n            # \\U00HHHHHH (8 hex digits)\n            result.append(f'\\\\U{codepoint:08x}')\n    return ''.join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        code_point = ord(ch)\n        if code_point <= 0xFF:\n            # Use \\xHH escape for code points <= 255\n            result.append('\\\\x{:02x}'.format(code_point))\n        elif code_point <= 0xFFFF:\n            # Use \\uHHHH escape for BMP code points > 255\n            result.append('\\\\u{:04x}'.format(code_point))\n        else:\n            # Use \\UHHHHHHHH escape for code points > 0xFFFF\n            result.append('\\\\U{:08x}'.format(code_point))\n    return ''.join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        code = ord(ch)\n        if code <= 0xFF:\n            # Use \\xHH format for code points <= 0xFF\n            result.append(f\"\\\\x{code:02x}\")\n        elif code <= 0xFFFF:\n            # Use \\uHHHH format for 0x100 - 0xFFFF\n            result.append(f\"\\\\u{code:04x}\")\n        else:\n            # Use \\UHHHHHHHH format for greater code points\n            result.append(f\"\\\\U{code:08x}\")\n    return ''.join(result)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_unicode_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        code = ord(ch)\n        if code <= 0xFF:\n            # Use \\xHH\n            escaped = f'\\\\x{code:02x}'\n        elif code <= 0xFFFF:\n            # Use \\uHHHH\n            escaped = f'\\\\u{code:04x}'\n        else:\n            # Use \\UHHHHHHHH\n            escaped = f'\\\\U{code:08x}'\n        # Escape the backslash to output literal backslashes\n        result.append(escaped.replace('\\\\', '\\\\\\\\'))\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escape_char(c):\n        code = ord(c)\n        if code <= 0xFF:\n            # Use \\xHH\n            return f'\\\\x{code:02x}'\n        elif code <= 0xFFFF:\n            # Use \\uHHHH\n            return f'\\\\u{code:04x}'\n        else:\n            # Use \\UHHHHHHHH\n            return f'\\\\U{code:08x}'\n\n    return ''.join(escape_char(c) for c in text)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0xFF:\n            # \\xHH (2 hex digits)\n            result.append(f'\\\\x{codepoint:02x}')\n        elif codepoint <= 0xFFFF:\n            # \\uHHHH (4 hex digits)\n            result.append(f'\\\\u{codepoint:04x}')\n        else:\n            # \\U00HHHHHH (8 hex digits)\n            result.append(f'\\\\U{codepoint:08x}')\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        code_point = ord(ch)\n        if code_point <= 0xFF:\n            # Use \\xHH escape for code points <= 255\n            result.append('\\\\x{:02x}'.format(code_point))\n        elif code_point <= 0xFFFF:\n            # Use \\uHHHH escape for BMP code points > 255\n            result.append('\\\\u{:04x}'.format(code_point))\n        else:\n            # Use \\UHHHHHHHH escape for code points > 0xFFFF\n            result.append('\\\\U{:08x}'.format(code_point))\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        code = ord(ch)\n        if code <= 0xFF:\n            # Use \\xHH format for code points <= 0xFF\n            result.append(f\"\\\\x{code:02x}\")\n        elif code <= 0xFFFF:\n            # Use \\uHHHH format for 0x100 - 0xFFFF\n            result.append(f\"\\\\u{code:04x}\")\n        else:\n            # Use \\UHHHHHHHH format for greater code points\n            result.append(f\"\\\\U{code:08x}\")\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n"]}
{"task_id": 133, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n    # Use the _each_utf8_hex generator to produce each character or escaped UTF8 hex byte.\n    out = ''.join(_each_utf8_hex(text))\n    return out", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n        text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_utf8_literal\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    out = ''\n    for char in text:\n        utf8_bytes = char.encode('utf-8')\n        for b in utf8_bytes:\n            out += '\\\\x{:02x}'.format(b)\n    return out", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    from functools import reduce\n    import re\n\n    def _each_utf8_hex(text: str):\n        for char in text:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                yield '\\\\x{:02x}'.format(utf8_byte)\n\n    # Use _each_utf8_hex to convert each character accordingly and join\n    out_str = reduce(lambda a, b: a + b, _each_utf8_hex(text), '')\n\n    return out_str", "from functools import reduce\nfrom typing import Tuple\nfrom flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    # Use _each_utf8_hex generator to produce escaped UTF8 hex for each char\n    out_str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text), '')\n    return out_str", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    from functools import reduce\n\n    def _each_utf8_hex(text: str):\n        for char in text:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                yield '\\\\x{:02x}'.format(utf8_byte)\n\n    out_str = reduce(lambda a, b: a + b, _each_utf8_hex(text), '')\n\n    return out_str"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n    # Use the _each_utf8_hex generator to produce each character or escaped UTF8 hex byte.\n    out = ''.join(_each_utf8_hex(text))\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n        text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_utf8_literal\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    out = ''\n    for char in text:\n        utf8_bytes = char.encode('utf-8')\n        for b in utf8_bytes:\n            out += '\\\\x{:02x}'.format(b)\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    from functools import reduce\n    import re\n\n    def _each_utf8_hex(text: str):\n        for char in text:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                yield '\\\\x{:02x}'.format(utf8_byte)\n\n    # Use _each_utf8_hex to convert each character accordingly and join\n    out_str = reduce(lambda a, b: a + b, _each_utf8_hex(text), '')\n\n    return out_str\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\nfrom functools import reduce\nfrom typing import Tuple\nfrom flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    # Use _each_utf8_hex generator to produce escaped UTF8 hex for each char\n    out_str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text), '')\n    return out_str\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    from functools import reduce\n\n    def _each_utf8_hex(text: str):\n        for char in text:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                yield '\\\\x{:02x}'.format(utf8_byte)\n\n    out_str = reduce(lambda a, b: a + b, _each_utf8_hex(text), '')\n\n    return out_str\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n"]}
{"task_id": 134, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the compiled regex _CAMEL_TO_UNDERSCORE_RE from file context to find\n    # positions where uppercase letters are after lowercase or digits\n    # or where uppercase letters followed by lowercase letters (boundary)\n    s1 = re.sub('((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))', r'_\\1', text)\n    return s1.lower()", "import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # This regex matches places where a lowercase letter or digit is followed by an uppercase letter,\n    # or when uppercase letters are followed by lowercase letters (not at start).\n    pattern = re.compile(r'((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))')\n    # Replace matched uppercase letters with '_' + lowercase letter\n    underscored = pattern.sub(r'_\\1', text).lower()\n    return underscored", "import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the compiled regex pattern to find the positions to insert underscores\n    # The regex matches capital letters that are either:\n    # - preceded by a lowercase letter or a number, OR\n    # - an uppercase letter followed by a lowercase letter (not at start)\n    splitted = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    return splitted.lower()", "import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the compiled regex in _CAMEL_TO_UNDERSCORE_RE to insert underscores\n    # before uppercase letters that follow lowercase letters or digits,\n    # or uppercase letters that precede lowercase letters (but not at start).\n    # Then lowercase the entire string.\n\n    # The pattern matches places to split camelcase words\n    pattern = re.compile('((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))')\n    # Insert underscore between the matched boundaries and lower the entire result\n    underscored = pattern.sub(r'_\\1', text).lower()\n    return underscored", "import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regex to find camelCase boundaries and insert underscore\n    s1 = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    return s1.lower()"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the compiled regex _CAMEL_TO_UNDERSCORE_RE from file context to find\n    # positions where uppercase letters are after lowercase or digits\n    # or where uppercase letters followed by lowercase letters (boundary)\n    s1 = re.sub('((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))', r'_\\1', text)\n    return s1.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # This regex matches places where a lowercase letter or digit is followed by an uppercase letter,\n    # or when uppercase letters are followed by lowercase letters (not at start).\n    pattern = re.compile(r'((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))')\n    # Replace matched uppercase letters with '_' + lowercase letter\n    underscored = pattern.sub(r'_\\1', text).lower()\n    return underscored\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the compiled regex pattern to find the positions to insert underscores\n    # The regex matches capital letters that are either:\n    # - preceded by a lowercase letter or a number, OR\n    # - an uppercase letter followed by a lowercase letter (not at start)\n    splitted = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    return splitted.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the compiled regex in _CAMEL_TO_UNDERSCORE_RE to insert underscores\n    # before uppercase letters that follow lowercase letters or digits,\n    # or uppercase letters that precede lowercase letters (but not at start).\n    # Then lowercase the entire string.\n\n    # The pattern matches places to split camelcase words\n    pattern = re.compile('((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))')\n    # Insert underscore between the matched boundaries and lower the entire result\n    underscored = pattern.sub(r'_\\1', text).lower()\n    return underscored\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regex to find camelCase boundaries and insert underscore\n    s1 = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    return s1.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n"]}
{"task_id": 135, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Pattern to match \\xHH, \\uHHHH or \\UHHHHHHHH escape sequences\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(m):\n        esc = m.group(0)\n        # Extract the hex digits after \\x, \\u, or \\U\n        if esc.startswith('\\\\x'):\n            hex_part = esc[2:]\n            codepoint = int(hex_part, 16)\n        elif esc.startswith('\\\\u'):\n            hex_part = esc[2:]\n            codepoint = int(hex_part, 16)\n        elif esc.startswith('\\\\U'):\n            hex_part = esc[2:]\n            codepoint = int(hex_part, 16)\n        else:\n            # Should never happen as pattern enforces it\n            return esc\n        return chr(codepoint)\n\n    # Replace all Unicode escape sequences with their actual characters\n    return pattern.sub(replace_match, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n        hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Define a regex pattern to match all three escape sequences: \\xHH, \\uHHHH, \\UHHHHHHHH\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(match: re.Match) -> str:\n        esc_seq = match.group(0)\n        # Strip the leading backslash and identify the type\n        prefix = esc_seq[1]\n        hex_part = esc_seq[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n\n    return pattern.sub(replace_match, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n\n    # Pattern to match \\xHH, \\uHHHH, or \\UHHHHHHHH\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(m):\n        esc = m.group(0)  # e.g. \\x31, \\u2605, \\U0001f6d1\n        if esc.startswith('\\\\x'):\n            # 2 hex digits\n            hex_part = esc[2:]\n            char_code = int(hex_part, 16)\n        elif esc.startswith('\\\\u'):\n            # 4 hex digits\n            hex_part = esc[2:]\n            char_code = int(hex_part, 16)\n        else:\n            # \\U with 8 hex digits\n            hex_part = esc[2:]\n            char_code = int(hex_part, 16)\n        return chr(char_code)\n\n    return pattern.sub(replace_match, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Regex to match \\xHH, \\uHHHH or \\UHHHHHHHH hex escapes\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(match: re.Match) -> str:\n        esc = match.group(0)\n        # Depending on the prefix, parse hex accordingly\n        if esc.startswith('\\\\x'):\n            codepoint = int(esc[2:], 16)\n        elif esc.startswith('\\\\u'):\n            codepoint = int(esc[2:], 16)\n        else:  # \\\\U\n            codepoint = int(esc[2:], 16)\n        return chr(codepoint)\n\n    # Substitute all matches with their proper unicode character\n    return pattern.sub(replace_match, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n        hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Regex to match \\xHH, \\uHHHH, \\UHHHHHHHH\n    pattern = re.compile(\n        r'\\\\x([0-9a-fA-F]{2})'\n        r'|\\\\u([0-9a-fA-F]{4})'\n        r'|\\\\U([0-9a-fA-F]{8})'\n    )\n\n    def replacer(match: re.Match) -> str:\n        # Extract hex part based on which group matched\n        hex_value = match.group(1) or match.group(2) or match.group(3)\n        # Convert hex to integer code point\n        code_point = int(hex_value, 16)\n        # Convert code point to character\n        return chr(code_point)\n\n    # Use sub to replace all escaped sequences with actual unicode characters\n    return pattern.sub(replacer, text)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Pattern to match \\xHH, \\uHHHH or \\UHHHHHHHH escape sequences\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(m):\n        esc = m.group(0)\n        # Extract the hex digits after \\x, \\u, or \\U\n        if esc.startswith('\\\\x'):\n            hex_part = esc[2:]\n            codepoint = int(hex_part, 16)\n        elif esc.startswith('\\\\u'):\n            hex_part = esc[2:]\n            codepoint = int(hex_part, 16)\n        elif esc.startswith('\\\\U'):\n            hex_part = esc[2:]\n            codepoint = int(hex_part, 16)\n        else:\n            # Should never happen as pattern enforces it\n            return esc\n        return chr(codepoint)\n\n    # Replace all Unicode escape sequences with their actual characters\n    return pattern.sub(replace_match, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n        hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Define a regex pattern to match all three escape sequences: \\xHH, \\uHHHH, \\UHHHHHHHH\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(match: re.Match) -> str:\n        esc_seq = match.group(0)\n        # Strip the leading backslash and identify the type\n        prefix = esc_seq[1]\n        hex_part = esc_seq[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n\n    return pattern.sub(replace_match, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n\n    # Pattern to match \\xHH, \\uHHHH, or \\UHHHHHHHH\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(m):\n        esc = m.group(0)  # e.g. \\x31, \\u2605, \\U0001f6d1\n        if esc.startswith('\\\\x'):\n            # 2 hex digits\n            hex_part = esc[2:]\n            char_code = int(hex_part, 16)\n        elif esc.startswith('\\\\u'):\n            # 4 hex digits\n            hex_part = esc[2:]\n            char_code = int(hex_part, 16)\n        else:\n            # \\U with 8 hex digits\n            hex_part = esc[2:]\n            char_code = int(hex_part, 16)\n        return chr(char_code)\n\n    return pattern.sub(replace_match, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Regex to match \\xHH, \\uHHHH or \\UHHHHHHHH hex escapes\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_match(match: re.Match) -> str:\n        esc = match.group(0)\n        # Depending on the prefix, parse hex accordingly\n        if esc.startswith('\\\\x'):\n            codepoint = int(esc[2:], 16)\n        elif esc.startswith('\\\\u'):\n            codepoint = int(esc[2:], 16)\n        else:  # \\\\U\n            codepoint = int(esc[2:], 16)\n        return chr(codepoint)\n\n    # Substitute all matches with their proper unicode character\n    return pattern.sub(replace_match, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n        hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Regex to match \\xHH, \\uHHHH, \\UHHHHHHHH\n    pattern = re.compile(\n        r'\\\\x([0-9a-fA-F]{2})'\n        r'|\\\\u([0-9a-fA-F]{4})'\n        r'|\\\\U([0-9a-fA-F]{8})'\n    )\n\n    def replacer(match: re.Match) -> str:\n        # Extract hex part based on which group matched\n        hex_value = match.group(1) or match.group(2) or match.group(3)\n        # Convert hex to integer code point\n        code_point = int(hex_value, 16)\n        # Convert code point to character\n        return chr(code_point)\n\n    # Use sub to replace all escaped sequences with actual unicode characters\n    return pattern.sub(replacer, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n"]}
{"task_id": 136, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["from flutils.codecs.raw_utf8_escape import decode\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Use the decode function from flutils.codecs.raw_utf8_escape.\n    # decode returns the decoded string and number of bytes consumed.\n    # Here we want the decoded string only.\n    decoded_str, _ = decode(text.encode('latin1'), errors='strict')\n    return decoded_str", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n        are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Use the decode function from flutils.codecs.raw_utf8_escape to decode entire input\n    decoded_text, consumed = decode(text.encode('latin1'))\n    # Since decode returns the number of bytes consumed, and we have given the entire input,\n    # we don't need to do incremental decoding.\n    return decoded_text", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n        are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    out, _ = decode(text.encode('latin1'))\n    return out", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    out, _ = decode(text.encode('latin1'), errors='strict')\n    return out", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Use the decode function from flutils.codecs.raw_utf8_escape to decode\n    # the entire text. Since decode returns a tuple (string, bytes_consumed),\n    # just return the decoded string part.\n    decoded_string, _ = decode(text.encode('latin1'), errors='strict')\n    return decoded_string"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Use the decode function from flutils.codecs.raw_utf8_escape.\n    # decode returns the decoded string and number of bytes consumed.\n    # Here we want the decoded string only.\n    decoded_str, _ = decode(text.encode('latin1'), errors='strict')\n    return decoded_str\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n        are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Use the decode function from flutils.codecs.raw_utf8_escape to decode entire input\n    decoded_text, consumed = decode(text.encode('latin1'))\n    # Since decode returns the number of bytes consumed, and we have given the entire input,\n    # we don't need to do incremental decoding.\n    return decoded_text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n        are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    out, _ = decode(text.encode('latin1'))\n    return out\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    out, _ = decode(text.encode('latin1'), errors='strict')\n    return out\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Use the decode function from flutils.codecs.raw_utf8_escape to decode\n    # the entire text. Since decode returns a tuple (string, bytes_consumed),\n    # just return the decoded string part.\n    decoded_string, _ = decode(text.encode('latin1'), errors='strict')\n    return decoded_string\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n"]}
{"task_id": 137, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["import re\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores and filter out empty parts (handles multiple, leading, trailing underscores)\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize the first letter of each part\n    parts = [p.capitalize() for p in parts]\n\n    # Join all parts\n    camel = ''.join(parts)\n\n    # If lower_first is True, lowercase the first char\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n\n    return camel", "import re\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, filtering out empty parts\n    parts = [p for p in text.split('_') if p]\n\n    # Capitalize each part\n    capitalized_parts = [p.capitalize() for p in parts]\n\n    if not capitalized_parts:\n        return ''  # If no parts remain, return empty string\n\n    if lower_first:\n        # Lowercase first character of the first part, keep the rest as is\n        first = capitalized_parts[0]\n        first = first[0].lower() + first[1:] if first else ''\n        camel = first + ''.join(capitalized_parts[1:])\n    else:\n        camel = ''.join(capitalized_parts)\n\n    return camel", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split on underscore and filter out empty strings caused by consecutive underscores\n    parts = [part for part in text.split('_') if part]\n\n    if not parts:\n        return ''\n\n    # Capitalize first letter of each part\n    camel = ''.join(word.capitalize() for word in parts)\n\n    # If lower_first is True, lowercase the first character of the resulting string\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n\n    return camel", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, filtering out empty parts caused by\n    # leading, trailing or multiple underscores.\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize all parts except possibly the first one\n    parts = [parts[0].lower() if lower_first else parts[0].capitalize()] + [\n        p.capitalize() for p in parts[1:]\n    ]\n\n    return ''.join(parts)", "import re\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text on underscores and filter out empty strings\n    words = [w for w in text.split('_') if w]\n\n    if not words:\n        return ''\n\n    # Capitalize first letter of each word except optionally the first word\n    if lower_first:\n        first_word = words[0].lower()\n    else:\n        first_word = words[0].capitalize()\n\n    camel_parts = [first_word]\n    for w in words[1:]:\n        camel_parts.append(w.capitalize())\n\n    return ''.join(camel_parts)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\nimport re\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores and filter out empty parts (handles multiple, leading, trailing underscores)\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize the first letter of each part\n    parts = [p.capitalize() for p in parts]\n\n    # Join all parts\n    camel = ''.join(parts)\n\n    # If lower_first is True, lowercase the first char\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n\n    return camel\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\nimport re\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, filtering out empty parts\n    parts = [p for p in text.split('_') if p]\n\n    # Capitalize each part\n    capitalized_parts = [p.capitalize() for p in parts]\n\n    if not capitalized_parts:\n        return ''  # If no parts remain, return empty string\n\n    if lower_first:\n        # Lowercase first character of the first part, keep the rest as is\n        first = capitalized_parts[0]\n        first = first[0].lower() + first[1:] if first else ''\n        camel = first + ''.join(capitalized_parts[1:])\n    else:\n        camel = ''.join(capitalized_parts)\n\n    return camel\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split on underscore and filter out empty strings caused by consecutive underscores\n    parts = [part for part in text.split('_') if part]\n\n    if not parts:\n        return ''\n\n    # Capitalize first letter of each part\n    camel = ''.join(word.capitalize() for word in parts)\n\n    # If lower_first is True, lowercase the first character of the resulting string\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n\n    return camel\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, filtering out empty parts caused by\n    # leading, trailing or multiple underscores.\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize all parts except possibly the first one\n    parts = [parts[0].lower() if lower_first else parts[0].capitalize()] + [\n        p.capitalize() for p in parts[1:]\n    ]\n\n    return ''.join(parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\nimport re\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text on underscores and filter out empty strings\n    words = [w for w in text.split('_') if w]\n\n    if not words:\n        return ''\n\n    # Capitalize first letter of each word except optionally the first word\n    if lower_first:\n        first_word = words[0].lower()\n    else:\n        first_word = words[0].capitalize()\n\n    camel_parts = [first_word]\n    for w in words[1:]:\n        camel_parts.append(w.capitalize())\n\n    return ''.join(camel_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n"]}
{"task_id": 138, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # get current user's primary group\n        user_name = getpass.getuser()\n        try:\n            pw_record = __import__('pwd').getpwnam(user_name)\n            gid = pw_record.pw_gid\n        except KeyError as e:\n            raise OSError(f\"User {user_name} not found\") from e\n        # Get group by gid\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        # Try to get group by gid\n        try:\n            return grp.getgrgid(name)\n        except KeyError as e:\n            raise OSError(f\"Group id {name} does not exist\") from e\n    elif isinstance(name, str):\n        # Try to get group by name\n        try:\n            return grp.getgrnam(name)\n        except KeyError as e:\n            raise OSError(f\"Group name '{name}' does not exist\") from e\n    else:\n        # Unexpected type\n        raise TypeError(f\"Invalid type for name: {type(name)}. Expected str, int, or None.\")", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group\n        try:\n            username = getpass.getuser()\n        except Exception:\n            # Fallback: use environment variable or raise\n            import os\n            username = os.getenv('USER') or os.getenv('USERNAME')\n            if not username:\n                raise OSError(\"Unable to determine the current user\")\n        import pwd\n        user_info = pwd.getpwnam(username)\n        gid = user_info.pw_gid\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # name is a gid\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        # name is a group name\n        return grp.getgrnam(name)\n\n    raise TypeError(f\"Invalid type for group name/gid: {type(name)}\")", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group name via gid\n        user_name = getpass.getuser()\n        # Find user's gid from passwd entry\n        import pwd\n        pw_entry = pwd.getpwnam(user_name)\n        gid = pw_entry.pw_gid\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # name is a gid\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        # name is a group name\n        return grp.getgrnam(name)\n\n    # If none of the above, raise error\n    raise OSError(f'Group {name!r} does not exist')", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    # If no name is provided, get current user's group\n    if name is None:\n        # Get current user's username\n        user = getpass.getuser()\n        # Get user's primary group id from password database\n        import pwd\n        pw_record = pwd.getpwnam(user)\n        gid = pw_record.pw_gid\n        # Return group info by gid\n        return grp.getgrgid(gid)\n\n    # If name is string containing digits, try to treat as gid\n    if isinstance(name, int):\n        # name is already an integer gid\n        try:\n            return grp.getgrgid(name)\n        except KeyError as e:\n            raise OSError(f\"Group id {name} does not exist.\") from e\n\n    if isinstance(name, str):\n        # Try if name is digits representing a gid\n        if name.isdigit():\n            gid_int = int(name)\n            try:\n                return grp.getgrgid(gid_int)\n            except KeyError as e:\n                raise OSError(f\"Group id {gid_int} does not exist.\") from e\n        else:\n            # name is string group name\n            try:\n                return grp.getgrnam(name)\n            except KeyError as e:\n                raise OSError(f\"Group name '{name}' does not exist.\") from e\n\n    # If type not handled, raise error\n    raise TypeError(\"name must be None, str, or int\")", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group ID and then the group struct\n        user = getpass.getuser()\n        import pwd\n        pw = pwd.getpwnam(user)\n        gid = pw.pw_gid\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        # If an int, treat as gid\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        # If str, try group name first\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(f\"Invalid type for 'name': {type(name)}. Must be str, int, or None.\")"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # get current user's primary group\n        user_name = getpass.getuser()\n        try:\n            pw_record = __import__('pwd').getpwnam(user_name)\n            gid = pw_record.pw_gid\n        except KeyError as e:\n            raise OSError(f\"User {user_name} not found\") from e\n        # Get group by gid\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        # Try to get group by gid\n        try:\n            return grp.getgrgid(name)\n        except KeyError as e:\n            raise OSError(f\"Group id {name} does not exist\") from e\n    elif isinstance(name, str):\n        # Try to get group by name\n        try:\n            return grp.getgrnam(name)\n        except KeyError as e:\n            raise OSError(f\"Group name '{name}' does not exist\") from e\n    else:\n        # Unexpected type\n        raise TypeError(f\"Invalid type for name: {type(name)}. Expected str, int, or None.\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group\n        try:\n            username = getpass.getuser()\n        except Exception:\n            # Fallback: use environment variable or raise\n            import os\n            username = os.getenv('USER') or os.getenv('USERNAME')\n            if not username:\n                raise OSError(\"Unable to determine the current user\")\n        import pwd\n        user_info = pwd.getpwnam(username)\n        gid = user_info.pw_gid\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # name is a gid\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        # name is a group name\n        return grp.getgrnam(name)\n\n    raise TypeError(f\"Invalid type for group name/gid: {type(name)}\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group name via gid\n        user_name = getpass.getuser()\n        # Find user's gid from passwd entry\n        import pwd\n        pw_entry = pwd.getpwnam(user_name)\n        gid = pw_entry.pw_gid\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # name is a gid\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        # name is a group name\n        return grp.getgrnam(name)\n\n    # If none of the above, raise error\n    raise OSError(f'Group {name!r} does not exist')\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    # If no name is provided, get current user's group\n    if name is None:\n        # Get current user's username\n        user = getpass.getuser()\n        # Get user's primary group id from password database\n        import pwd\n        pw_record = pwd.getpwnam(user)\n        gid = pw_record.pw_gid\n        # Return group info by gid\n        return grp.getgrgid(gid)\n\n    # If name is string containing digits, try to treat as gid\n    if isinstance(name, int):\n        # name is already an integer gid\n        try:\n            return grp.getgrgid(name)\n        except KeyError as e:\n            raise OSError(f\"Group id {name} does not exist.\") from e\n\n    if isinstance(name, str):\n        # Try if name is digits representing a gid\n        if name.isdigit():\n            gid_int = int(name)\n            try:\n                return grp.getgrgid(gid_int)\n            except KeyError as e:\n                raise OSError(f\"Group id {gid_int} does not exist.\") from e\n        else:\n            # name is string group name\n            try:\n                return grp.getgrnam(name)\n            except KeyError as e:\n                raise OSError(f\"Group name '{name}' does not exist.\") from e\n\n    # If type not handled, raise error\n    raise TypeError(\"name must be None, str, or int\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group ID and then the group struct\n        user = getpass.getuser()\n        import pwd\n        pw = pwd.getpwnam(user)\n        gid = pw.pw_gid\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        # If an int, treat as gid\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        # If str, try group name first\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(f\"Invalid type for 'name': {type(name)}. Must be str, int, or None.\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()"]}
{"task_id": 139, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["import getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    try:\n        if isinstance(name, int):\n            # name is a uid\n            return pwd.getpwuid(name)\n        else:\n            # name is a username string\n            return pwd.getpwnam(name)\n    except KeyError:\n        if isinstance(name, int):\n            raise OSError(f\"The given uid: {name!r}, is not a valid uid for this operating system.\")\n        else:\n            raise OSError(f\"The given name: {name!r}, is not a valid login name for this operating system.\")", "import getpass\nimport pwd\nfrom typing import Union, Optional, cast\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            f\"The given name: {name!r} is not a valid 'login name' for this operating system.\"\n        )", "import getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default to current user's login name\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        # Treat as uid\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r}, is not a valid uid for this operating system.\"\n            )\n    else:\n        # Treat as login name (str)\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid 'login name' for this operating system.\"\n            )", "import getpass\nimport pwd\nfrom typing import Union, Optional\n\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        username = getpass.getuser()\n        try:\n            return pwd.getpwnam(username)\n        except KeyError:\n            raise OSError(\n                f\"The current user's login name '{username}' does not exist \"\n                \"on this operating system.\"\n            )\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    # Otherwise name is str\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            f\"The given name: {name!r} is not a valid 'login name' for this operating system.\"\n        )", "import getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default to current user's login name\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r}, is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid 'login name' for this operating system.\"\n            )"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    try:\n        if isinstance(name, int):\n            # name is a uid\n            return pwd.getpwuid(name)\n        else:\n            # name is a username string\n            return pwd.getpwnam(name)\n    except KeyError:\n        if isinstance(name, int):\n            raise OSError(f\"The given uid: {name!r}, is not a valid uid for this operating system.\")\n        else:\n            raise OSError(f\"The given name: {name!r}, is not a valid login name for this operating system.\")\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional, cast\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            f\"The given name: {name!r} is not a valid 'login name' for this operating system.\"\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default to current user's login name\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        # Treat as uid\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r}, is not a valid uid for this operating system.\"\n            )\n    else:\n        # Treat as login name (str)\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid 'login name' for this operating system.\"\n            )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        username = getpass.getuser()\n        try:\n            return pwd.getpwnam(username)\n        except KeyError:\n            raise OSError(\n                f\"The current user's login name '{username}' does not exist \"\n                \"on this operating system.\"\n            )\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    # Otherwise name is str\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            f\"The given name: {name!r} is not a valid 'login name' for this operating system.\"\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default to current user's login name\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r}, is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid 'login name' for this operating system.\"\n            )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()"]}
{"task_id": 140, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["from typing import Tuple, Union, cast\nfrom collections import UserString\nimport codecs\n\n_Str = Union[str, UserString]\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert input errors to str in case it is UserString\n    errors_input = cast(str, errors)\n\n    # Step 1: Convert text which may contain escaped utf8 hex literals\n    # into proper unicode characters (decode the escape sequences).\n    # This relies on convert_escaped_utf8_literal which may raise UnicodeDecodeError.\n    from flutils.strutils import convert_escaped_utf8_literal\n    try:\n        normalized_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # Raise with the required UnicodeEncodeError as mandated by the docstring\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text).encode('utf-8', errors='strict'),\n            e.start,\n            e.end,\n            e.reason\n        )\n\n    # Step 2: Encode the normalized text into escaped utf8 hex bytes.\n    # We use _each_utf8_hex to get a generator of printable chars and escaped utf8 hex bytes.\n    # Join to a string first.\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n    escaped_str = ''.join(_each_utf8_hex(normalized_text))\n\n    # Step 3: Convert the escaped string (e.g. containing \\xHH sequences)\n    # into bytes by decoding it with unicode_escape.\n    # This converts \\xHH to the actual byte 0xHH.\n    try:\n        escaped_bytes = escaped_str.encode('latin1').decode('unicode_escape').encode('latin1')\n    except UnicodeDecodeError as e:\n        # If the escaped sequence is malformed (should not happen here),\n        # re-raise as UnicodeEncodeError.\n        raise UnicodeEncodeError(\n            'eutf8h',\n            escaped_str.encode('utf8', errors='strict'),\n            e.start,\n            e.end,\n            e.reason\n        )\n\n    return escaped_bytes, len(text)", "from typing import Tuple, Union, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert errors to str in case it is UserString\n    errors = str(errors)\n\n    # First convert the input text that may contain escaped UTF8 hex into a proper string of characters.\n    # This step validates if the escape sequences correspond to valid UTF8 bytes.\n    try:\n        # We must import convert_escaped_utf8_literal here to avoid import conflicts and because\n        # it registered the raw_utf8_escape codec needed to decode the escaped sequences properly.\n        from flutils.strutils import convert_escaped_utf8_literal\n        decoded_text = convert_escaped_utf8_literal(text)\n    except UnicodeDecodeError as e:\n        # Re-raise as UnicodeEncodeError per docstring\n        raise UnicodeEncodeError('eutf8h', text, e.start, e.end, e.reason) from None\n\n    # Now, encode that decoded text to a bytes object of escaped utf8 hexadecimal sequences.\n    # We will convert each character as per _each_utf8_hex: printable ASCII as-is, others as escaped utf8 hex.\n    # The output is a string mixing chars and escape sequences; we then encode to ascii bytes.\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n    encoded_pieces = list(_each_utf8_hex(decoded_text))\n    encoded_str = ''.join(encoded_pieces)\n    # The encoded_str consists of printable ASCII chars and escape sequences like \\xHH.\n    # We encode this string to ascii bytes.\n    encoded_bytes = encoded_str.encode('ascii', errors)\n\n    # Return the encoded bytes and number of original input characters consumed (the full input)\n    return encoded_bytes, len(text)", "from typing import Tuple, Union, cast\nfrom collections import UserString\nimport codecs\n\n_Str = Union[str, UserString]\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert errors to str if it's UserString\n    errors_input = str(errors)\n\n    # Cast text to str for processing convenience\n    text_str = cast(str, text)\n\n    # First, ensure that if the input text contains escaped utf8 hex (e.g. \\xc3\\xa9),\n    # they are valid UTF8 sequences. This is done by trying to decode via convert_escaped_utf8_literal\n    # which raises UnicodeDecodeError if invalid sequences exist.\n    # If errors='strict' propagate error, else handle accordingly.\n    from flutils.strutils import convert_escaped_utf8_literal\n\n    try:\n        # Validate and convert any escaped UTF8 hex in the input text to proper Unicode characters.\n        _ = convert_escaped_utf8_literal(text_str)\n    except UnicodeDecodeError as e:\n        if errors_input == 'strict':\n            raise\n        elif errors_input == 'ignore':\n            # On ignore, just skip validation and assume best effort...\n            # But this is questionable; safer to re-raise.\n            raise\n        elif errors_input == 'replace':\n            # Replace invalid sequences with replacement char - we can't do partial\n            # conversions here easily, so raise anyway.\n            raise\n        else:\n            # Unknown error handler - raise\n            raise\n\n    # Now convert each character in the input text into:\n    # - printable ASCII characters as is\n    # - other characters as escaped UTF8 hex bytes (\\xHH)\n    # This matches the _each_utf8_hex generator behavior.\n    def _each_utf8_hex(text: _Str):\n        for char in text:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n                yield str_hex\n\n    escaped_str_parts = list(_each_utf8_hex(text_str))\n    escaped_str = ''.join(escaped_str_parts)\n\n    # The escaped string now consists of printable ASCII and escaped hex sequences,\n    # so encode it as latin-1 bytes for exact byte-to-byte mapping.\n    out_bytes = escaped_str.encode('latin1')\n\n    return out_bytes, len(text_str)", "from typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # 1. First, convert any escaped utf8 hexadecimal sequences in input text into proper characters.\n    #    This validates correctness of escaped sequences and ensures \"text\" is normalized as characters.\n    try:\n        from flutils.strutils import convert_escaped_utf8_literal\n        normalized_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # Re-raise as UnicodeEncodeError to meet the docstring spec.\n        raise UnicodeEncodeError(\n            \"eutf8h\",\n            text,\n            e.start,\n            e.end,\n            e.reason\n        ) from e\n\n    # 2. Convert the normalized text characters into escaped utf8 hexadecimal sequences.\n    #    Using the _each_utf8_hex generator from the file content style (already provided).\n    def _each_utf8_hex(text_: _Str):\n        for char in text_:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                yield '\\\\' + hex(utf8_byte)[1:]\n\n    # Generate the escaped utf8 hex string sequence\n    escaped_str = ''.join(_each_utf8_hex(normalized_text))\n\n    # Encoding the escaped string to bytes. The escaped_str contains printable characters + backslash-hex sequences.\n    # Because it's a string representing escaped bytes, encode with 'latin1' to get the raw byte values correctly.\n    # However, here the escaped sequences are in the form of literal backslashes + hex digits (e.g. \\xe2),\n    # so we need to encode it as ascii or utf-8 to get their exact literal byte sequence.\n    # But we want the escaped form retained; the common approach is to encode using ASCII since all characters are ASCII printable.\n    try:\n        escaped_bytes = escaped_str.encode('ascii', errors=str(errors))\n    except UnicodeEncodeError as e:\n        # Propagate errors according to the given `errors` parameter\n        raise UnicodeEncodeError(\n            \"eutf8h\",\n            escaped_str,\n            e.start,\n            e.end,\n            e.reason\n        ) from e\n\n    # Return the escaped bytes and length of input text consumed\n    return escaped_bytes, len(text)", "from typing import Tuple, Union, cast\nfrom collections import UserString\nimport codecs\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # First, normalize the errors parameter to str\n    errors_input = str(errors)\n\n    # Convert the input text (which may contain escaped UTF-8 hexadecimal) into proper characters.\n    # This step will raise UnicodeDecodeError if invalid escaped UTF8 byte sequences are present.\n    # We use the context function convert_escaped_utf8_literal to interpret escaped hex sequences.\n    from flutils.strutils import convert_escaped_utf8_literal\n\n    try:\n        decoded_text = convert_escaped_utf8_literal(text if isinstance(text, str) else str(text))\n    except UnicodeDecodeError as e:\n        # When convert_escaped_utf8_literal fails decoding, convert_escaped_utf8_literal raises UnicodeDecodeError,\n        # but our function should raise UnicodeEncodeError as per docstring.\n        # So we convert the exception type accordingly.\n        raise UnicodeEncodeError(\n            \"eutf8h\",  # encoding name\n            text,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now encode the decoded_text into escaped utf8 bytes.\n    # We need the output to be bytes of escaped utf8 hexadecimal.\n    # This means: for printable ASCII chars (code < 128 and printable) yield as-is bytes,\n    # else yield UTF8 bytes escaped as \\xhh.\n\n    # Since we want the final output to be bytes with escaped utf8 hexadecimal sequences,\n    # we can build a string of such escaped characters and then encode to bytes.\n\n    # The provided _each_utf8_hex generator yields strings:\n    # for ASCII printable chars, the char itself,\n    # for others, escaped hex sequences like \\xhh.\n\n    # Using _each_utf8_hex and joining results to form the escaped string.\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n    try:\n        escaped_str = ''.join(_each_utf8_hex(decoded_text))\n    except Exception as e:\n        # If something unexpected occurs, raise UnicodeEncodeError to be consistent.\n        raise UnicodeEncodeError(\n            \"eutf8h\",\n            text if isinstance(text, bytes) else text.encode('utf-8', errors_input),\n            0,\n            len(text),\n            f\"Encoding failed: {e}\",\n        )\n\n    # Convert the escaped string into bytes using ascii encoding.\n    # The escaped string consists of ASCII characters only (printables and \\x sequences)\n    escaped_bytes = escaped_str.encode('ascii')\n\n    chars_consumed = len(text)\n\n    return escaped_bytes, chars_consumed"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union, cast\nfrom collections import UserString\nimport codecs\n\n_Str = Union[str, UserString]\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert input errors to str in case it is UserString\n    errors_input = cast(str, errors)\n\n    # Step 1: Convert text which may contain escaped utf8 hex literals\n    # into proper unicode characters (decode the escape sequences).\n    # This relies on convert_escaped_utf8_literal which may raise UnicodeDecodeError.\n    from flutils.strutils import convert_escaped_utf8_literal\n    try:\n        normalized_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # Raise with the required UnicodeEncodeError as mandated by the docstring\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text).encode('utf-8', errors='strict'),\n            e.start,\n            e.end,\n            e.reason\n        )\n\n    # Step 2: Encode the normalized text into escaped utf8 hex bytes.\n    # We use _each_utf8_hex to get a generator of printable chars and escaped utf8 hex bytes.\n    # Join to a string first.\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n    escaped_str = ''.join(_each_utf8_hex(normalized_text))\n\n    # Step 3: Convert the escaped string (e.g. containing \\xHH sequences)\n    # into bytes by decoding it with unicode_escape.\n    # This converts \\xHH to the actual byte 0xHH.\n    try:\n        escaped_bytes = escaped_str.encode('latin1').decode('unicode_escape').encode('latin1')\n    except UnicodeDecodeError as e:\n        # If the escaped sequence is malformed (should not happen here),\n        # re-raise as UnicodeEncodeError.\n        raise UnicodeEncodeError(\n            'eutf8h',\n            escaped_str.encode('utf8', errors='strict'),\n            e.start,\n            e.end,\n            e.reason\n        )\n\n    return escaped_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert errors to str in case it is UserString\n    errors = str(errors)\n\n    # First convert the input text that may contain escaped UTF8 hex into a proper string of characters.\n    # This step validates if the escape sequences correspond to valid UTF8 bytes.\n    try:\n        # We must import convert_escaped_utf8_literal here to avoid import conflicts and because\n        # it registered the raw_utf8_escape codec needed to decode the escaped sequences properly.\n        from flutils.strutils import convert_escaped_utf8_literal\n        decoded_text = convert_escaped_utf8_literal(text)\n    except UnicodeDecodeError as e:\n        # Re-raise as UnicodeEncodeError per docstring\n        raise UnicodeEncodeError('eutf8h', text, e.start, e.end, e.reason) from None\n\n    # Now, encode that decoded text to a bytes object of escaped utf8 hexadecimal sequences.\n    # We will convert each character as per _each_utf8_hex: printable ASCII as-is, others as escaped utf8 hex.\n    # The output is a string mixing chars and escape sequences; we then encode to ascii bytes.\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n    encoded_pieces = list(_each_utf8_hex(decoded_text))\n    encoded_str = ''.join(encoded_pieces)\n    # The encoded_str consists of printable ASCII chars and escape sequences like \\xHH.\n    # We encode this string to ascii bytes.\n    encoded_bytes = encoded_str.encode('ascii', errors)\n\n    # Return the encoded bytes and number of original input characters consumed (the full input)\n    return encoded_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union, cast\nfrom collections import UserString\nimport codecs\n\n_Str = Union[str, UserString]\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert errors to str if it's UserString\n    errors_input = str(errors)\n\n    # Cast text to str for processing convenience\n    text_str = cast(str, text)\n\n    # First, ensure that if the input text contains escaped utf8 hex (e.g. \\xc3\\xa9),\n    # they are valid UTF8 sequences. This is done by trying to decode via convert_escaped_utf8_literal\n    # which raises UnicodeDecodeError if invalid sequences exist.\n    # If errors='strict' propagate error, else handle accordingly.\n    from flutils.strutils import convert_escaped_utf8_literal\n\n    try:\n        # Validate and convert any escaped UTF8 hex in the input text to proper Unicode characters.\n        _ = convert_escaped_utf8_literal(text_str)\n    except UnicodeDecodeError as e:\n        if errors_input == 'strict':\n            raise\n        elif errors_input == 'ignore':\n            # On ignore, just skip validation and assume best effort...\n            # But this is questionable; safer to re-raise.\n            raise\n        elif errors_input == 'replace':\n            # Replace invalid sequences with replacement char - we can't do partial\n            # conversions here easily, so raise anyway.\n            raise\n        else:\n            # Unknown error handler - raise\n            raise\n\n    # Now convert each character in the input text into:\n    # - printable ASCII characters as is\n    # - other characters as escaped UTF8 hex bytes (\\xHH)\n    # This matches the _each_utf8_hex generator behavior.\n    def _each_utf8_hex(text: _Str):\n        for char in text:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n                yield str_hex\n\n    escaped_str_parts = list(_each_utf8_hex(text_str))\n    escaped_str = ''.join(escaped_str_parts)\n\n    # The escaped string now consists of printable ASCII and escaped hex sequences,\n    # so encode it as latin-1 bytes for exact byte-to-byte mapping.\n    out_bytes = escaped_str.encode('latin1')\n\n    return out_bytes, len(text_str)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # 1. First, convert any escaped utf8 hexadecimal sequences in input text into proper characters.\n    #    This validates correctness of escaped sequences and ensures \"text\" is normalized as characters.\n    try:\n        from flutils.strutils import convert_escaped_utf8_literal\n        normalized_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # Re-raise as UnicodeEncodeError to meet the docstring spec.\n        raise UnicodeEncodeError(\n            \"eutf8h\",\n            text,\n            e.start,\n            e.end,\n            e.reason\n        ) from e\n\n    # 2. Convert the normalized text characters into escaped utf8 hexadecimal sequences.\n    #    Using the _each_utf8_hex generator from the file content style (already provided).\n    def _each_utf8_hex(text_: _Str):\n        for char in text_:\n            if ord(char) < 128 and char.isprintable():\n                yield char\n                continue\n            utf8_bytes = char.encode('utf8')\n            for utf8_byte in utf8_bytes:\n                yield '\\\\' + hex(utf8_byte)[1:]\n\n    # Generate the escaped utf8 hex string sequence\n    escaped_str = ''.join(_each_utf8_hex(normalized_text))\n\n    # Encoding the escaped string to bytes. The escaped_str contains printable characters + backslash-hex sequences.\n    # Because it's a string representing escaped bytes, encode with 'latin1' to get the raw byte values correctly.\n    # However, here the escaped sequences are in the form of literal backslashes + hex digits (e.g. \\xe2),\n    # so we need to encode it as ascii or utf-8 to get their exact literal byte sequence.\n    # But we want the escaped form retained; the common approach is to encode using ASCII since all characters are ASCII printable.\n    try:\n        escaped_bytes = escaped_str.encode('ascii', errors=str(errors))\n    except UnicodeEncodeError as e:\n        # Propagate errors according to the given `errors` parameter\n        raise UnicodeEncodeError(\n            \"eutf8h\",\n            escaped_str,\n            e.start,\n            e.end,\n            e.reason\n        ) from e\n\n    # Return the escaped bytes and length of input text consumed\n    return escaped_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union, cast\nfrom collections import UserString\nimport codecs\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # First, normalize the errors parameter to str\n    errors_input = str(errors)\n\n    # Convert the input text (which may contain escaped UTF-8 hexadecimal) into proper characters.\n    # This step will raise UnicodeDecodeError if invalid escaped UTF8 byte sequences are present.\n    # We use the context function convert_escaped_utf8_literal to interpret escaped hex sequences.\n    from flutils.strutils import convert_escaped_utf8_literal\n\n    try:\n        decoded_text = convert_escaped_utf8_literal(text if isinstance(text, str) else str(text))\n    except UnicodeDecodeError as e:\n        # When convert_escaped_utf8_literal fails decoding, convert_escaped_utf8_literal raises UnicodeDecodeError,\n        # but our function should raise UnicodeEncodeError as per docstring.\n        # So we convert the exception type accordingly.\n        raise UnicodeEncodeError(\n            \"eutf8h\",  # encoding name\n            text,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now encode the decoded_text into escaped utf8 bytes.\n    # We need the output to be bytes of escaped utf8 hexadecimal.\n    # This means: for printable ASCII chars (code < 128 and printable) yield as-is bytes,\n    # else yield UTF8 bytes escaped as \\xhh.\n\n    # Since we want the final output to be bytes with escaped utf8 hexadecimal sequences,\n    # we can build a string of such escaped characters and then encode to bytes.\n\n    # The provided _each_utf8_hex generator yields strings:\n    # for ASCII printable chars, the char itself,\n    # for others, escaped hex sequences like \\xhh.\n\n    # Using _each_utf8_hex and joining results to form the escaped string.\n    from flutils.codecs.raw_utf8_escape import _each_utf8_hex\n\n    try:\n        escaped_str = ''.join(_each_utf8_hex(decoded_text))\n    except Exception as e:\n        # If something unexpected occurs, raise UnicodeEncodeError to be consistent.\n        raise UnicodeEncodeError(\n            \"eutf8h\",\n            text if isinstance(text, bytes) else text.encode('utf-8', errors_input),\n            0,\n            len(text),\n            f\"Encoding failed: {e}\",\n        )\n\n    # Convert the escaped string into bytes using ascii encoding.\n    # The escaped string consists of ASCII characters only (printables and \\x sequences)\n    escaped_bytes = escaped_str.encode('ascii')\n\n    chars_consumed = len(text)\n\n    return escaped_bytes, chars_consumed\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()"]}
{"task_id": 141, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["from typing import Tuple, Union, ByteString as _ByteString\n\n_Str = Union[str, 'UserString']\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    from flutils.strutils import convert_escaped_utf8_literal\n    from UserString import UserString\n\n    # Convert bytes input into str using UTF-8 decoding\n    try:\n        data_str = data.decode('utf-8', errors=str(errors))\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'raw_utf8_escape',\n            data,\n            e.start,\n            e.end,\n            e.reason\n        )\n\n    try:\n        decoded_str = convert_escaped_utf8_literal(data_str)\n    except UnicodeDecodeError as e:\n        raise\n\n    return decoded_str, len(data)", "from typing import ByteString, Tuple, Union, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n    \"\"\"\n\n    # Convert the ByteString to a string decoding as 'utf-8'\n    data_str = data.decode('utf-8', errors=str(errors))\n\n    # Try to decode the escaped utf8 hexadecimal bytes into proper string\n    # The approach:\n    # 1. Decode the escaped UTF-8 hexadecimal bytes (like '\\\\xc2\\\\xa9') into proper bytes.\n    # 2. Decode those bytes into a proper Unicode string using UTF-8.\n    # This is done by:\n    #  - bytes: data is escaped utf8 hex bytes (e.g. b\"\\\\xc2\\\\xa9\")\n    #  - decode to string (done) -> data_str = \"\\\\xc2\\\\xa9\"\n    #  - encode to bytes interpreting those escapes -> bytes.decode('raw_utf8_escape') does that.\n    # We do this as in convert_escaped_utf8_literal.\n\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n\n    try:\n        # encode string into bytes with utf-8\n        temp_bytes = data_str.encode('utf-8')\n        # decode bytes using the 'raw_utf8_escape' codec to get the proper Unicode string\n        decoded_str = temp_bytes.decode('raw_utf8_escape', errors=str(errors))\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return decoded_str, len(data)", "from typing import ByteString, Tuple, Union, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert bytes input into a string using latin1 to retain byte values\n    data_str = data.decode('latin1')\n\n    # Now decode escape sequences to actual bytes (e.g., turning \\xHH into byte 0xHH)\n    try:\n        # decode unicode_escape converts sequences like \\\\xHH to actual bytes in a str\n        decoded_escapes = data_str.encode('latin1').decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # After decode unicode_escape, decoded_escapes is a str that contains UTF-8 encoded bytes actually interpreted as characters\n    # To get bytes back from that string, encode with latin1\n    utf8_bytes = decoded_escapes.encode('latin1')\n\n    # Decode these utf8 bytes to get the final string\n    try:\n        text_str = utf8_bytes.decode('utf-8', errors=str(errors))\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return text_str, len(data)", "from typing import ByteString, Tuple, Union, cast\nfrom flutils.strutils import convert_escaped_utf8_literal\n\n_Str = Union[str, ByteString]\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert bytes data to a string assuming utf-8 encoding\n    data_str = cast(str, data.decode('utf-8', errors=str(errors)))\n\n    try:\n        # Use the context function to convert escaped UTF-8 hex bytes to proper Unicode characters\n        decoded_str = convert_escaped_utf8_literal(data_str)\n    except UnicodeDecodeError as e:\n        # Re-raise as UnicodeDecodeError with appropriate info\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason\n        ) from e\n\n    # Return the decoded string and the length of input bytes consumed (all of them)\n    return decoded_str, len(data)", "from typing import Tuple, Union, ByteString as _ByteString\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    try:\n        text = data.decode('utf-8', errors=str(errors))\n        decoded = convert_escaped_utf8_literal(text)\n        return decoded, len(data)\n    except UnicodeDecodeError as e:\n        raise e"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import Tuple, Union, ByteString as _ByteString\n\n_Str = Union[str, 'UserString']\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    from flutils.strutils import convert_escaped_utf8_literal\n    from UserString import UserString\n\n    # Convert bytes input into str using UTF-8 decoding\n    try:\n        data_str = data.decode('utf-8', errors=str(errors))\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'raw_utf8_escape',\n            data,\n            e.start,\n            e.end,\n            e.reason\n        )\n\n    try:\n        decoded_str = convert_escaped_utf8_literal(data_str)\n    except UnicodeDecodeError as e:\n        raise\n\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import ByteString, Tuple, Union, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n    \"\"\"\n\n    # Convert the ByteString to a string decoding as 'utf-8'\n    data_str = data.decode('utf-8', errors=str(errors))\n\n    # Try to decode the escaped utf8 hexadecimal bytes into proper string\n    # The approach:\n    # 1. Decode the escaped UTF-8 hexadecimal bytes (like '\\\\xc2\\\\xa9') into proper bytes.\n    # 2. Decode those bytes into a proper Unicode string using UTF-8.\n    # This is done by:\n    #  - bytes: data is escaped utf8 hex bytes (e.g. b\"\\\\xc2\\\\xa9\")\n    #  - decode to string (done) -> data_str = \"\\\\xc2\\\\xa9\"\n    #  - encode to bytes interpreting those escapes -> bytes.decode('raw_utf8_escape') does that.\n    # We do this as in convert_escaped_utf8_literal.\n\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n\n    try:\n        # encode string into bytes with utf-8\n        temp_bytes = data_str.encode('utf-8')\n        # decode bytes using the 'raw_utf8_escape' codec to get the proper Unicode string\n        decoded_str = temp_bytes.decode('raw_utf8_escape', errors=str(errors))\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import ByteString, Tuple, Union, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert bytes input into a string using latin1 to retain byte values\n    data_str = data.decode('latin1')\n\n    # Now decode escape sequences to actual bytes (e.g., turning \\xHH into byte 0xHH)\n    try:\n        # decode unicode_escape converts sequences like \\\\xHH to actual bytes in a str\n        decoded_escapes = data_str.encode('latin1').decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # After decode unicode_escape, decoded_escapes is a str that contains UTF-8 encoded bytes actually interpreted as characters\n    # To get bytes back from that string, encode with latin1\n    utf8_bytes = decoded_escapes.encode('latin1')\n\n    # Decode these utf8 bytes to get the final string\n    try:\n        text_str = utf8_bytes.decode('utf-8', errors=str(errors))\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return text_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import ByteString, Tuple, Union, cast\nfrom flutils.strutils import convert_escaped_utf8_literal\n\n_Str = Union[str, ByteString]\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert bytes data to a string assuming utf-8 encoding\n    data_str = cast(str, data.decode('utf-8', errors=str(errors)))\n\n    try:\n        # Use the context function to convert escaped UTF-8 hex bytes to proper Unicode characters\n        decoded_str = convert_escaped_utf8_literal(data_str)\n    except UnicodeDecodeError as e:\n        # Re-raise as UnicodeDecodeError with appropriate info\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason\n        ) from e\n\n    # Return the decoded string and the length of input bytes consumed (all of them)\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    try:\n        text = data.decode('utf-8', errors=str(errors))\n        decoded = convert_escaped_utf8_literal(text)\n        return decoded, len(data)\n    except UnicodeDecodeError as e:\n        raise e\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()"]}
{"task_id": 142, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "from typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "from typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "from typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n"]}
{"task_id": 143, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            value = getattr(obj, attr)\n            if callable(value):\n                return True\n    return False", "from typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\n        True\n    \"\"\"\n    for attr in attrs:\n        attr_val = getattr(obj, attr, None)\n        if callable(attr_val):\n            return True\n    return False", "from typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            attr_val = getattr(obj, attr)\n            if callable(attr_val):\n                return True\n    return False", "from typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            attr_val = getattr(obj, attr)\n            if callable(attr_val):\n                return True\n    return False", "from typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            value = getattr(obj, attr)\n            if callable(value):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\n        True\n    \"\"\"\n    for attr in attrs:\n        attr_val = getattr(obj, attr, None)\n        if callable(attr_val):\n            return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            attr_val = getattr(obj, attr)\n            if callable(attr_val):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            attr_val = getattr(obj, attr)\n            if callable(attr_val):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n"]}
{"task_id": 144, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    if obj is None:\n        return False\n    if isinstance(obj, (bool, bytes, str)):\n        return False\n\n    # Check if obj is instance of accepted list-like types\n    if isinstance(obj, (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        KeysView,\n        ValuesView,\n        UserList,\n    )):\n        return True\n\n    # For any other type, return True if it is iterable but NOT a dict subclass\n    # We exclude dict and other mapping types dynamically to cover stated exclusions.\n    try:\n        # Check if object is iterable\n        iter(obj)\n    except TypeError:\n        return False\n\n    # Exclude dictionary-like types explicitly by checking against collections.abc.Mapping\n    from collections.abc import Mapping\n\n    if isinstance(obj, Mapping):\n        return False\n\n    # Exclude all other explicitly mentioned non-list-like types by checking their classes\n    # We cover types like ChainMap, Counter, OrderedDict, UserDict, UserString, defaultdict, Decimal, float, int.\n\n    # We import these here to avoid import overhead if not needed.\n    import collections\n    import decimal\n\n    if isinstance(obj, (\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        decimal.Decimal,\n        float,\n        int,\n    )):\n        return False\n\n    # If it passed all these exclusion cases and is iterable, consider list-like\n    return True", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    if obj is None:\n        return False\n\n    # Exclude explicit non-list-like types\n    if isinstance(obj, (bool, bytes, bytearray, memoryview, str, dict, float, int)):\n        return False\n\n    # Check if instance of any of the recognized list-like classes\n    if isinstance(obj, _LIST_LIKE):\n        return True\n\n    # Some objects may behave like lists (iterable + __getitem__) but not in _LIST_LIKE\n    # We can try to check for __iter__ and __getitem__ attributes as heuristic\n\n    # But to keep implementation consistent with docstring and avoid false positives,\n    # only types in _LIST_LIKE are considered list-like.\n\n    return False", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Explicitly exclude types that look iterable but are not list-like\n    exclude_types = (\n        type(None),\n        bool,\n        bytes,\n        dict,\n        float,\n        int,\n        str,\n    )\n\n    # Also exclude collections types that are not considered list-like here\n    # but are not imported in this file: ChainMap, Counter, OrderedDict,\n    # UserDict, UserString, defaultdict, Decimal\n    # We exclude them by type name and module to avoid imports.\n\n    # To cover those, exclude by type name and module:\n    exclude_type_names_and_modules = {\n        ('ChainMap', 'collections'),\n        ('Counter', 'collections'),\n        ('OrderedDict', 'collections'),\n        ('UserDict', 'collections'),\n        ('UserString', 'collections'),\n        ('defaultdict', 'collections'),\n        ('Decimal', 'decimal'),\n    }\n\n    obj_type = type(obj)\n\n    # Exclude built-in types as above\n    if obj_type in exclude_types:\n        return False\n\n    # Exclude by name and module\n    if (obj_type.__name__, obj_type.__module__) in exclude_type_names_and_modules:\n        return False\n\n    # Check if obj is instance of any _LIST_LIKE classes\n    if isinstance(obj, _LIST_LIKE):\n        return True\n\n    # Additional check: some iterable that is not instance of above,\n    # but behaves like a list, e.g. other iterable types.\n    # According to docstring example, sorted('hello') returns list (True).\n    # So we should only accept those that are iterable and not excluded types.\n\n    # Check if object is iterable and not a string/bytes/etc.\n    # But strings and bytes excluded above.\n\n    # Check for __iter__ attribute presence and callable\n    if hasattr(obj, '__iter__') and callable(getattr(obj, '__iter__')):\n        # Further exclude mapping types (dict-like)\n        # Check if obj has 'keys' attribute (only mappings have keys)\n        if hasattr(obj, 'keys'):\n            # Most mapping types have keys() callable\n            return False\n        return True\n\n    return False", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Reject None, bool, bytes, str explicitly (common but not list-like)\n    if obj is None:\n        return False\n    if isinstance(obj, (bool, bytes, str)):\n        return False\n\n    # Check if instance of any listed list-like types\n    if isinstance(obj, _LIST_LIKE):\n        return True\n\n    # Some built-in collections types are explicitly not list-like\n    # We avoid importing those types as per instruction, so we do\n    # an approximate check for dict-like types:\n    # If it is dict or dict subclass -> not list-like\n    # Also exclude other common mapping types by checking for typical mapping attributes.\n\n    # Quick check for dict and dict-like (has 'keys' and 'items' callable)\n    # but we want to exclude dict derived, so if it has all these attributes and is subclass of dict, exclude\n    try:\n        if isinstance(obj, dict):\n            return False\n    except Exception:\n        # Defensive catch if isinstance fails for some reason (unlikely)\n        pass\n\n    # Finally, as a fallback, check if object is iterable (has __iter__ method) but is not a string or bytes (already checked above)\n    # This covers some custom iterable types which may not be instances of _LIST_LIKE but behave list-like.\n    if hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes)):\n        return True\n\n    return False", "from typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    _list_like = (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        ValuesView,\n        KeysView,\n        UserList,\n    )\n\n    # Explicitly reject types that are considered NOT list-like\n    # None, bool, bytes, dict, float, int, str, and some known collections\n    # Because importing those classes would violate the instruction, \n    # testing by type directly on known types/custom types is enough.\n\n    # Reject None\n    if obj is None:\n        return False\n\n    # Reject bool and bytes explicitly\n    if isinstance(obj, (bool, bytes)):\n        return False\n\n    # Reject str explicitly\n    if isinstance(obj, str):\n        return False\n\n    # Reject float and int explicitly\n    if isinstance(obj, (int, float)):\n        return False\n\n    # Reject dict explicitly\n    if isinstance(obj, dict):\n        return False\n\n    # Check if obj is instance of any of the list-like classes\n    if isinstance(obj, _list_like):\n        return True\n\n    # As a fallback: check if it's iterable with __iter__ method and not excluded types\n    # The docstring shows sorted('hello') -> True, so also list-likes like returned from sorted()\n    # are instances of list so they pass first check.\n\n    # If it has __iter__ but excluded types filtered above, then True\n\n    if hasattr(obj, '__iter__'):\n        return True\n\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    if obj is None:\n        return False\n    if isinstance(obj, (bool, bytes, str)):\n        return False\n\n    # Check if obj is instance of accepted list-like types\n    if isinstance(obj, (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        KeysView,\n        ValuesView,\n        UserList,\n    )):\n        return True\n\n    # For any other type, return True if it is iterable but NOT a dict subclass\n    # We exclude dict and other mapping types dynamically to cover stated exclusions.\n    try:\n        # Check if object is iterable\n        iter(obj)\n    except TypeError:\n        return False\n\n    # Exclude dictionary-like types explicitly by checking against collections.abc.Mapping\n    from collections.abc import Mapping\n\n    if isinstance(obj, Mapping):\n        return False\n\n    # Exclude all other explicitly mentioned non-list-like types by checking their classes\n    # We cover types like ChainMap, Counter, OrderedDict, UserDict, UserString, defaultdict, Decimal, float, int.\n\n    # We import these here to avoid import overhead if not needed.\n    import collections\n    import decimal\n\n    if isinstance(obj, (\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        decimal.Decimal,\n        float,\n        int,\n    )):\n        return False\n\n    # If it passed all these exclusion cases and is iterable, consider list-like\n    return True\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    if obj is None:\n        return False\n\n    # Exclude explicit non-list-like types\n    if isinstance(obj, (bool, bytes, bytearray, memoryview, str, dict, float, int)):\n        return False\n\n    # Check if instance of any of the recognized list-like classes\n    if isinstance(obj, _LIST_LIKE):\n        return True\n\n    # Some objects may behave like lists (iterable + __getitem__) but not in _LIST_LIKE\n    # We can try to check for __iter__ and __getitem__ attributes as heuristic\n\n    # But to keep implementation consistent with docstring and avoid false positives,\n    # only types in _LIST_LIKE are considered list-like.\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Explicitly exclude types that look iterable but are not list-like\n    exclude_types = (\n        type(None),\n        bool,\n        bytes,\n        dict,\n        float,\n        int,\n        str,\n    )\n\n    # Also exclude collections types that are not considered list-like here\n    # but are not imported in this file: ChainMap, Counter, OrderedDict,\n    # UserDict, UserString, defaultdict, Decimal\n    # We exclude them by type name and module to avoid imports.\n\n    # To cover those, exclude by type name and module:\n    exclude_type_names_and_modules = {\n        ('ChainMap', 'collections'),\n        ('Counter', 'collections'),\n        ('OrderedDict', 'collections'),\n        ('UserDict', 'collections'),\n        ('UserString', 'collections'),\n        ('defaultdict', 'collections'),\n        ('Decimal', 'decimal'),\n    }\n\n    obj_type = type(obj)\n\n    # Exclude built-in types as above\n    if obj_type in exclude_types:\n        return False\n\n    # Exclude by name and module\n    if (obj_type.__name__, obj_type.__module__) in exclude_type_names_and_modules:\n        return False\n\n    # Check if obj is instance of any _LIST_LIKE classes\n    if isinstance(obj, _LIST_LIKE):\n        return True\n\n    # Additional check: some iterable that is not instance of above,\n    # but behaves like a list, e.g. other iterable types.\n    # According to docstring example, sorted('hello') returns list (True).\n    # So we should only accept those that are iterable and not excluded types.\n\n    # Check if object is iterable and not a string/bytes/etc.\n    # But strings and bytes excluded above.\n\n    # Check for __iter__ attribute presence and callable\n    if hasattr(obj, '__iter__') and callable(getattr(obj, '__iter__')):\n        # Further exclude mapping types (dict-like)\n        # Check if obj has 'keys' attribute (only mappings have keys)\n        if hasattr(obj, 'keys'):\n            # Most mapping types have keys() callable\n            return False\n        return True\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Reject None, bool, bytes, str explicitly (common but not list-like)\n    if obj is None:\n        return False\n    if isinstance(obj, (bool, bytes, str)):\n        return False\n\n    # Check if instance of any listed list-like types\n    if isinstance(obj, _LIST_LIKE):\n        return True\n\n    # Some built-in collections types are explicitly not list-like\n    # We avoid importing those types as per instruction, so we do\n    # an approximate check for dict-like types:\n    # If it is dict or dict subclass -> not list-like\n    # Also exclude other common mapping types by checking for typical mapping attributes.\n\n    # Quick check for dict and dict-like (has 'keys' and 'items' callable)\n    # but we want to exclude dict derived, so if it has all these attributes and is subclass of dict, exclude\n    try:\n        if isinstance(obj, dict):\n            return False\n    except Exception:\n        # Defensive catch if isinstance fails for some reason (unlikely)\n        pass\n\n    # Finally, as a fallback, check if object is iterable (has __iter__ method) but is not a string or bytes (already checked above)\n    # This covers some custom iterable types which may not be instances of _LIST_LIKE but behave list-like.\n    if hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes)):\n        return True\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    _list_like = (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        ValuesView,\n        KeysView,\n        UserList,\n    )\n\n    # Explicitly reject types that are considered NOT list-like\n    # None, bool, bytes, dict, float, int, str, and some known collections\n    # Because importing those classes would violate the instruction, \n    # testing by type directly on known types/custom types is enough.\n\n    # Reject None\n    if obj is None:\n        return False\n\n    # Reject bool and bytes explicitly\n    if isinstance(obj, (bool, bytes)):\n        return False\n\n    # Reject str explicitly\n    if isinstance(obj, str):\n        return False\n\n    # Reject float and int explicitly\n    if isinstance(obj, (int, float)):\n        return False\n\n    # Reject dict explicitly\n    if isinstance(obj, dict):\n        return False\n\n    # Check if obj is instance of any of the list-like classes\n    if isinstance(obj, _list_like):\n        return True\n\n    # As a fallback: check if it's iterable with __iter__ method and not excluded types\n    # The docstring shows sorted('hello') -> True, so also list-likes like returned from sorted()\n    # are instances of list so they pass first check.\n\n    # If it has __iter__ but excluded types filtered above, then True\n\n    if hasattr(obj, '__iter__'):\n        return True\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n"]}
{"task_id": 145, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from typing import Any\n\n\ndef is_subclass_of_any(obj: Any, *classes: Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(), ValuesView, KeysView, UserList)\n        True\n    \"\"\"\n    try:\n        obj_cls = obj if isinstance(obj, type) else type(obj)\n        for cls in classes:\n            # Only consider valid classes/types\n            if isinstance(cls, type) and issubclass(obj_cls, cls):\n                return True\n    except TypeError:\n        # If obj_cls or cls is not a class/type, or issubclass fails, return False\n        return False\n    return False", "from typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        obj_type = obj if isinstance(obj, type) else type(obj)\n        for cls in classes:\n            if isinstance(cls, type) and issubclass(obj_type, cls):\n                return True\n        return False\n    except TypeError:\n        # Some inputs to issubclass may not be class types, just return False in that case\n        return False", "def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    if not classes:\n        return False\n\n    # Use isinstance to check if obj is instance of any provided class.\n    return any(isinstance(obj, cls) for cls in classes)", "from typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    try:\n        return any(isinstance(obj, cls) for cls in classes)\n    except TypeError:\n        # If any of the elements in classes is not a class/type, isinstance will raise TypeError\n        return False", "from typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    # Defensive: if no classes given, return False immediately\n    if not classes:\n        return False\n\n    try:\n        obj_type = obj if isinstance(obj, type) else type(obj)\n    except Exception:\n        # If type() fails for any reason, return False\n        return False\n\n    for cls in classes:\n        # Defensive: skip if cls is not a class/type\n        # Using isinstance(cls, type) ensures cls is a class/type\n        if not isinstance(cls, type):\n            continue\n        try:\n            if issubclass(obj_type, cls):\n                return True\n        except TypeError:\n            # If obj_type or cls is not a class, issubclass raises TypeError\n            # We'll ignore and continue\n            continue\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any\n\n\ndef is_subclass_of_any(obj: Any, *classes: Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(), ValuesView, KeysView, UserList)\n        True\n    \"\"\"\n    try:\n        obj_cls = obj if isinstance(obj, type) else type(obj)\n        for cls in classes:\n            # Only consider valid classes/types\n            if isinstance(cls, type) and issubclass(obj_cls, cls):\n                return True\n    except TypeError:\n        # If obj_cls or cls is not a class/type, or issubclass fails, return False\n        return False\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        obj_type = obj if isinstance(obj, type) else type(obj)\n        for cls in classes:\n            if isinstance(cls, type) and issubclass(obj_type, cls):\n                return True\n        return False\n    except TypeError:\n        # Some inputs to issubclass may not be class types, just return False in that case\n        return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    if not classes:\n        return False\n\n    # Use isinstance to check if obj is instance of any provided class.\n    return any(isinstance(obj, cls) for cls in classes)\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    try:\n        return any(isinstance(obj, cls) for cls in classes)\n    except TypeError:\n        # If any of the elements in classes is not a class/type, isinstance will raise TypeError\n        return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    # Defensive: if no classes given, return False immediately\n    if not classes:\n        return False\n\n    try:\n        obj_type = obj if isinstance(obj, type) else type(obj)\n    except Exception:\n        # If type() fails for any reason, return False\n        return False\n\n    for cls in classes:\n        # Defensive: skip if cls is not a class/type\n        # Using isinstance(cls, type) ensures cls is a class/type\n        if not isinstance(cls, type):\n            continue\n        try:\n            if issubclass(obj_type, cls):\n                return True\n        except TypeError:\n            # If obj_type or cls is not a class, issubclass raises TypeError\n            # We'll ignore and continue\n            continue\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n"]}
