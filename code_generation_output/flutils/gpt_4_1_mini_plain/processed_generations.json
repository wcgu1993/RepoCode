{"task_id": 125, "project": "test-apps/flutils", "module": "flutils.packages", "predictions": ["def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    # Validate pre_release value\n    valid_pre_releases = {'a', 'alpha', 'b', 'beta', None}\n    if pre_release is not None and pre_release.lower() not in valid_pre_releases:\n        raise ValueError(\"Invalid pre_release value. Must be one of 'a', 'alpha', 'b', 'beta'.\")\n\n    pre_release = pre_release.lower() if pre_release else None\n    if pre_release == 'alpha':\n        pre_release = 'a'\n    elif pre_release == 'beta':\n        pre_release = 'b'\n\n    # Regex to parse the version: groups numeric parts and optional pre-release part\n    # Eg: 1.2.4a0  --> parts = ['1','2','4'], pre='a', pre_num='0'\n    # Eg: 1.2b0    --> parts = ['1','2'], pre='b', pre_num='0'\n    # Eg: 2.0      --> parts = ['2','0'], no pre\n    version_re = re.compile(\n        r\"^(\\d+(?:\\.\\d+)*)(?:([ab])(\\d+))?$\", re.IGNORECASE\n    )\n    m = version_re.match(version)\n    if not m:\n        raise ValueError(f\"Invalid version string: {version}\")\n\n    base_version_str = m.group(1)\n    pre = m.group(2)\n    pre_num = m.group(3)\n\n    # Split version parts into int list\n    parts_str = base_version_str.split('.')\n    try:\n        parts = [int(p) for p in parts_str]\n    except ValueError:\n        raise ValueError(\"Invalid version number components.\")\n\n    if position < 0 or position > len(parts):\n        raise ValueError(f\"Position {position} does not exist for version parts {parts}.\")\n\n    # If position equals length of parts, we will append new component 0 before increment\n    # but only if position is not 0, since position=0 must exist to increment major.\n    if position == len(parts):\n        parts.append(0)\n\n    # Remove pre-release if present and no pre_release argument exists\n    if pre_release is None and pre is not None:\n        # Remove pre-release by dropping pre and pre_num\n        pre = None\n        pre_num = None\n\n    # Handle pre-release bump\n    if pre_release is not None:\n        # If position==0 (major) and pre-release is requested: error\n        if position == 0:\n            raise ValueError(\"Cannot set a pre-release on the major part of version.\")\n\n        # If position is greater than current length of parts, append zeros as needed\n        if position > len(parts) - 1:\n            # Append zeros to reach length position+1\n            parts += [0] * (position - len(parts) + 1)\n\n        # If original pre-release exists\n        if pre is not None:\n            # If pre is same as pre_release, increment pre_num\n            if pre == pre_release:\n                pre_num = str(int(pre_num) + 1)\n            else:\n                # Different pre-release letter requested, reset pre_num to 0\n                pre = pre_release\n                pre_num = '0'\n            # Base version remains same, no numeric bump\n        else:\n            # No pre-release originally, bump numeric version part at position\n            parts[position] += 1\n            # Truncate parts after position\n            parts = parts[:position+1]\n            pre = pre_release\n            pre_num = '0'\n\n        # Build version string with pre-release\n        version_str = '.'.join(str(p) for p in parts)\n        # Remove trailing zero components if any beyond position 0\n        # But only if position is 0 or 1, generally versioning is at least two levels\n        # So removing trailing zeros only if position < len(parts)-1\n        # Actually, examples keep zeros except for major bump.\n        # So do not remove trailing zeros extra here, just keep as is.\n        return f\"{version_str}{pre}{pre_num}\"\n\n    # No pre_release argument: bump normal version number (numeric parts), removing pre_release if exists\n    else:\n        # Bumping numeric version at position\n        parts[position] += 1\n        # truncate parts after position\n        parts = parts[:position+1]\n\n        # Remove pre-release if any\n        pre = None\n        pre_num = None\n\n        # On bumping major (position=0), reset minor to 0 if it exists (if len(parts)>1)\n        if position == 0:\n            if len(parts) > 1:\n                # Ensure we have at least two parts: major.minor\n                if len(parts) == 1:\n                    parts.append(0)\n                else:\n                    parts[1] = 0\n                # truncate after minor (position 1)\n                parts = parts[:2]\n        else:\n            # For non major bumps, truncation after bumped position done already\n            pass\n\n        version_str = '.'.join(str(p) for p in parts)\n        return version_str", "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    if pre_release is not None:\n        pre_release = pre_release.lower()\n        if pre_release in ('a', 'alpha'):\n            pre_release = 'a'\n        elif pre_release in ('b', 'beta'):\n            pre_release = 'b'\n        else:\n            raise ValueError(\"Invalid pre_release value: must be one of 'a', 'alpha', 'b', 'beta'\")\n\n    # Regex to capture components:\n    # groups = numbers separated by dots, with optional trailing pre_release part in the last component if any\n    # For example: '1.2.4a0' => major=1, minor=2, patch=4, prerel='a', prerel_num=0\n    ver_re = re.compile(r'^(\\d+(?:\\.\\d+)*)([ab](\\d+))?$')\n    m = ver_re.match(version)\n    if not m:\n        raise ValueError(\"Invalid version string\")\n\n    # Split main version components by dot\n    main_ver = m.group(1)\n    main_parts = [int(x) for x in main_ver.split('.')]\n    prerel = ''\n    prerel_num = None\n    if m.group(2):\n        prerel = m.group(2)[0]  # 'a' or 'b'\n        prerel_num = int(m.group(3))\n\n    # Validate position\n    if position >= len(main_parts):\n        if position == 2:\n            # As per examples, position=2 (patch) may be missing, treat as 0 and append\n            while len(main_parts) < 3:\n                main_parts.append(0)\n        else:\n            raise ValueError(f\"Position {position} does not exist in version '{version}'\")\n\n    # If pre_release given, ensure position != 0 (cannot bump major if pre-release is requested)\n    if pre_release is not None and position == 0:\n        raise ValueError(\"Cannot bump major version with a pre-release\")\n\n    # If pre_release is None and current version has a pre-release, remove the pre-release part (bump removes prerelease)\n    if pre_release is None and prerel != '':\n        prerel = ''\n        prerel_num = None\n\n    # Bump version number at the chosen position\n    # First, reset all parts after position (truncate)\n    main_parts = main_parts[:position+1]\n    main_parts[position] += 1\n\n    # Reset all parts after position to zero - based on examples:\n    # * bumping position=0 resets position=1 to zero, and removes position=2 if any (see example '1.3.4',position=0 -> '2.0')\n    # * bumping position=1 seems to leave no patch for '1.2.3', position=1 => '1.3' (patch dropped)\n    # So we truncate parts list at position+1 and do not add zeros beyond it, so length of main_parts = position +1\n    # So any parts after position dropped (will not add zeros beyond)\n\n    # If position < len(main_parts)-1, drop trailing parts already done by slice [:position+1]\n\n    # Now handle pre-release bumping\n    if pre_release is not None:\n        # pre-release bump requested\n        # If current pre-release exists on that component, check what to do:\n        if prerel == pre_release:\n            # same pre-release, bump number\n            if prerel_num is None:\n                prerel_num = 0\n            else:\n                prerel_num += 1\n        else:\n            # different or no current pre-release, set pre-release number to 0\n            prerel_num = 0\n        prerel = pre_release\n    else:\n        # no pre_release requested ->\n        # if previous pre-release existed, remove it already done above\n\n        # per example:\n        # '1.2.4a1' with no pre_release param => '1.2.4'\n        # so prerel cleared above\n\n        prerel = ''\n        prerel_num = None\n\n    # Convert main_parts back to string\n    main_str = '.'.join(str(x) for x in main_parts)\n\n    # Compose final version string\n    if prerel != '':\n        return f\"{main_str}{prerel}{prerel_num}\"\n    else:\n        return main_str", "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n\n    import re\n    from typing import Optional\n\n    # Validate and normalize pre_release\n    if pre_release is not None:\n        pre_release_map = {'a': 'a', 'alpha': 'a', 'b': 'b', 'beta': 'b'}\n        if pre_release.lower() not in pre_release_map:\n            raise ValueError(\"Invalid pre_release value, must be one of 'a', 'alpha', 'b', 'beta'\")\n        pre_release = pre_release_map[pre_release.lower()]\n\n    # Regular expression to parse version parts and optional pre-release\n    # Matches components separated by '.' where last component may have pre-release suffix\n    version_pattern = re.compile(\n        r'^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+)([ab]\\d+)?)?$|^(\\d+)([ab]\\d+)?$'\n    )\n\n    # Alternative approach: parse version number into parts and extract pre-release info from last part\n    # Because versions can be '1.2.4a0' or '1.2b0' or '1.2.3' etc.\n\n    # We will parse version by splitting on '.' then parsing last part.\n    parts = version.split('.')\n    if not parts:\n        raise ValueError(\"Invalid version string\")\n\n    parsed_parts = []\n    prerelease_str = None\n\n    def split_num_pre(s):\n        # Split numeric part from possible pre-release suffix on last component\n        m = re.match(r'^(\\d+)([ab]\\d+)?$', s)\n        if not m:\n            raise ValueError(f\"Invalid version component: {s}\")\n        return int(m.group(1)), m.group(2)\n\n    for i, part in enumerate(parts):\n        # Only last part can have pre-release suffix\n        if i == len(parts) - 1:\n            num, pr = split_num_pre(part)\n            parsed_parts.append(num)\n            prerelease_str = pr\n        else:\n            if not part.isdigit():\n                raise ValueError(f\"Invalid version component: {part}\")\n            parsed_parts.append(int(part))\n\n    # If pre_release is None and input version has prerelease suffix,\n    # by bumping the version without pre_release argument, we remove prerelease.\n    if pre_release is None and prerelease_str is not None:\n        # Remove prerelease suffix from version, return version with numeric parts only.\n        # According to example: bump_version('1.2.4a1') => '1.2.4'\n        prerelease_str = None\n        # Version string will be reassembled below.\n\n    # Validate position\n    if position < 0:\n        raise ValueError(f\"Invalid position: {position}\")\n    # Extend parsed_parts with zeros up to position if needed\n    while len(parsed_parts) <= position:\n        parsed_parts.append(0)\n\n    # If pre_release is not None and position == 0, raise ValueError\n    if pre_release is not None and position == 0:\n        raise ValueError(\"Cannot assign pre-release version to major version part\")\n\n    # Handle version bumping\n    # When bumping position, set lower positions to zero\n\n    # Before bump:\n    # If pre_release is None:\n    #   increment parts[position] by 1\n    #   zero out all positions after position\n    #   strip prerelease suffix\n    # If pre_release is not None:\n    #   if prerelease_str exists and of different type than requested pre_release:\n    #       replace pre_release suffix with requested one and start at 0\n    #   else if prerelease_str exists and same type as requested pre_release:\n    #       increase pre_release number by 1\n    #   else no prerelease_str:\n    #       bump parts[position] (if position outside parts, extend) and set pre_release count to 0\n\n    if pre_release is None:\n        # normal bump, increment and remove pre-release\n        parsed_parts[position] += 1\n        # zero out all lower positions after bump position\n        for idx in range(position + 1, len(parsed_parts)):\n            parsed_parts[idx] = 0\n        prerelease_str = None\n    else:\n        # pre_release bump\n        # If pre_release given, and position exists, bump that part only (but no major)\n        # position 0 is forbidden above\n\n        # if prerelease_str is present:\n        # extract pre_release type and number\n        if prerelease_str:\n            m = re.match(r'^([ab])(\\d+)$', prerelease_str)\n            if not m:\n                raise ValueError(f\"Invalid pre-release suffix in version: {prerelease_str}\")\n            cur_pre_type = m.group(1)\n            cur_pre_num = int(m.group(2))\n\n            if cur_pre_type != pre_release:\n                # Different type requested: reset pre_release number to 0, leave version number unchanged\n                # So no bump of version number part, just change pre-release.\n                prerelease_str = f\"{pre_release}0\"\n            else:\n                # Same pre_release type: increment number by 1\n                prerelease_str = f\"{pre_release}{cur_pre_num + 1}\"\n        else:\n            # No existing pre-release, bump position and add pre_release 0 suffix\n            # position might be beyond current length, extend\n            if len(parsed_parts) <= position:\n                while len(parsed_parts) <= position:\n                    parsed_parts.append(0)\n            parsed_parts[position] += 1\n            for idx in range(position + 1, len(parsed_parts)):\n                parsed_parts[idx] = 0\n            prerelease_str = f\"{pre_release}0\"\n\n    # Now assemble the version string\n    # Per examples, if position=0 (major) bumped, output only major.minor (i.e. 2 parts).\n    # If position=1 bumped, output two parts.\n    # If position=2 bumped, output 3 parts.\n    # But if position beyond length, output all parts.\n\n    # Also, if position==0 (major) bumped, example shows output two components '2.0'\n\n    # We'll output parts up to max(position+1, 2)\n    min_parts_len = 2 if position == 0 else (position + 1)\n    output_parts = parsed_parts[:min_parts_len]\n\n    # Remove trailing zeros from minor and patch unless position==0\n    if position != 0:\n        # remove trailing zeros from the right\n        while len(output_parts) > 1 and output_parts[-1] == 0:\n            output_parts.pop()\n\n    ver_str = '.'.join(str(p) for p in output_parts)\n    if prerelease_str:\n        ver_str += prerelease_str\n    return ver_str", "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    # Validate pre_release\n    if pre_release is not None:\n        pre_release_lower = pre_release.lower()\n        if pre_release_lower in ('a', 'alpha'):\n            pre_type = 'a'\n        elif pre_release_lower in ('b', 'beta'):\n            pre_type = 'b'\n        else:\n            raise ValueError(\"pre_release must be one of 'a', 'alpha', 'b', 'beta'\")\n\n    # Pattern to parse version components and optional pre-release suffix\n    # Examples matched:\n    #  - \"1.2.3\", \"1.2.4a0\", \"1.2.4b0\", \"1.2b0\"\n    # Returns groups: full version, main version part, optional pre-release letter and number\n    regex = re.compile(r'^(\\d+(?:\\.\\d+)*)(?:(a|b)(\\d+))?$')\n    m = regex.match(version)\n    if not m:\n        raise ValueError(\"Invalid version string format\")\n\n    main_version_str = m.group(1)\n    existing_pre_type = m.group(2)\n    existing_pre_num_str = m.group(3)\n\n    components_str = main_version_str.split('.')\n    # Convert components to ints\n    try:\n        components = [int(c) for c in components_str]\n    except Exception as e:\n        raise ValueError(\"Invalid integer in version components\") from e\n\n    # Validate position\n    if position < 0:\n        raise ValueError(\"position cannot be negative\")\n    if position > len(components):\n        # position cannot exceed len(components)\n        raise ValueError(\"position does not exist in the version components\")\n\n    # If position equals length of components, we consider this as bumping a new component starting from 0\n    # But problem examples only bump existing or one extra? So be strict and expect position <= length components.\n    # So position == len(components) is invalid because you can't bump a component that doesn't exist.\n    if position == len(components):\n        raise ValueError(\"position does not exist in the version components\")\n\n    # Remove pre-release if pre_release is None (strip pre-release suffix)\n    if pre_release is None:\n        # If there's pre-release suffix in the current version, just remove it\n        # Return main version only\n        # But according to example '1.2.4a1' -> '1.2.4'\n        # '1.2.4b0' -> '1.2.4'\n        # So remove pre-release suffix by returning just the main version string\n        # But consider the position bumping: if position is specified, do bump first then remove pre-release\n        # From examples, if pre_release is None and position is given, then bump numeric component and remove pre-release if any.\n        # So bump first\n        # Remove pre-release after bump\n        pass\n\n    # If pre_release is set and position==0 (major) raise ValueError\n    if pre_release is not None and position == 0:\n        raise ValueError(\"Cannot create a pre-release version for the major position.\")\n\n    # Bump main version component at position\n    # Increase version component at position by 1\n    components[position] += 1\n    # All components after position should be removed (cut off) according to examples\n    # Because for example:\n    # '1.2.3', position=1 -> '1.3'  (components: [1,2,3], pos=1 -> bump 2->3 and remove 3rd component)\n    components = components[:position + 1]\n\n    # When bumping - pre-release suffix currently not considered in examples - only at the end\n    # Now manage pre-release suffix depending on pre_release argument\n\n    # Cases:\n\n    # 1) If pre_release is None: remove any existing pre-release suffix\n    if pre_release is None:\n        # no pre-release suffix\n        result_version = \".\".join(str(c) for c in components)\n\n    else:\n        # pre_release specified: 'a' or 'b'\n        # Need to check if main version changed or not\n        # In examples, bumping pre-release if existing and same type increments its num\n        # if pre-release type changes, start at num 0\n\n        # The pre-release is applied to the last component bumped: e.g. '1.2.4a0'\n        # So basically pre-release suffix appended to the last number component (no dot)\n\n        # Check if existing pre-release type matches requested pre_release\n        if existing_pre_type == pre_type and len(components) == len(components_str):\n            # Same pre-release type exists on this exact main version\n            # increment pre-release number\n            new_pre_num = int(existing_pre_num_str) + 1 if existing_pre_num_str is not None else 0\n        else:\n            # pre-release type changed or new pre-release, start from 0\n            new_pre_num = 0\n\n        result_version = \".\".join(str(c) for c in components) + pre_type + str(new_pre_num)\n\n    return result_version", "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    # Validate pre_release argument\n    if pre_release is not None:\n        pre_release_lower = pre_release.lower()\n        if pre_release_lower in (\"a\", \"alpha\"):\n            pre_release = \"a\"\n        elif pre_release_lower in (\"b\", \"beta\"):\n            pre_release = \"b\"\n        else:\n            raise ValueError(\n                \"Invalid pre_release value. Must be 'a', 'alpha', 'b', or 'beta'\"\n            )\n    else:\n        pre_release = None\n\n    # Match version pattern: major.minor.patch + optional pre_release & number\n    # Examples: '1.2.3', '1.2.3a0', '1.2b1', '1.2.3b0'\n    # Pattern: ^(\\d+(?:\\.\\d+)*)([ab])?(\\d+)?$\n    pattern = r\"^(\\d+(?:\\.\\d+)*)([ab])?(\\d+)?$\"\n    m = re.match(pattern, version)\n    if not m:\n        raise ValueError(f\"Invalid version number: {version}\")\n    number_part, current_pre, pre_num = m.groups()\n\n    components = number_part.split(\".\")\n    components = [int(c) for c in components]\n    length = len(components)\n\n    # Validate position\n    if position < 0:\n        raise ValueError(\"Position must be zero or positive integer\")\n    # If position >= length, append zero components to reach position? No, based on example:\n    # bump_version('1.2b0', position=2) => '1.2.1' means add component if missing at position\n    if position >= length:\n        # pad with zeros\n        components.extend([0] * (position - length + 1))\n\n    # Function to strip pre-release from version string\n    def remove_pre_release(components_list):\n        return \".\".join(str(x) for x in components_list)\n\n    # 1) If pre_release is None and current version has pre-release, then remove it and return version with same components (do not bump)\n    if pre_release is None and current_pre is not None:\n        # remove pre-release from version string\n        return remove_pre_release(components)\n\n    # 2) If pre_release is given:\n    # - If position == 0 and pre_release is specified, raise error (cannot add prerelease to major version bump)\n    if pre_release is not None and position == 0:\n        raise ValueError(\n            \"Cannot set pre-release on 'major' version component (position 0)\"\n        )\n\n    # 3) Bump version:\n    # - Increment the component at 'position' by 1\n    # - Truncate all components after position\n    components = components[: position + 1]\n    components[position] += 1\n    # Any components after position are removed (as per examples)\n    # If bumping the major (pos 0), minor reset to 0, patch removed (see example '1.3.4' position=0 -> '2.0')\n    # So after truncation, add a zero for position=0 (major bump) for minor version\n\n    # Handle the minor component in case of position 0 bump\n    if position == 0:\n        # after incrementing major, add minor as 0\n        if len(components) == 1:\n            components.append(0)\n    else:\n        # position > 0, all after position truncated, which we already did\n        pass\n\n    # Compose version string before pre-release\n    base_version = \".\".join(str(c) for c in components)\n\n    # Handle pre_release logic:\n    # Pre-release is a suffix with letter + number (e.g. a0, b1)\n    # If pre_release is None and current_pre is None, just return base_version\n    # If pre_release is None and current_pre is present -> removed above already\n    # If pre_release is present:\n\n    # Conditions to detect if we should increase patch to add pre_release:\n    # - If position > len(components)-1 (should be impossible since we padded)\n    # - else if position > last component index, we padded; so the user wants to bump that position\n\n    if pre_release is not None:\n        # Determine current pre-release state\n        # Determine if the pre_release matches current pre_release, then increment pre_num\n        if current_pre == pre_release and pre_num is not None:\n            # increment pre_num\n            new_pre_num = int(pre_num) + 1\n            return f\"{base_version}{pre_release}{new_pre_num}\"\n        else:\n            # if current pre-release was different or none, reset pre_num to 0\n            return f\"{base_version}{pre_release}0\"\n\n    # No pre_release specified and no pre_release present in original version (already handled), just return base_version\n    return base_version"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    # Validate pre_release value\n    valid_pre_releases = {'a', 'alpha', 'b', 'beta', None}\n    if pre_release is not None and pre_release.lower() not in valid_pre_releases:\n        raise ValueError(\"Invalid pre_release value. Must be one of 'a', 'alpha', 'b', 'beta'.\")\n\n    pre_release = pre_release.lower() if pre_release else None\n    if pre_release == 'alpha':\n        pre_release = 'a'\n    elif pre_release == 'beta':\n        pre_release = 'b'\n\n    # Regex to parse the version: groups numeric parts and optional pre-release part\n    # Eg: 1.2.4a0  --> parts = ['1','2','4'], pre='a', pre_num='0'\n    # Eg: 1.2b0    --> parts = ['1','2'], pre='b', pre_num='0'\n    # Eg: 2.0      --> parts = ['2','0'], no pre\n    version_re = re.compile(\n        r\"^(\\d+(?:\\.\\d+)*)(?:([ab])(\\d+))?$\", re.IGNORECASE\n    )\n    m = version_re.match(version)\n    if not m:\n        raise ValueError(f\"Invalid version string: {version}\")\n\n    base_version_str = m.group(1)\n    pre = m.group(2)\n    pre_num = m.group(3)\n\n    # Split version parts into int list\n    parts_str = base_version_str.split('.')\n    try:\n        parts = [int(p) for p in parts_str]\n    except ValueError:\n        raise ValueError(\"Invalid version number components.\")\n\n    if position < 0 or position > len(parts):\n        raise ValueError(f\"Position {position} does not exist for version parts {parts}.\")\n\n    # If position equals length of parts, we will append new component 0 before increment\n    # but only if position is not 0, since position=0 must exist to increment major.\n    if position == len(parts):\n        parts.append(0)\n\n    # Remove pre-release if present and no pre_release argument exists\n    if pre_release is None and pre is not None:\n        # Remove pre-release by dropping pre and pre_num\n        pre = None\n        pre_num = None\n\n    # Handle pre-release bump\n    if pre_release is not None:\n        # If position==0 (major) and pre-release is requested: error\n        if position == 0:\n            raise ValueError(\"Cannot set a pre-release on the major part of version.\")\n\n        # If position is greater than current length of parts, append zeros as needed\n        if position > len(parts) - 1:\n            # Append zeros to reach length position+1\n            parts += [0] * (position - len(parts) + 1)\n\n        # If original pre-release exists\n        if pre is not None:\n            # If pre is same as pre_release, increment pre_num\n            if pre == pre_release:\n                pre_num = str(int(pre_num) + 1)\n            else:\n                # Different pre-release letter requested, reset pre_num to 0\n                pre = pre_release\n                pre_num = '0'\n            # Base version remains same, no numeric bump\n        else:\n            # No pre-release originally, bump numeric version part at position\n            parts[position] += 1\n            # Truncate parts after position\n            parts = parts[:position+1]\n            pre = pre_release\n            pre_num = '0'\n\n        # Build version string with pre-release\n        version_str = '.'.join(str(p) for p in parts)\n        # Remove trailing zero components if any beyond position 0\n        # But only if position is 0 or 1, generally versioning is at least two levels\n        # So removing trailing zeros only if position < len(parts)-1\n        # Actually, examples keep zeros except for major bump.\n        # So do not remove trailing zeros extra here, just keep as is.\n        return f\"{version_str}{pre}{pre_num}\"\n\n    # No pre_release argument: bump normal version number (numeric parts), removing pre_release if exists\n    else:\n        # Bumping numeric version at position\n        parts[position] += 1\n        # truncate parts after position\n        parts = parts[:position+1]\n\n        # Remove pre-release if any\n        pre = None\n        pre_num = None\n\n        # On bumping major (position=0), reset minor to 0 if it exists (if len(parts)>1)\n        if position == 0:\n            if len(parts) > 1:\n                # Ensure we have at least two parts: major.minor\n                if len(parts) == 1:\n                    parts.append(0)\n                else:\n                    parts[1] = 0\n                # truncate after minor (position 1)\n                parts = parts[:2]\n        else:\n            # For non major bumps, truncation after bumped position done already\n            pass\n\n        version_str = '.'.join(str(p) for p in parts)\n        return version_str\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    if pre_release is not None:\n        pre_release = pre_release.lower()\n        if pre_release in ('a', 'alpha'):\n            pre_release = 'a'\n        elif pre_release in ('b', 'beta'):\n            pre_release = 'b'\n        else:\n            raise ValueError(\"Invalid pre_release value: must be one of 'a', 'alpha', 'b', 'beta'\")\n\n    # Regex to capture components:\n    # groups = numbers separated by dots, with optional trailing pre_release part in the last component if any\n    # For example: '1.2.4a0' => major=1, minor=2, patch=4, prerel='a', prerel_num=0\n    ver_re = re.compile(r'^(\\d+(?:\\.\\d+)*)([ab](\\d+))?$')\n    m = ver_re.match(version)\n    if not m:\n        raise ValueError(\"Invalid version string\")\n\n    # Split main version components by dot\n    main_ver = m.group(1)\n    main_parts = [int(x) for x in main_ver.split('.')]\n    prerel = ''\n    prerel_num = None\n    if m.group(2):\n        prerel = m.group(2)[0]  # 'a' or 'b'\n        prerel_num = int(m.group(3))\n\n    # Validate position\n    if position >= len(main_parts):\n        if position == 2:\n            # As per examples, position=2 (patch) may be missing, treat as 0 and append\n            while len(main_parts) < 3:\n                main_parts.append(0)\n        else:\n            raise ValueError(f\"Position {position} does not exist in version '{version}'\")\n\n    # If pre_release given, ensure position != 0 (cannot bump major if pre-release is requested)\n    if pre_release is not None and position == 0:\n        raise ValueError(\"Cannot bump major version with a pre-release\")\n\n    # If pre_release is None and current version has a pre-release, remove the pre-release part (bump removes prerelease)\n    if pre_release is None and prerel != '':\n        prerel = ''\n        prerel_num = None\n\n    # Bump version number at the chosen position\n    # First, reset all parts after position (truncate)\n    main_parts = main_parts[:position+1]\n    main_parts[position] += 1\n\n    # Reset all parts after position to zero - based on examples:\n    # * bumping position=0 resets position=1 to zero, and removes position=2 if any (see example '1.3.4',position=0 -> '2.0')\n    # * bumping position=1 seems to leave no patch for '1.2.3', position=1 => '1.3' (patch dropped)\n    # So we truncate parts list at position+1 and do not add zeros beyond it, so length of main_parts = position +1\n    # So any parts after position dropped (will not add zeros beyond)\n\n    # If position < len(main_parts)-1, drop trailing parts already done by slice [:position+1]\n\n    # Now handle pre-release bumping\n    if pre_release is not None:\n        # pre-release bump requested\n        # If current pre-release exists on that component, check what to do:\n        if prerel == pre_release:\n            # same pre-release, bump number\n            if prerel_num is None:\n                prerel_num = 0\n            else:\n                prerel_num += 1\n        else:\n            # different or no current pre-release, set pre-release number to 0\n            prerel_num = 0\n        prerel = pre_release\n    else:\n        # no pre_release requested ->\n        # if previous pre-release existed, remove it already done above\n\n        # per example:\n        # '1.2.4a1' with no pre_release param => '1.2.4'\n        # so prerel cleared above\n\n        prerel = ''\n        prerel_num = None\n\n    # Convert main_parts back to string\n    main_str = '.'.join(str(x) for x in main_parts)\n\n    # Compose final version string\n    if prerel != '':\n        return f\"{main_str}{prerel}{prerel_num}\"\n    else:\n        return main_str\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n\n    import re\n    from typing import Optional\n\n    # Validate and normalize pre_release\n    if pre_release is not None:\n        pre_release_map = {'a': 'a', 'alpha': 'a', 'b': 'b', 'beta': 'b'}\n        if pre_release.lower() not in pre_release_map:\n            raise ValueError(\"Invalid pre_release value, must be one of 'a', 'alpha', 'b', 'beta'\")\n        pre_release = pre_release_map[pre_release.lower()]\n\n    # Regular expression to parse version parts and optional pre-release\n    # Matches components separated by '.' where last component may have pre-release suffix\n    version_pattern = re.compile(\n        r'^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+)([ab]\\d+)?)?$|^(\\d+)([ab]\\d+)?$'\n    )\n\n    # Alternative approach: parse version number into parts and extract pre-release info from last part\n    # Because versions can be '1.2.4a0' or '1.2b0' or '1.2.3' etc.\n\n    # We will parse version by splitting on '.' then parsing last part.\n    parts = version.split('.')\n    if not parts:\n        raise ValueError(\"Invalid version string\")\n\n    parsed_parts = []\n    prerelease_str = None\n\n    def split_num_pre(s):\n        # Split numeric part from possible pre-release suffix on last component\n        m = re.match(r'^(\\d+)([ab]\\d+)?$', s)\n        if not m:\n            raise ValueError(f\"Invalid version component: {s}\")\n        return int(m.group(1)), m.group(2)\n\n    for i, part in enumerate(parts):\n        # Only last part can have pre-release suffix\n        if i == len(parts) - 1:\n            num, pr = split_num_pre(part)\n            parsed_parts.append(num)\n            prerelease_str = pr\n        else:\n            if not part.isdigit():\n                raise ValueError(f\"Invalid version component: {part}\")\n            parsed_parts.append(int(part))\n\n    # If pre_release is None and input version has prerelease suffix,\n    # by bumping the version without pre_release argument, we remove prerelease.\n    if pre_release is None and prerelease_str is not None:\n        # Remove prerelease suffix from version, return version with numeric parts only.\n        # According to example: bump_version('1.2.4a1') => '1.2.4'\n        prerelease_str = None\n        # Version string will be reassembled below.\n\n    # Validate position\n    if position < 0:\n        raise ValueError(f\"Invalid position: {position}\")\n    # Extend parsed_parts with zeros up to position if needed\n    while len(parsed_parts) <= position:\n        parsed_parts.append(0)\n\n    # If pre_release is not None and position == 0, raise ValueError\n    if pre_release is not None and position == 0:\n        raise ValueError(\"Cannot assign pre-release version to major version part\")\n\n    # Handle version bumping\n    # When bumping position, set lower positions to zero\n\n    # Before bump:\n    # If pre_release is None:\n    #   increment parts[position] by 1\n    #   zero out all positions after position\n    #   strip prerelease suffix\n    # If pre_release is not None:\n    #   if prerelease_str exists and of different type than requested pre_release:\n    #       replace pre_release suffix with requested one and start at 0\n    #   else if prerelease_str exists and same type as requested pre_release:\n    #       increase pre_release number by 1\n    #   else no prerelease_str:\n    #       bump parts[position] (if position outside parts, extend) and set pre_release count to 0\n\n    if pre_release is None:\n        # normal bump, increment and remove pre-release\n        parsed_parts[position] += 1\n        # zero out all lower positions after bump position\n        for idx in range(position + 1, len(parsed_parts)):\n            parsed_parts[idx] = 0\n        prerelease_str = None\n    else:\n        # pre_release bump\n        # If pre_release given, and position exists, bump that part only (but no major)\n        # position 0 is forbidden above\n\n        # if prerelease_str is present:\n        # extract pre_release type and number\n        if prerelease_str:\n            m = re.match(r'^([ab])(\\d+)$', prerelease_str)\n            if not m:\n                raise ValueError(f\"Invalid pre-release suffix in version: {prerelease_str}\")\n            cur_pre_type = m.group(1)\n            cur_pre_num = int(m.group(2))\n\n            if cur_pre_type != pre_release:\n                # Different type requested: reset pre_release number to 0, leave version number unchanged\n                # So no bump of version number part, just change pre-release.\n                prerelease_str = f\"{pre_release}0\"\n            else:\n                # Same pre_release type: increment number by 1\n                prerelease_str = f\"{pre_release}{cur_pre_num + 1}\"\n        else:\n            # No existing pre-release, bump position and add pre_release 0 suffix\n            # position might be beyond current length, extend\n            if len(parsed_parts) <= position:\n                while len(parsed_parts) <= position:\n                    parsed_parts.append(0)\n            parsed_parts[position] += 1\n            for idx in range(position + 1, len(parsed_parts)):\n                parsed_parts[idx] = 0\n            prerelease_str = f\"{pre_release}0\"\n\n    # Now assemble the version string\n    # Per examples, if position=0 (major) bumped, output only major.minor (i.e. 2 parts).\n    # If position=1 bumped, output two parts.\n    # If position=2 bumped, output 3 parts.\n    # But if position beyond length, output all parts.\n\n    # Also, if position==0 (major) bumped, example shows output two components '2.0'\n\n    # We'll output parts up to max(position+1, 2)\n    min_parts_len = 2 if position == 0 else (position + 1)\n    output_parts = parsed_parts[:min_parts_len]\n\n    # Remove trailing zeros from minor and patch unless position==0\n    if position != 0:\n        # remove trailing zeros from the right\n        while len(output_parts) > 1 and output_parts[-1] == 0:\n            output_parts.pop()\n\n    ver_str = '.'.join(str(p) for p in output_parts)\n    if prerelease_str:\n        ver_str += prerelease_str\n    return ver_str\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    # Validate pre_release\n    if pre_release is not None:\n        pre_release_lower = pre_release.lower()\n        if pre_release_lower in ('a', 'alpha'):\n            pre_type = 'a'\n        elif pre_release_lower in ('b', 'beta'):\n            pre_type = 'b'\n        else:\n            raise ValueError(\"pre_release must be one of 'a', 'alpha', 'b', 'beta'\")\n\n    # Pattern to parse version components and optional pre-release suffix\n    # Examples matched:\n    #  - \"1.2.3\", \"1.2.4a0\", \"1.2.4b0\", \"1.2b0\"\n    # Returns groups: full version, main version part, optional pre-release letter and number\n    regex = re.compile(r'^(\\d+(?:\\.\\d+)*)(?:(a|b)(\\d+))?$')\n    m = regex.match(version)\n    if not m:\n        raise ValueError(\"Invalid version string format\")\n\n    main_version_str = m.group(1)\n    existing_pre_type = m.group(2)\n    existing_pre_num_str = m.group(3)\n\n    components_str = main_version_str.split('.')\n    # Convert components to ints\n    try:\n        components = [int(c) for c in components_str]\n    except Exception as e:\n        raise ValueError(\"Invalid integer in version components\") from e\n\n    # Validate position\n    if position < 0:\n        raise ValueError(\"position cannot be negative\")\n    if position > len(components):\n        # position cannot exceed len(components)\n        raise ValueError(\"position does not exist in the version components\")\n\n    # If position equals length of components, we consider this as bumping a new component starting from 0\n    # But problem examples only bump existing or one extra? So be strict and expect position <= length components.\n    # So position == len(components) is invalid because you can't bump a component that doesn't exist.\n    if position == len(components):\n        raise ValueError(\"position does not exist in the version components\")\n\n    # Remove pre-release if pre_release is None (strip pre-release suffix)\n    if pre_release is None:\n        # If there's pre-release suffix in the current version, just remove it\n        # Return main version only\n        # But according to example '1.2.4a1' -> '1.2.4'\n        # '1.2.4b0' -> '1.2.4'\n        # So remove pre-release suffix by returning just the main version string\n        # But consider the position bumping: if position is specified, do bump first then remove pre-release\n        # From examples, if pre_release is None and position is given, then bump numeric component and remove pre-release if any.\n        # So bump first\n        # Remove pre-release after bump\n        pass\n\n    # If pre_release is set and position==0 (major) raise ValueError\n    if pre_release is not None and position == 0:\n        raise ValueError(\"Cannot create a pre-release version for the major position.\")\n\n    # Bump main version component at position\n    # Increase version component at position by 1\n    components[position] += 1\n    # All components after position should be removed (cut off) according to examples\n    # Because for example:\n    # '1.2.3', position=1 -> '1.3'  (components: [1,2,3], pos=1 -> bump 2->3 and remove 3rd component)\n    components = components[:position + 1]\n\n    # When bumping - pre-release suffix currently not considered in examples - only at the end\n    # Now manage pre-release suffix depending on pre_release argument\n\n    # Cases:\n\n    # 1) If pre_release is None: remove any existing pre-release suffix\n    if pre_release is None:\n        # no pre-release suffix\n        result_version = \".\".join(str(c) for c in components)\n\n    else:\n        # pre_release specified: 'a' or 'b'\n        # Need to check if main version changed or not\n        # In examples, bumping pre-release if existing and same type increments its num\n        # if pre-release type changes, start at num 0\n\n        # The pre-release is applied to the last component bumped: e.g. '1.2.4a0'\n        # So basically pre-release suffix appended to the last number component (no dot)\n\n        # Check if existing pre-release type matches requested pre_release\n        if existing_pre_type == pre_type and len(components) == len(components_str):\n            # Same pre-release type exists on this exact main version\n            # increment pre-release number\n            new_pre_num = int(existing_pre_num_str) + 1 if existing_pre_num_str is not None else 0\n        else:\n            # pre-release type changed or new pre-release, start from 0\n            new_pre_num = 0\n\n        result_version = \".\".join(str(c) for c in components) + pre_type + str(new_pre_num)\n\n    return result_version\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    import re\n    from typing import Optional\n\n    # Validate pre_release argument\n    if pre_release is not None:\n        pre_release_lower = pre_release.lower()\n        if pre_release_lower in (\"a\", \"alpha\"):\n            pre_release = \"a\"\n        elif pre_release_lower in (\"b\", \"beta\"):\n            pre_release = \"b\"\n        else:\n            raise ValueError(\n                \"Invalid pre_release value. Must be 'a', 'alpha', 'b', or 'beta'\"\n            )\n    else:\n        pre_release = None\n\n    # Match version pattern: major.minor.patch + optional pre_release & number\n    # Examples: '1.2.3', '1.2.3a0', '1.2b1', '1.2.3b0'\n    # Pattern: ^(\\d+(?:\\.\\d+)*)([ab])?(\\d+)?$\n    pattern = r\"^(\\d+(?:\\.\\d+)*)([ab])?(\\d+)?$\"\n    m = re.match(pattern, version)\n    if not m:\n        raise ValueError(f\"Invalid version number: {version}\")\n    number_part, current_pre, pre_num = m.groups()\n\n    components = number_part.split(\".\")\n    components = [int(c) for c in components]\n    length = len(components)\n\n    # Validate position\n    if position < 0:\n        raise ValueError(\"Position must be zero or positive integer\")\n    # If position >= length, append zero components to reach position? No, based on example:\n    # bump_version('1.2b0', position=2) => '1.2.1' means add component if missing at position\n    if position >= length:\n        # pad with zeros\n        components.extend([0] * (position - length + 1))\n\n    # Function to strip pre-release from version string\n    def remove_pre_release(components_list):\n        return \".\".join(str(x) for x in components_list)\n\n    # 1) If pre_release is None and current version has pre-release, then remove it and return version with same components (do not bump)\n    if pre_release is None and current_pre is not None:\n        # remove pre-release from version string\n        return remove_pre_release(components)\n\n    # 2) If pre_release is given:\n    # - If position == 0 and pre_release is specified, raise error (cannot add prerelease to major version bump)\n    if pre_release is not None and position == 0:\n        raise ValueError(\n            \"Cannot set pre-release on 'major' version component (position 0)\"\n        )\n\n    # 3) Bump version:\n    # - Increment the component at 'position' by 1\n    # - Truncate all components after position\n    components = components[: position + 1]\n    components[position] += 1\n    # Any components after position are removed (as per examples)\n    # If bumping the major (pos 0), minor reset to 0, patch removed (see example '1.3.4' position=0 -> '2.0')\n    # So after truncation, add a zero for position=0 (major bump) for minor version\n\n    # Handle the minor component in case of position 0 bump\n    if position == 0:\n        # after incrementing major, add minor as 0\n        if len(components) == 1:\n            components.append(0)\n    else:\n        # position > 0, all after position truncated, which we already did\n        pass\n\n    # Compose version string before pre-release\n    base_version = \".\".join(str(c) for c in components)\n\n    # Handle pre_release logic:\n    # Pre-release is a suffix with letter + number (e.g. a0, b1)\n    # If pre_release is None and current_pre is None, just return base_version\n    # If pre_release is None and current_pre is present -> removed above already\n    # If pre_release is present:\n\n    # Conditions to detect if we should increase patch to add pre_release:\n    # - If position > len(components)-1 (should be impossible since we padded)\n    # - else if position > last component index, we padded; so the user wants to bump that position\n\n    if pre_release is not None:\n        # Determine current pre-release state\n        # Determine if the pre_release matches current pre_release, then increment pre_num\n        if current_pre == pre_release and pre_num is not None:\n            # increment pre_num\n            new_pre_num = int(pre_num) + 1\n            return f\"{base_version}{pre_release}{new_pre_num}\"\n        else:\n            # if current pre-release was different or none, reset pre_num to 0\n            return f\"{base_version}{pre_release}0\"\n\n    # No pre_release specified and no pre_release present in original version (already handled), just return base_version\n    return base_version\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n"]}
{"task_id": 126, "project": "test-apps/flutils", "module": "flutils.namedtupleutils", "predictions": ["def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    from collections import abc\n    from collections import namedtuple\n\n    def is_valid_identifier(s):\n        return s.isidentifier() and not s.startswith('_')\n\n    def convert_mapping(mapping):\n        # Determine keys in order: ordered dict keeps order, else sorted keys\n        if isinstance(mapping, collections.OrderedDict):\n            keys = list(mapping.keys())\n        else:\n            keys = sorted(mapping.keys())\n\n        # Filter keys: only those valid identifiers and not starting with _\n        attr_names = [k for k in keys if isinstance(k, str) and is_valid_identifier(k)]\n\n        # Recursively convert values for attributes in attr_names\n        attr_values = []\n        for k in attr_names:\n            v = mapping[k]\n            attr_values.append(to_namedtuple(v))\n\n        # Create namedtuple class with name 'NamedTuple'\n        NT = namedtuple('NamedTuple', attr_names)\n        return NT(*attr_values)\n\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n    elif isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n    elif isinstance(obj, abc.Mapping):\n        return convert_mapping(obj)\n    elif isinstance(obj, types.SimpleNamespace):\n        # Get attribute dict\n        attr_dict = vars(obj)\n        # sort attributes alphabetically, exclude those starting with _\n        attr_names = sorted(k for k in attr_dict if is_valid_identifier(k))\n        attr_values = [to_namedtuple(attr_dict[k]) for k in attr_names]\n        NT = namedtuple('NamedTuple', attr_names)\n        return NT(*attr_values)\n    else:\n        # Not a container we handle, return as is\n        return obj", "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    import keyword\n    from collections import namedtuple\n    from collections.abc import Mapping\n    from typing import NamedTuple, Union, List, Tuple\n\n    def _is_valid_identifier(name: str) -> bool:\n        return (\n            isinstance(name, str)\n            and name.isidentifier()\n            and not name.startswith('_')\n            and not keyword.iskeyword(name)\n        )\n\n    def _convert(obj_inner):\n        if isinstance(obj_inner, Mapping):\n            # Determine keys and order for namedtuple fields\n            if isinstance(obj_inner, collections.OrderedDict):\n                keys = [k for k in obj_inner.keys() if _is_valid_identifier(k)]\n            else:\n                keys = sorted(k for k in obj_inner.keys() if _is_valid_identifier(k))\n            # Recursively convert the values\n            values = [ _convert(obj_inner[k]) for k in keys ]\n            # Build namedtuple type with keys ordered as above\n            NamedTupleClass = namedtuple('NamedTuple', keys)\n            return NamedTupleClass(*values)\n\n        elif isinstance(obj_inner, types.SimpleNamespace):\n            # get dict attributes filtered and sorted alphabetically\n            attr_dict = vars(obj_inner)\n            keys = sorted(k for k in attr_dict if _is_valid_identifier(k))\n            values = [_convert(attr_dict[k]) for k in keys]\n            NamedTupleClass = namedtuple('NamedTuple', keys)\n            return NamedTupleClass(*values)\n\n        elif isinstance(obj_inner, list):\n            # convert each element recursively and return new list\n            return [_convert(item) for item in obj_inner]\n\n        elif isinstance(obj_inner, tuple):\n            # convert each element recursively and return new tuple\n            return tuple(_convert(item) for item in obj_inner)\n\n        else:\n            return obj_inner\n\n    return _convert(obj)", "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    from typing import NamedTuple, Union, Mapping, List, Tuple\n\n    def is_valid_identifier(s: str) -> bool:\n        return s.isidentifier() and not s.startswith('_')\n\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    elif isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    elif isinstance(obj, collections.OrderedDict):\n        # keep the order of keys as is\n        items = []\n        fields = []\n        for k, v in obj.items():\n            if is_valid_identifier(k):\n                fields.append(k)\n                items.append(to_namedtuple(v))\n        NT = NamedTuple('NamedTuple', [(field, object) for field in fields])\n        return NT(*items)\n\n    elif isinstance(obj, Mapping):\n        # dictionary\n        # sort keys alphabetically only those valid identifiers and not starting with _\n        fields_and_values = []\n        for k, v in obj.items():\n            if is_valid_identifier(k):\n                fields_and_values.append((k, to_namedtuple(v)))\n\n        fields_and_values.sort(key=lambda x: x[0])\n\n        fields = [f for f, _ in fields_and_values]\n        values = [v for _, v in fields_and_values]\n\n        NT = NamedTuple('NamedTuple', [(field, object) for field in fields])\n        return NT(*values)\n\n    elif isinstance(obj, types.SimpleNamespace):\n        attrs = vars(obj)\n        fields_and_values = []\n        for k, v in attrs.items():\n            if is_valid_identifier(k):\n                fields_and_values.append((k, to_namedtuple(v)))\n\n        fields_and_values.sort(key=lambda x: x[0])\n        fields = [f for f, _ in fields_and_values]\n        values = [v for _, v in fields_and_values]\n\n        NT = NamedTuple('NamedTuple', [(field, object) for field in fields])\n        return NT(*values)\n\n    else:\n        return obj", "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"    \n    from collections import namedtuple, OrderedDict\n    from collections.abc import Mapping\n    from types import SimpleNamespace\n    import keyword\n\n    def is_valid_identifier(s: str) -> bool:\n        return s.isidentifier() and not s.startswith('_') and not keyword.iskeyword(s)\n\n    if isinstance(obj, list):\n        # Return a new list with each element recursively converted\n        return [to_namedtuple(i) for i in obj]\n\n    elif isinstance(obj, tuple):\n        # Return a new tuple with each element recursively converted\n        return tuple(to_namedtuple(i) for i in obj)\n\n    elif isinstance(obj, Mapping):\n        # Decide the order of keys depending on the mapping type\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            keys = sorted(obj.keys())\n\n        # Filter keys to valid identifiers and not starting with _\n        attrs = [k for k in keys if is_valid_identifier(k)]\n\n        values = [to_namedtuple(obj[k]) for k in attrs]\n\n        # Create a namedtuple class with name 'NamedTuple' and specified attrs\n        NT = namedtuple(\"NamedTuple\", attrs, defaults=(None,) * len(attrs))\n        return NT(*values)\n\n    elif isinstance(obj, SimpleNamespace):\n        # Attributes sorted alphabetically, skipping those starting with _\n        attrs = [k for k in sorted(obj.__dict__) if is_valid_identifier(k)]\n        values = [to_namedtuple(getattr(obj, k)) for k in attrs]\n        NT = namedtuple(\"NamedTuple\", attrs, defaults=(None,) * len(attrs))\n        return NT(*values)\n\n    else:\n        # Unhandled type, return as is\n        return obj", "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    from collections.abc import Mapping\n    from typing import NamedTuple, Tuple, List, Union\n    \n    def is_valid_identifier(s: str) -> bool:\n        return s.isidentifier() and not s.startswith(\"_\")\n\n    # Recursive conversion function\n    if isinstance(obj, Mapping):\n        # Determine if ordered or not\n        if isinstance(obj, collections.OrderedDict):\n            keys = list(obj.keys())\n        else:\n            keys = sorted(k for k in obj.keys())\n        # Filter keys for valid identifiers\n        filtered_keys = [k for k in keys if is_valid_identifier(k)]\n\n        # Build values list matching filtered keys, recursively converted\n        values = [to_namedtuple(obj[k]) for k in filtered_keys]\n\n        # Create namedtuple with name 'NamedTuple'\n        if filtered_keys:\n            NT = NamedTuple('NamedTuple', [(k, object) for k in filtered_keys])  # type: ignore\n            return NT(*values)\n        else:\n            # No valid keys, return empty named tuple\n            NT = NamedTuple('NamedTuple', [])\n            return NT()\n\n    elif isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    elif isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    elif isinstance(obj, types.SimpleNamespace):\n        attrs = vars(obj)\n        keys = sorted(k for k in attrs.keys())\n        filtered_keys = [k for k in keys if is_valid_identifier(k)]\n        values = [to_namedtuple(attrs[k]) for k in filtered_keys]\n        if filtered_keys:\n            NT = NamedTuple('NamedTuple', [(k, object) for k in filtered_keys])  # type: ignore\n            return NT(*values)\n        else:\n            NT = NamedTuple('NamedTuple', [])\n            return NT()\n\n    else:\n        # obj cannot be converted, return as is\n        return obj"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    from collections import abc\n    from collections import namedtuple\n\n    def is_valid_identifier(s):\n        return s.isidentifier() and not s.startswith('_')\n\n    def convert_mapping(mapping):\n        # Determine keys in order: ordered dict keeps order, else sorted keys\n        if isinstance(mapping, collections.OrderedDict):\n            keys = list(mapping.keys())\n        else:\n            keys = sorted(mapping.keys())\n\n        # Filter keys: only those valid identifiers and not starting with _\n        attr_names = [k for k in keys if isinstance(k, str) and is_valid_identifier(k)]\n\n        # Recursively convert values for attributes in attr_names\n        attr_values = []\n        for k in attr_names:\n            v = mapping[k]\n            attr_values.append(to_namedtuple(v))\n\n        # Create namedtuple class with name 'NamedTuple'\n        NT = namedtuple('NamedTuple', attr_names)\n        return NT(*attr_values)\n\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n    elif isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n    elif isinstance(obj, abc.Mapping):\n        return convert_mapping(obj)\n    elif isinstance(obj, types.SimpleNamespace):\n        # Get attribute dict\n        attr_dict = vars(obj)\n        # sort attributes alphabetically, exclude those starting with _\n        attr_names = sorted(k for k in attr_dict if is_valid_identifier(k))\n        attr_values = [to_namedtuple(attr_dict[k]) for k in attr_names]\n        NT = namedtuple('NamedTuple', attr_names)\n        return NT(*attr_values)\n    else:\n        # Not a container we handle, return as is\n        return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    import keyword\n    from collections import namedtuple\n    from collections.abc import Mapping\n    from typing import NamedTuple, Union, List, Tuple\n\n    def _is_valid_identifier(name: str) -> bool:\n        return (\n            isinstance(name, str)\n            and name.isidentifier()\n            and not name.startswith('_')\n            and not keyword.iskeyword(name)\n        )\n\n    def _convert(obj_inner):\n        if isinstance(obj_inner, Mapping):\n            # Determine keys and order for namedtuple fields\n            if isinstance(obj_inner, collections.OrderedDict):\n                keys = [k for k in obj_inner.keys() if _is_valid_identifier(k)]\n            else:\n                keys = sorted(k for k in obj_inner.keys() if _is_valid_identifier(k))\n            # Recursively convert the values\n            values = [ _convert(obj_inner[k]) for k in keys ]\n            # Build namedtuple type with keys ordered as above\n            NamedTupleClass = namedtuple('NamedTuple', keys)\n            return NamedTupleClass(*values)\n\n        elif isinstance(obj_inner, types.SimpleNamespace):\n            # get dict attributes filtered and sorted alphabetically\n            attr_dict = vars(obj_inner)\n            keys = sorted(k for k in attr_dict if _is_valid_identifier(k))\n            values = [_convert(attr_dict[k]) for k in keys]\n            NamedTupleClass = namedtuple('NamedTuple', keys)\n            return NamedTupleClass(*values)\n\n        elif isinstance(obj_inner, list):\n            # convert each element recursively and return new list\n            return [_convert(item) for item in obj_inner]\n\n        elif isinstance(obj_inner, tuple):\n            # convert each element recursively and return new tuple\n            return tuple(_convert(item) for item in obj_inner)\n\n        else:\n            return obj_inner\n\n    return _convert(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    from typing import NamedTuple, Union, Mapping, List, Tuple\n\n    def is_valid_identifier(s: str) -> bool:\n        return s.isidentifier() and not s.startswith('_')\n\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    elif isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    elif isinstance(obj, collections.OrderedDict):\n        # keep the order of keys as is\n        items = []\n        fields = []\n        for k, v in obj.items():\n            if is_valid_identifier(k):\n                fields.append(k)\n                items.append(to_namedtuple(v))\n        NT = NamedTuple('NamedTuple', [(field, object) for field in fields])\n        return NT(*items)\n\n    elif isinstance(obj, Mapping):\n        # dictionary\n        # sort keys alphabetically only those valid identifiers and not starting with _\n        fields_and_values = []\n        for k, v in obj.items():\n            if is_valid_identifier(k):\n                fields_and_values.append((k, to_namedtuple(v)))\n\n        fields_and_values.sort(key=lambda x: x[0])\n\n        fields = [f for f, _ in fields_and_values]\n        values = [v for _, v in fields_and_values]\n\n        NT = NamedTuple('NamedTuple', [(field, object) for field in fields])\n        return NT(*values)\n\n    elif isinstance(obj, types.SimpleNamespace):\n        attrs = vars(obj)\n        fields_and_values = []\n        for k, v in attrs.items():\n            if is_valid_identifier(k):\n                fields_and_values.append((k, to_namedtuple(v)))\n\n        fields_and_values.sort(key=lambda x: x[0])\n        fields = [f for f, _ in fields_and_values]\n        values = [v for _, v in fields_and_values]\n\n        NT = NamedTuple('NamedTuple', [(field, object) for field in fields])\n        return NT(*values)\n\n    else:\n        return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"    \n    from collections import namedtuple, OrderedDict\n    from collections.abc import Mapping\n    from types import SimpleNamespace\n    import keyword\n\n    def is_valid_identifier(s: str) -> bool:\n        return s.isidentifier() and not s.startswith('_') and not keyword.iskeyword(s)\n\n    if isinstance(obj, list):\n        # Return a new list with each element recursively converted\n        return [to_namedtuple(i) for i in obj]\n\n    elif isinstance(obj, tuple):\n        # Return a new tuple with each element recursively converted\n        return tuple(to_namedtuple(i) for i in obj)\n\n    elif isinstance(obj, Mapping):\n        # Decide the order of keys depending on the mapping type\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            keys = sorted(obj.keys())\n\n        # Filter keys to valid identifiers and not starting with _\n        attrs = [k for k in keys if is_valid_identifier(k)]\n\n        values = [to_namedtuple(obj[k]) for k in attrs]\n\n        # Create a namedtuple class with name 'NamedTuple' and specified attrs\n        NT = namedtuple(\"NamedTuple\", attrs, defaults=(None,) * len(attrs))\n        return NT(*values)\n\n    elif isinstance(obj, SimpleNamespace):\n        # Attributes sorted alphabetically, skipping those starting with _\n        attrs = [k for k in sorted(obj.__dict__) if is_valid_identifier(k)]\n        values = [to_namedtuple(getattr(obj, k)) for k in attrs]\n        NT = namedtuple(\"NamedTuple\", attrs, defaults=(None,) * len(attrs))\n        return NT(*values)\n\n    else:\n        # Unhandled type, return as is\n        return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    import collections\n    import types\n    from collections.abc import Mapping\n    from typing import NamedTuple, Tuple, List, Union\n    \n    def is_valid_identifier(s: str) -> bool:\n        return s.isidentifier() and not s.startswith(\"_\")\n\n    # Recursive conversion function\n    if isinstance(obj, Mapping):\n        # Determine if ordered or not\n        if isinstance(obj, collections.OrderedDict):\n            keys = list(obj.keys())\n        else:\n            keys = sorted(k for k in obj.keys())\n        # Filter keys for valid identifiers\n        filtered_keys = [k for k in keys if is_valid_identifier(k)]\n\n        # Build values list matching filtered keys, recursively converted\n        values = [to_namedtuple(obj[k]) for k in filtered_keys]\n\n        # Create namedtuple with name 'NamedTuple'\n        if filtered_keys:\n            NT = NamedTuple('NamedTuple', [(k, object) for k in filtered_keys])  # type: ignore\n            return NT(*values)\n        else:\n            # No valid keys, return empty named tuple\n            NT = NamedTuple('NamedTuple', [])\n            return NT()\n\n    elif isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    elif isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    elif isinstance(obj, types.SimpleNamespace):\n        attrs = vars(obj)\n        keys = sorted(k for k in attrs.keys())\n        filtered_keys = [k for k in keys if is_valid_identifier(k)]\n        values = [to_namedtuple(attrs[k]) for k in filtered_keys]\n        if filtered_keys:\n            NT = NamedTuple('NamedTuple', [(k, object) for k in filtered_keys])  # type: ignore\n            return NT(*values)\n        else:\n            NT = NamedTuple('NamedTuple', [])\n            return NT()\n\n    else:\n        # obj cannot be converted, return as is\n        return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n"]}
{"task_id": 127, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if '=' in foreign_name:\n        attr_name, rest = foreign_name.split('=', 1)\n        if '.' in rest:\n            mod_name, mod_attr_name = rest.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = rest, ''\n    else:\n        attr_name = ''\n        if '.' in foreign_name:\n            mod_name, mod_attr_name = foreign_name.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = foreign_name, ''\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)", "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    parts = foreign_name.split(\":\")\n    if len(parts) == 1:\n        # If no colon, attr_name and mod_attr_name both default to empty string\n        mod_name = parts[0]\n        return _AttrMapping(attr_name=\"\", mod_name=mod_name, mod_attr_name=\"\")\n    elif len(parts) == 2:\n        # Check if after colon there's a dot\n        attr_name, rest = parts[0], parts[1]\n        if \".\" in rest:\n            mod_name, mod_attr_name = rest.split(\".\", 1)\n            return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name)\n        else:\n            # No dot means rest is mod_name and mod_attr_name is empty\n            return _AttrMapping(attr_name=attr_name, mod_name=rest, mod_attr_name=\"\")\n    elif len(parts) == 3:\n        # attr_name : mod_name : mod_attr_name\n        attr_name, mod_name, mod_attr_name = parts\n        return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name)\n    else:\n        raise ValueError(f\"Invalid foreign_name format: {foreign_name}\")", "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if '=' in foreign_name:\n        attr_name, rest = foreign_name.split('=', 1)\n        if '.' in rest:\n            mod_name, mod_attr_name = rest.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = rest, ''\n    else:\n        attr_name = ''\n        if '.' in foreign_name:\n            mod_name, mod_attr_name = foreign_name.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = foreign_name, ''\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)", "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    attr_name = \"\"\n    mod_attr_name = \"\"\n\n    # Split off attr_name if present\n    if \":\" in foreign_name:\n        attr_name, foreign_name = foreign_name.split(\":\", 1)\n\n    # Split the mod_name and mod_attr_name\n    if \".\" in foreign_name:\n        *mod_parts, mod_attr_name = foreign_name.rsplit(\".\", 1)\n        mod_name = \".\".join(mod_parts)\n    else:\n        mod_name = foreign_name\n        mod_attr_name = \"\"\n\n    # If attr_name not given, default to mod_attr_name or module\n    if not attr_name:\n        attr_name = mod_attr_name if mod_attr_name else \"\"\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)", "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Split foreign_name by '=' to separate attr_name and module part\n    if '=' in foreign_name:\n        attr_name, remainder = foreign_name.split('=', 1)\n    else:\n        attr_name = ''\n        remainder = foreign_name\n\n    # Split remainder by ':' to separate module name and module attribute\n    if ':' in remainder:\n        mod_name, mod_attr_name = remainder.split(':', 1)\n    else:\n        mod_name = remainder\n        mod_attr_name = ''\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if '=' in foreign_name:\n        attr_name, rest = foreign_name.split('=', 1)\n        if '.' in rest:\n            mod_name, mod_attr_name = rest.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = rest, ''\n    else:\n        attr_name = ''\n        if '.' in foreign_name:\n            mod_name, mod_attr_name = foreign_name.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = foreign_name, ''\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    parts = foreign_name.split(\":\")\n    if len(parts) == 1:\n        # If no colon, attr_name and mod_attr_name both default to empty string\n        mod_name = parts[0]\n        return _AttrMapping(attr_name=\"\", mod_name=mod_name, mod_attr_name=\"\")\n    elif len(parts) == 2:\n        # Check if after colon there's a dot\n        attr_name, rest = parts[0], parts[1]\n        if \".\" in rest:\n            mod_name, mod_attr_name = rest.split(\".\", 1)\n            return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name)\n        else:\n            # No dot means rest is mod_name and mod_attr_name is empty\n            return _AttrMapping(attr_name=attr_name, mod_name=rest, mod_attr_name=\"\")\n    elif len(parts) == 3:\n        # attr_name : mod_name : mod_attr_name\n        attr_name, mod_name, mod_attr_name = parts\n        return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name)\n    else:\n        raise ValueError(f\"Invalid foreign_name format: {foreign_name}\")\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if '=' in foreign_name:\n        attr_name, rest = foreign_name.split('=', 1)\n        if '.' in rest:\n            mod_name, mod_attr_name = rest.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = rest, ''\n    else:\n        attr_name = ''\n        if '.' in foreign_name:\n            mod_name, mod_attr_name = foreign_name.rsplit('.', 1)\n        else:\n            mod_name, mod_attr_name = foreign_name, ''\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    attr_name = \"\"\n    mod_attr_name = \"\"\n\n    # Split off attr_name if present\n    if \":\" in foreign_name:\n        attr_name, foreign_name = foreign_name.split(\":\", 1)\n\n    # Split the mod_name and mod_attr_name\n    if \".\" in foreign_name:\n        *mod_parts, mod_attr_name = foreign_name.rsplit(\".\", 1)\n        mod_name = \".\".join(mod_parts)\n    else:\n        mod_name = foreign_name\n        mod_attr_name = \"\"\n\n    # If attr_name not given, default to mod_attr_name or module\n    if not attr_name:\n        attr_name = mod_attr_name if mod_attr_name else \"\"\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Split foreign_name by '=' to separate attr_name and module part\n    if '=' in foreign_name:\n        attr_name, remainder = foreign_name.split('=', 1)\n    else:\n        attr_name = ''\n        remainder = foreign_name\n\n    # Split remainder by ':' to separate module name and module attribute\n    if ':' in remainder:\n        mod_name, mod_attr_name = remainder.split(':', 1)\n    else:\n        mod_name = remainder\n        mod_attr_name = ''\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()"]}
{"task_id": 128, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        parts = foreign_name.split(':')\n        if len(parts) == 1:\n            # no namespace or alias, foreign_name is also local_name\n            local_name = parts[0]\n            namespace = None\n            alias = None\n        elif len(parts) == 2:\n            # two parts, could be namespace:local_name or local_name:alias\n            if parts[0].startswith('@'):\n                # treat as namespace:local_name (for example)\n                namespace = parts[0]\n                local_name = parts[1]\n                alias = None\n            else:\n                # treat as local_name:alias\n                namespace = None\n                local_name = parts[0]\n                alias = parts[1]\n        elif len(parts) == 3:\n            namespace, local_name, alias = parts\n        else:\n            raise ValueError(f\"Invalid foreign-name format: {foreign_name}\")\n        yield _AttrMapping(foreign=foreign_name, namespace=namespace, local_name=local_name, alias=alias)", "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        # The foreign_name is expected to have a specific format, for example:\n        # \"local_name:remote_name:type\"\n        # This is just an example, adjust based on actual expected format.\n        parts = foreign_name.split(':')\n        if len(parts) == 3:\n            local_name, remote_name, typ = parts\n        elif len(parts) == 2:\n            local_name, remote_name = parts\n            typ = None\n        else:\n            local_name = remote_name = parts[0]\n            typ = None\n        yield _AttrMapping(local_name=local_name, foreign_name=remote_name, typ=typ)", "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        # Assuming _AttrMapping has fields: foreign_name, local_name, and type_hint\n        # Parse the foreign_name string to extract local_name and type_hint if possible.\n        # Example foreign_name format: \"foreign_name:local_name:type_hint\"\n        parts = foreign_name.split(\":\")\n        if len(parts) == 3:\n            foreign, local, hint = parts\n        elif len(parts) == 2:\n            foreign, local = parts\n            hint = None\n        else:\n            foreign = parts[0]\n            local = None\n            hint = None\n        yield _AttrMapping(foreign_name=foreign, local_name=local, type_hint=hint)", "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        parts = foreign_name.split(':')\n        if len(parts) == 1:\n            yield _AttrMapping(foreign_name, None, None)\n        elif len(parts) == 2:\n            yield _AttrMapping(parts[0], parts[1], None)\n        elif len(parts) == 3:\n            yield _AttrMapping(parts[0], parts[1], parts[2])\n        else:\n            raise ValueError(f\"Invalid foreign-name format: {foreign_name}\")", "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        # Split by ':' to separate parts (e.g., foreign name and other info)\n        parts = foreign_name.split(':')\n        name_part = parts[0]\n        extra = parts[1:] if len(parts) > 1 else []\n\n        # further split by '.' to handle nested attributes\n        nested_parts = name_part.split('.')\n        if len(nested_parts) == 1:\n            # single attribute, yield _AttrMapping with appropriate values\n            yield _AttrMapping(foreign=foreign_name, local=name_part, nested=())\n        else:\n            # more than one nested part, first is local attribute, rest is nested\n            local = nested_parts[0]\n            nested = tuple(nested_parts[1:])\n            yield _AttrMapping(foreign=foreign_name, local=local, nested=nested)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        parts = foreign_name.split(':')\n        if len(parts) == 1:\n            # no namespace or alias, foreign_name is also local_name\n            local_name = parts[0]\n            namespace = None\n            alias = None\n        elif len(parts) == 2:\n            # two parts, could be namespace:local_name or local_name:alias\n            if parts[0].startswith('@'):\n                # treat as namespace:local_name (for example)\n                namespace = parts[0]\n                local_name = parts[1]\n                alias = None\n            else:\n                # treat as local_name:alias\n                namespace = None\n                local_name = parts[0]\n                alias = parts[1]\n        elif len(parts) == 3:\n            namespace, local_name, alias = parts\n        else:\n            raise ValueError(f\"Invalid foreign-name format: {foreign_name}\")\n        yield _AttrMapping(foreign=foreign_name, namespace=namespace, local_name=local_name, alias=alias)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        # The foreign_name is expected to have a specific format, for example:\n        # \"local_name:remote_name:type\"\n        # This is just an example, adjust based on actual expected format.\n        parts = foreign_name.split(':')\n        if len(parts) == 3:\n            local_name, remote_name, typ = parts\n        elif len(parts) == 2:\n            local_name, remote_name = parts\n            typ = None\n        else:\n            local_name = remote_name = parts[0]\n            typ = None\n        yield _AttrMapping(local_name=local_name, foreign_name=remote_name, typ=typ)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        # Assuming _AttrMapping has fields: foreign_name, local_name, and type_hint\n        # Parse the foreign_name string to extract local_name and type_hint if possible.\n        # Example foreign_name format: \"foreign_name:local_name:type_hint\"\n        parts = foreign_name.split(\":\")\n        if len(parts) == 3:\n            foreign, local, hint = parts\n        elif len(parts) == 2:\n            foreign, local = parts\n            hint = None\n        else:\n            foreign = parts[0]\n            local = None\n            hint = None\n        yield _AttrMapping(foreign_name=foreign, local_name=local, type_hint=hint)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        parts = foreign_name.split(':')\n        if len(parts) == 1:\n            yield _AttrMapping(foreign_name, None, None)\n        elif len(parts) == 2:\n            yield _AttrMapping(parts[0], parts[1], None)\n        elif len(parts) == 3:\n            yield _AttrMapping(parts[0], parts[1], parts[2])\n        else:\n            raise ValueError(f\"Invalid foreign-name format: {foreign_name}\")\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        # Split by ':' to separate parts (e.g., foreign name and other info)\n        parts = foreign_name.split(':')\n        name_part = parts[0]\n        extra = parts[1:] if len(parts) > 1 else []\n\n        # further split by '.' to handle nested attributes\n        nested_parts = name_part.split('.')\n        if len(nested_parts) == 1:\n            # single attribute, yield _AttrMapping with appropriate values\n            yield _AttrMapping(foreign=foreign_name, local=name_part, nested=())\n        else:\n            # more than one nested part, first is local attribute, rest is nested\n            local = nested_parts[0]\n            nested = tuple(nested_parts[1:])\n            yield _AttrMapping(foreign=foreign_name, local=local, nested=nested)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n"]}
{"task_id": 129, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["def encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove all whitespace characters to handle multi-line and indented input\n    cleaned_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(cleaned_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)", "def encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove all whitespace characters including newlines and spaces\n    clean_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(clean_text)\n    return decoded_bytes, len(decoded_bytes)", "def encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove all whitespace characters that might be present due to indentation or newlines\n    filtered_text = \"\".join(text.split())\n    decoded_bytes = base64.b64decode(filtered_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)", "def encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Strip spaces and newlines, since base64 can be multiline and indented\n    normalized_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(normalized_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)", "def encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove whitespace and newlines from text\n    clean_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(clean_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove all whitespace characters to handle multi-line and indented input\n    cleaned_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(cleaned_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove all whitespace characters including newlines and spaces\n    clean_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(clean_text)\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove all whitespace characters that might be present due to indentation or newlines\n    filtered_text = \"\".join(text.split())\n    decoded_bytes = base64.b64decode(filtered_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Strip spaces and newlines, since base64 can be multiline and indented\n    normalized_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(normalized_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    import base64\n    # Remove whitespace and newlines from text\n    clean_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(clean_text, validate=True)\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()"]}
{"task_id": 130, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["def decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    if not isinstance(data, (bytes, bytearray, memoryview)):\n        raise TypeError(\"a bytes-like object is required\")\n    encoded_bytes = base64.b64encode(data)\n    encoded_str = encoded_bytes.decode('ascii')\n    return encoded_str, len(data)", "def decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    encoded = base64.b64encode(data)\n    return encoded.decode('ascii'), len(data)", "def decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    encoded = base64.b64encode(data)\n    return encoded.decode('ascii'), len(data)", "def decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    encoded_bytes = base64.b64encode(data)\n    encoded_str = encoded_bytes.decode('ascii')\n    return encoded_str, len(data)", "def decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    b64_str = base64.b64encode(data).decode('ascii')\n    return b64_str, len(data)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    if not isinstance(data, (bytes, bytearray, memoryview)):\n        raise TypeError(\"a bytes-like object is required\")\n    encoded_bytes = base64.b64encode(data)\n    encoded_str = encoded_bytes.decode('ascii')\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    encoded = base64.b64encode(data)\n    return encoded.decode('ascii'), len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    encoded = base64.b64encode(data)\n    return encoded.decode('ascii'), len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    encoded_bytes = base64.b64encode(data)\n    encoded_str = encoded_bytes.decode('ascii')\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    import base64\n    b64_str = base64.b64encode(data).decode('ascii')\n    return b64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n"]}
{"task_id": 131, "project": "test-apps/flutils", "module": "flutils.txtutils", "predictions": ["def len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*[mK]')\n    if isinstance(seq, str):\n        return len(ansi_escape.sub('', seq))\n    elif isinstance(seq, (list, tuple)):\n        return sum(len_without_ansi(s) for s in seq)\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")", "def len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*[mKHF]')\n    if isinstance(seq, (list, tuple)):\n        return sum(len(ansi_escape.sub('', s)) for s in seq)\n    else:\n        return len(ansi_escape.sub('', seq))", "def len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*m')\n    if isinstance(seq, str):\n        clean_text = ansi_escape.sub('', seq)\n        return len(clean_text)\n    elif isinstance(seq, (list, tuple)):\n        total_length = 0\n        for item in seq:\n            if isinstance(item, str):\n                clean_item = ansi_escape.sub('', item)\n                total_length += len(clean_item)\n            else:\n                raise TypeError(\"All elements of the sequence must be strings\")\n        return total_length\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")", "def len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*m')\n\n    if isinstance(seq, str):\n        return len(ansi_escape.sub('', seq))\n    elif isinstance(seq, (list, tuple)):\n        return sum(len(ansi_escape.sub('', s)) for s in seq)\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")", "def len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*m')\n    if isinstance(seq, str):\n        return len(ansi_escape.sub('', seq))\n    elif isinstance(seq, (list, tuple)):\n        return sum(len(ansi_escape.sub('', s)) for s in seq)\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*[mK]')\n    if isinstance(seq, str):\n        return len(ansi_escape.sub('', seq))\n    elif isinstance(seq, (list, tuple)):\n        return sum(len_without_ansi(s) for s in seq)\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*[mKHF]')\n    if isinstance(seq, (list, tuple)):\n        return sum(len(ansi_escape.sub('', s)) for s in seq)\n    else:\n        return len(ansi_escape.sub('', seq))\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*m')\n    if isinstance(seq, str):\n        clean_text = ansi_escape.sub('', seq)\n        return len(clean_text)\n    elif isinstance(seq, (list, tuple)):\n        total_length = 0\n        for item in seq:\n            if isinstance(item, str):\n                clean_item = ansi_escape.sub('', item)\n                total_length += len(clean_item)\n            else:\n                raise TypeError(\"All elements of the sequence must be strings\")\n        return total_length\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*m')\n\n    if isinstance(seq, str):\n        return len(ansi_escape.sub('', seq))\n    elif isinstance(seq, (list, tuple)):\n        return sum(len(ansi_escape.sub('', s)) for s in seq)\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    import re\n    ansi_escape = re.compile(r'\\x1b\\[[0-9;]*m')\n    if isinstance(seq, str):\n        return len(ansi_escape.sub('', seq))\n    elif isinstance(seq, (list, tuple)):\n        return sum(len(ansi_escape.sub('', s)) for s in seq)\n    else:\n        raise TypeError(\"Input must be a string or a list/tuple of strings\")\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n"]}
{"task_id": 132, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escape_char(c: str) -> str:\n        codepoint = ord(c)\n        # ASCII range - use \\xHH\n        if codepoint <= 0x7F:\n            return f\"\\\\x{codepoint:02x}\"\n        # BMP range (Basic Multilingual Plane) - use \\uHHHH\n        elif codepoint <= 0xFFFF:\n            return f\"\\\\u{codepoint:04x}\"\n        else:\n            # Supplementary planes - use \\UHHHHHHHH\n            return f\"\\\\U{codepoint:08x}\"\n\n    return ''.join(escape_char(c) for c in text)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for c in text:\n        codepoint = ord(c)\n        if codepoint <= 0xFF:\n            escaped = f\"\\\\x{codepoint:02x}\"\n        elif codepoint <= 0xFFFF:\n            escaped = f\"\\\\u{codepoint:04x}\"\n        else:\n            escaped = f\"\\\\U{codepoint:08x}\"\n        result.append(escaped)\n    # Return string with each escape character escaped (doubling backslashes)\n    return ''.join(result).replace('\\\\', '\\\\\\\\')", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escape_char(c):\n        code = ord(c)\n        if code <= 0xFF:\n            return '\\\\\\\\x{:02x}'.format(code)\n        elif code <= 0xFFFF:\n            return '\\\\\\\\u{:04x}'.format(code)\n        else:\n            return '\\\\\\\\U{:08x}'.format(code)\n\n    return ''.join(escape_char(c) for c in text)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escaped_char(c: str) -> str:\n        codepoint = ord(c)\n        if codepoint <= 0xFF:\n            return f\"\\\\x{codepoint:02x}\"\n        elif codepoint <= 0xFFFF:\n            return f\"\\\\u{codepoint:04x}\"\n        else:\n            return f\"\\\\U{codepoint:08x}\"\n\n    return \"\".join(escaped_char(c) for c in text)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0xFF:\n            result.append(f'\\\\\\\\x{codepoint:02x}')\n        elif codepoint <= 0xFFFF:\n            result.append(f'\\\\\\\\u{codepoint:04x}')\n        else:\n            result.append(f'\\\\\\\\U{codepoint:08x}')\n    return ''.join(result)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escape_char(c: str) -> str:\n        codepoint = ord(c)\n        # ASCII range - use \\xHH\n        if codepoint <= 0x7F:\n            return f\"\\\\x{codepoint:02x}\"\n        # BMP range (Basic Multilingual Plane) - use \\uHHHH\n        elif codepoint <= 0xFFFF:\n            return f\"\\\\u{codepoint:04x}\"\n        else:\n            # Supplementary planes - use \\UHHHHHHHH\n            return f\"\\\\U{codepoint:08x}\"\n\n    return ''.join(escape_char(c) for c in text)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for c in text:\n        codepoint = ord(c)\n        if codepoint <= 0xFF:\n            escaped = f\"\\\\x{codepoint:02x}\"\n        elif codepoint <= 0xFFFF:\n            escaped = f\"\\\\u{codepoint:04x}\"\n        else:\n            escaped = f\"\\\\U{codepoint:08x}\"\n        result.append(escaped)\n    # Return string with each escape character escaped (doubling backslashes)\n    return ''.join(result).replace('\\\\', '\\\\\\\\')\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escape_char(c):\n        code = ord(c)\n        if code <= 0xFF:\n            return '\\\\\\\\x{:02x}'.format(code)\n        elif code <= 0xFFFF:\n            return '\\\\\\\\u{:04x}'.format(code)\n        else:\n            return '\\\\\\\\U{:08x}'.format(code)\n\n    return ''.join(escape_char(c) for c in text)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    def escaped_char(c: str) -> str:\n        codepoint = ord(c)\n        if codepoint <= 0xFF:\n            return f\"\\\\x{codepoint:02x}\"\n        elif codepoint <= 0xFFFF:\n            return f\"\\\\u{codepoint:04x}\"\n        else:\n            return f\"\\\\U{codepoint:08x}\"\n\n    return \"\".join(escaped_char(c) for c in text)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0xFF:\n            result.append(f'\\\\\\\\x{codepoint:02x}')\n        elif codepoint <= 0xFFFF:\n            result.append(f'\\\\\\\\u{codepoint:04x}')\n        else:\n            result.append(f'\\\\\\\\U{codepoint:08x}')\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n"]}
{"task_id": 133, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\x{b:02x}' for b in text.encode('utf-8'))", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\x{b:02x}' for b in text.encode('utf-8'))\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    return ''.join(f'\\\\\\\\x{b:02x}' for b in text.encode('utf-8'))\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n"]}
{"task_id": 134, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    s2 = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1)\n    return s2.lower()", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    underscored = re.sub(r'(?<!^)(?=[A-Z])', '_', text).lower()\n    return underscored", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    underscored = re.sub(r'(?<!^)(?=[A-Z])', '_', text).lower()\n    return underscored", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    s2 = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1)\n    return s2.lower()", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    s2 = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1)\n    return s2.lower()"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    s2 = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1)\n    return s2.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    underscored = re.sub(r'(?<!^)(?=[A-Z])', '_', text).lower()\n    return underscored\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    underscored = re.sub(r'(?<!^)(?=[A-Z])', '_', text).lower()\n    return underscored\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    s2 = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1)\n    return s2.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    import re\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    s2 = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1)\n    return s2.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n"]}
{"task_id": 135, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    return text.encode('utf-8').decode('unicode_escape')", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    import codecs\n    return codecs.decode(text, 'unicode_escape')", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    return bytes(text, \"utf-8\").decode(\"unicode_escape\")", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"    \n    return bytes(text, \"utf-8\").decode(\"unicode_escape\")", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    return bytes(text, \"utf-8\").decode(\"unicode_escape\")"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    return text.encode('utf-8').decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    import codecs\n    return codecs.decode(text, 'unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    return bytes(text, \"utf-8\").decode(\"unicode_escape\")\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"    \n    return bytes(text, \"utf-8\").decode(\"unicode_escape\")\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    return bytes(text, \"utf-8\").decode(\"unicode_escape\")\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n"]}
{"task_id": 136, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    try:\n        bytes_decoded = text.encode('utf-8').decode('unicode_escape').encode('latin1')\n        return bytes_decoded.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise e", "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Encode the string to bytes using 'latin1' to ensure all bytes 0-255 map directly\n    # Then decode using 'unicode_escape' to convert escaped sequences into bytes\n    bytes_decoded = text.encode('latin1').decode('unicode_escape').encode('latin1')\n    # Finally decode the bytes as UTF-8 to get the proper string characters\n    return bytes_decoded.decode('utf-8')", "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    import codecs\n    try:\n        # First decode using unicode_escape to interpret the escaped sequences\n        decoded_bytes = codecs.decode(text, 'unicode_escape')\n        # Then encode back to bytes to decode utf-8 bytes properly\n        utf8_bytes = decoded_bytes.encode('latin1')\n        # Finally decode utf-8 bytes to get proper characters\n        return utf8_bytes.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise e", "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Decode the escaped hex bytes into binary, then decode binary as UTF-8 string\n    try:\n        return text.encode('utf-8').decode('unicode_escape').encode('latin1').decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise e", "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Encode the string to bytes using 'latin1' so that the characters remain\n    # the same byte values, then decode using 'unicode_escape' to interpret\n    # the escaped hex sequences, then encode to bytes again and decode as utf-8.\n    # This allows the conversion of escaped UTF-8 hex bytes into correct characters.\n    try:\n        return text.encode('latin1').decode('unicode_escape').encode('latin1').decode('utf-8')\n    except UnicodeDecodeError as e:\n        # Reraise with the same exception for clarity\n        raise e"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    try:\n        bytes_decoded = text.encode('utf-8').decode('unicode_escape').encode('latin1')\n        return bytes_decoded.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise e\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Encode the string to bytes using 'latin1' to ensure all bytes 0-255 map directly\n    # Then decode using 'unicode_escape' to convert escaped sequences into bytes\n    bytes_decoded = text.encode('latin1').decode('unicode_escape').encode('latin1')\n    # Finally decode the bytes as UTF-8 to get the proper string characters\n    return bytes_decoded.decode('utf-8')\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    import codecs\n    try:\n        # First decode using unicode_escape to interpret the escaped sequences\n        decoded_bytes = codecs.decode(text, 'unicode_escape')\n        # Then encode back to bytes to decode utf-8 bytes properly\n        utf8_bytes = decoded_bytes.encode('latin1')\n        # Finally decode utf-8 bytes to get proper characters\n        return utf8_bytes.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise e\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Decode the escaped hex bytes into binary, then decode binary as UTF-8 string\n    try:\n        return text.encode('utf-8').decode('unicode_escape').encode('latin1').decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise e\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Encode the string to bytes using 'latin1' so that the characters remain\n    # the same byte values, then decode using 'unicode_escape' to interpret\n    # the escaped hex sequences, then encode to bytes again and decode as utf-8.\n    # This allows the conversion of escaped UTF-8 hex bytes into correct characters.\n    try:\n        return text.encode('latin1').decode('unicode_escape').encode('latin1').decode('utf-8')\n    except UnicodeDecodeError as e:\n        # Reraise with the same exception for clarity\n        raise e\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n"]}
{"task_id": 137, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n\n    words = [w for w in text.split('_') if w]\n    if not words:\n        return ''\n    camel = ''.join(word.capitalize() for word in words)\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n    return camel", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = [p for p in text.split('_') if p]\n    if not parts:\n        return ''\n    camel_parts = [parts[0].lower() if lower_first else parts[0].capitalize()]\n    camel_parts += [p.capitalize() for p in parts[1:]]\n    return ''.join(camel_parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = [p for p in text.split('_') if p]\n    if not parts:\n        return ''\n    camel = ''.join(word.capitalize() for word in parts)\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n    return camel", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = [part for part in text.split('_') if part]\n    if not parts:\n        return ''\n    camel = ''.join(word.capitalize() for word in parts)\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n    return camel", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    words = [word for word in text.split('_') if word]\n    if not words:\n        return ''\n    camel_cased = ''.join(word.capitalize() for word in words)\n    if lower_first and camel_cased:\n        camel_cased = camel_cased[0].lower() + camel_cased[1:]\n    return camel_cased"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n\n    words = [w for w in text.split('_') if w]\n    if not words:\n        return ''\n    camel = ''.join(word.capitalize() for word in words)\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n    return camel\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = [p for p in text.split('_') if p]\n    if not parts:\n        return ''\n    camel_parts = [parts[0].lower() if lower_first else parts[0].capitalize()]\n    camel_parts += [p.capitalize() for p in parts[1:]]\n    return ''.join(camel_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = [p for p in text.split('_') if p]\n    if not parts:\n        return ''\n    camel = ''.join(word.capitalize() for word in parts)\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n    return camel\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = [part for part in text.split('_') if part]\n    if not parts:\n        return ''\n    camel = ''.join(word.capitalize() for word in parts)\n    if lower_first and camel:\n        camel = camel[0].lower() + camel[1:]\n    return camel\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    words = [word for word in text.split('_') if word]\n    if not words:\n        return ''\n    camel_cased = ''.join(word.capitalize() for word in words)\n    if lower_first and camel_cased:\n        camel_cased = camel_cased[0].lower() + camel_cased[1:]\n    return camel_cased\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n"]}
{"task_id": 138, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n    import pwd\n\n    if name is None:\n        # Get current user's group\n        uid = os.getuid()\n        user_info = pwd.getpwuid(uid)\n        gid = user_info.pw_gid\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # Treat as gid\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        # Treat as group name\n        return grp.getgrnam(name)\n\n    # If not matched type, raise TypeError\n    raise TypeError(\"name must be None, an int (gid), or a str (group name).\")", "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n    if name is None:\n        # Use current user's group\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(\"name must be either None, str, or int\")", "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n\n    if name is None:\n        # default to current user's group id\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        # interpret name as gid\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        # interpret name as group name\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(\"name must be str, int, or None\")", "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n\n    if name is None:\n        # Use current user's primary group id\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        return grp.getgrnam(name)\n\n    raise TypeError(\"name must be a str, int or None\")", "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n\n    if name is None:\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # assume it's a gid\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        # assume it's a group name\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(f\"Expected str, int, or None, got {type(name).__name__}\")"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n    import pwd\n\n    if name is None:\n        # Get current user's group\n        uid = os.getuid()\n        user_info = pwd.getpwuid(uid)\n        gid = user_info.pw_gid\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # Treat as gid\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        # Treat as group name\n        return grp.getgrnam(name)\n\n    # If not matched type, raise TypeError\n    raise TypeError(\"name must be None, an int (gid), or a str (group name).\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n    if name is None:\n        # Use current user's group\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(\"name must be either None, str, or int\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n\n    if name is None:\n        # default to current user's group id\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n    elif isinstance(name, int):\n        # interpret name as gid\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        # interpret name as group name\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(\"name must be str, int, or None\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n\n    if name is None:\n        # Use current user's primary group id\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        return grp.getgrgid(name)\n\n    if isinstance(name, str):\n        return grp.getgrnam(name)\n\n    raise TypeError(\"name must be a str, int or None\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    import grp\n    import os\n\n    if name is None:\n        gid = os.getgid()\n        return grp.getgrgid(gid)\n\n    if isinstance(name, int):\n        # assume it's a gid\n        return grp.getgrgid(name)\n    elif isinstance(name, str):\n        # assume it's a group name\n        return grp.getgrnam(name)\n    else:\n        raise TypeError(f\"Expected str, int, or None, got {type(name).__name__}\")\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()"]}
{"task_id": 139, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n\n    if name is None:\n        name = os.getlogin()\n    if isinstance(name, int):\n        # Lookup by uid\n        return pwd.getpwuid(name)\n    else:\n        # Lookup by username (str)\n        return pwd.getpwnam(name)", "def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n    \n    if name is None:\n        name = os.getlogin()\n        \n    if isinstance(name, int):\n        # Assume name is a uid\n        return pwd.getpwuid(name)\n    else:\n        # Assume name is a login name (str)\n        return pwd.getpwnam(name)", "def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import os\n    import pwd\n\n    if name is None:\n        name = os.getlogin()\n\n    if isinstance(name, int):\n        return pwd.getpwuid(name)\n    elif isinstance(name, str):\n        return pwd.getpwnam(name)\n    else:\n        raise TypeError(\"name must be either a string or an integer, or None\")", "def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n\n    if name is None:\n        name = os.getlogin()\n\n    try:\n        if isinstance(name, int):\n            return pwd.getpwuid(name)\n        else:\n            return pwd.getpwnam(str(name))\n    except KeyError as e:\n        raise OSError(f\"os user not found: {name}\") from e", "def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n    if name is None:\n        name = os.getlogin()\n    try:\n        if isinstance(name, int):\n            return pwd.getpwuid(name)\n        else:\n            return pwd.getpwnam(name)\n    except KeyError as e:\n        raise OSError(f\"User '{name}' does not exist\") from e"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n\n    if name is None:\n        name = os.getlogin()\n    if isinstance(name, int):\n        # Lookup by uid\n        return pwd.getpwuid(name)\n    else:\n        # Lookup by username (str)\n        return pwd.getpwnam(name)\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n    \n    if name is None:\n        name = os.getlogin()\n        \n    if isinstance(name, int):\n        # Assume name is a uid\n        return pwd.getpwuid(name)\n    else:\n        # Assume name is a login name (str)\n        return pwd.getpwnam(name)\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import os\n    import pwd\n\n    if name is None:\n        name = os.getlogin()\n\n    if isinstance(name, int):\n        return pwd.getpwuid(name)\n    elif isinstance(name, str):\n        return pwd.getpwnam(name)\n    else:\n        raise TypeError(\"name must be either a string or an integer, or None\")\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n\n    if name is None:\n        name = os.getlogin()\n\n    try:\n        if isinstance(name, int):\n            return pwd.getpwuid(name)\n        else:\n            return pwd.getpwnam(str(name))\n    except KeyError as e:\n        raise OSError(f\"os user not found: {name}\") from e\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    import pwd\n    import os\n    if name is None:\n        name = os.getlogin()\n    try:\n        if isinstance(name, int):\n            return pwd.getpwuid(name)\n        else:\n            return pwd.getpwnam(name)\n    except KeyError as e:\n        raise OSError(f\"User '{name}' does not exist\") from e\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()"]}
{"task_id": 140, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    result_bytes = bytearray()\n    i = 0\n    length = len(text)\n\n    # Pattern to match escaped hex bytes like \\xHH\n    escape_pattern = re.compile(r'\\\\x([0-9A-Fa-f]{2})')\n\n    while i < length:\n        char = text[i]\n\n        if char == '\\\\' and i + 3 < length and text[i+1] == 'x':\n            # Attempt to parse escaped hex byte\n            hex_part = text[i+2:i+4]\n            if re.fullmatch(r'[0-9A-Fa-f]{2}', hex_part):\n                byte_val = int(hex_part, 16)\n                # Validate if the byte_val can be part of a valid utf8 byte sequence\n                # For this, we need to parse the bytes to utf8.\n                # We will collect all consecutive \\xHH bytes and then decode.\n\n                # Collect consecutive escaped hex bytes\n                start = i\n                bytes_buffer = bytearray()\n                while (i + 3 < length and text[i] == '\\\\' and text[i+1] == 'x' and\n                       re.fullmatch(r'[0-9A-Fa-f]{2}', text[i+2:i+4])):\n                    bytes_buffer.append(int(text[i+2:i+4], 16))\n                    i += 4\n\n                # Validate UTF-8 decoding\n                try:\n                    bytes_buffer.decode('utf-8')\n                except UnicodeDecodeError as e:\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"utf-8\", text, start, i,\n                            \"invalid UTF-8 bytes escaped sequence\"\n                        ) from e\n                    elif errors == 'ignore':\n                        # Skip the invalid sequence\n                        continue\n                    elif errors == 'replace':\n                        # Replace invalid sequence with '?' bytes\n                        bytes_buffer = b'?'\n                    else:\n                        # Fallback to raising error\n                        raise UnicodeEncodeError(\n                            \"utf-8\", text, start, i,\n                            \"invalid UTF-8 bytes escaped sequence\"\n                        ) from e\n\n                result_bytes.extend(bytes_buffer)\n                continue\n            else:\n                # Not a valid escaped hex byte, encode the backslash as utf8\n                result_bytes.extend(char.encode('utf-8', errors=errors))\n                i += 1\n        else:\n            # Normal character; encode with utf8\n            result_bytes.extend(char.encode('utf-8', errors=errors))\n            i += 1\n\n    return bytes(result_bytes), length", "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    def is_valid_utf8(byte_seq):\n        try:\n            byte_seq.decode('utf-8')\n            return True\n        except UnicodeDecodeError:\n            return False\n\n    bytes_out = bytearray()\n    i = 0\n    length = len(text)\n    while i < length:\n        ch = text[i]\n        if ch == '\\\\' and i + 3 < length and text[i+1] == 'x':\n            # Attempt to parse escaped hex\n            hex_part = text[i+2:i+4]\n            if re.fullmatch(r'[0-9a-fA-F]{2}', hex_part):\n                byte_val = int(hex_part, 16)\n                candidate = bytes_out + bytes([byte_val])\n                if not is_valid_utf8(candidate):\n                    # unicode error if adding this byte would cause invalid utf8\n                    raise UnicodeEncodeError(\"utf-8\", text, i, i+4,\n                                             \"escaped hex byte leads to invalid utf-8\")\n                bytes_out.append(byte_val)\n                i += 4\n                continue\n            else:\n                # Invalid hex digits after \\x, fallback\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\"utf-8\", text, i, i+4, \"invalid hex digits after '\\\\x'\")\n                elif errors == 'replace':\n                    bytes_out.append(ord('?'))\n                    i += 4\n                    continue\n                elif errors == 'ignore':\n                    i += 4\n                    continue\n                else:\n                    raise ValueError(f\"Unknown error handler: {errors}\")\n        else:\n            # Encode character to UTF-8 normally\n            encoded = ch.encode('utf-8', errors=errors)\n            bytes_out.extend(encoded)\n            i += 1\n\n    return bytes(bytes_out), i", "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    result = bytearray()\n    pos = 0\n    length = len(text)\n\n    # Regex to match escaped hex bytes like \\xHH\n    escaped_hex_re = re.compile(r'\\\\x([0-9A-Fa-f]{2})')\n\n    while pos < length:\n        char = text[pos]\n        if char == '\\\\':\n            # Check if this is an escaped hex byte\n            match = escaped_hex_re.match(text, pos)\n            if match:\n                hex_byte = match.group(1)\n                try:\n                    byte_value = int(hex_byte, 16)\n                except ValueError as e:\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"utf-8\", text, pos, pos + 4,\n                            \"invalid escaped hex byte\"\n                        ) from e\n                    elif errors == 'ignore':\n                        pos += 4\n                        continue\n                    elif errors == 'replace':\n                        result.extend(b'?')\n                        pos += 4\n                        continue\n                    else:\n                        raise\n                # Validate this byte can be part of a utf-8 sequence by collecting\n                # subsequent bytes if necessary.\n                # For simplicity, accumulate bytes and then validate entire bytes sequence.\n                # We'll decode after the full byte sequence is read.\n                # But since we read one byte at a time, we can append and validate after.\n\n                # Try to decode the last bytes to check if valid UTF-8 so far\n                # But here we don't have a clear boundary; so instead, accumulate all bytes\n                # until next non-escaped char or end.\n\n                # We'll do a look-ahead to find next non-escaped byte or append only this byte and continue.\n\n                # For correctness, just append the byte and later decode whole result\n\n                result.append(byte_value)\n                pos += 4\n            else:\n                # It is a backslash not followed by xHH, treat the backslash as escaped byte\n                # Like '\\\\' => one backslash byte 0x5c\n                # Or '\\n','\\t' etc are not mentioned, so treat backslash literal\n                result.append(ord('\\\\'))\n                pos += 1\n        else:\n            # Non-backslash character: encode it to utf-8 bytes and add\n            encoded_bytes = char.encode('utf-8', errors)\n            result.extend(encoded_bytes)\n            pos += 1\n\n    # Now validate entire bytearray is valid utf-8\n    try:\n        result.decode('utf-8')\n    except UnicodeDecodeError as e:\n        if errors == 'strict':\n            raise UnicodeEncodeError(\n                \"utf-8\", text, e.start, e.end,\n                \"invalid utf8 bytes in escaped sequence\"\n            ) from e\n        elif errors == 'ignore':\n            # Remove invalid bytes and continue\n            valid_bytes = bytearray()\n            i = 0\n            while i < len(result):\n                try:\n                    # Test decode from i to i+1, increasing length until valid UTF-8 char found\n                    for j in range(i+1, len(result)+1):\n                        try:\n                            result[i:j].decode('utf-8')\n                        except UnicodeDecodeError:\n                            continue\n                        else:\n                            valid_bytes.extend(result[i:j])\n                            i = j\n                            break\n                    else:\n                        # no valid decode found, skip one byte\n                        i += 1\n                except UnicodeDecodeError:\n                    i += 1\n            result = valid_bytes\n        elif errors == 'replace':\n            decoded = result.decode('utf-8', 'replace')\n            result = decoded.encode('utf-8')\n        else:\n            raise\n\n    return bytes(result), length", "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    consumed = 0\n    result_bytes = bytearray()\n    i = 0\n    length = len(text)\n\n    def decode_hex_escape(seq: str) -> int:\n        try:\n            return int(seq, 16)\n        except ValueError:\n            raise UnicodeEncodeError(\n                \"utf-8\", text, i, i+4,\n                f\"illegal hex escape sequence '\\\\x{seq}'\"\n            )\n\n    while i < length:\n        c = text[i]\n        if c == '\\\\' and i + 3 < length and text[i+1] == 'x':\n            hex_seq = text[i+2:i+4]\n            byte_val = decode_hex_escape(hex_seq)\n            # check if byte_val is a valid UTF-8 byte start or continuation\n            # It is probably enough to check that byte_val is in 0-255, which it always is.\n            # The check required is if the resulted bytes together are valid UTF-8,\n            # but since we process byte by byte, defer to try decode later.\n            result_bytes.append(byte_val)\n            i += 4\n            consumed += 4\n        else:\n            # encode c as utf-8 bytes\n            encoded = c.encode('utf-8', errors)\n            result_bytes.extend(encoded)\n            i += 1\n            consumed += 1\n\n    # validate that the resulting bytes form valid utf-8\n    try:\n        result_bytes.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\"utf-8\", text, e.start, e.end, \"invalid utf-8 byte sequence\") from None\n\n    return bytes(result_bytes), consumed", "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    result = bytearray()\n    i = 0\n    n = len(text)\n\n    while i < n:\n        if text[i] == '\\\\' and i + 3 < n and text[i+1] == 'x':\n            # Try to parse escaped hex byte\n            hex_part = text[i+2:i+4]\n            try:\n                byte_val = int(hex_part, 16)\n            except ValueError:\n                # Not a valid hex, treat it as literal backslash\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped hex byte\"\n                    )\n                elif errors == 'replace':\n                    result.extend(b'?')\n                    i += 4\n                    continue\n                elif errors == 'ignore':\n                    i += 4\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped hex byte\"\n                    )\n            # Validate the byte as part of a valid UTF-8 sequence\n            candidate = bytes(result) + bytes([byte_val])\n            # We won't fully decode here, but ensure valid UTF-8 prefix\n            # Attempt to decode candidate to check validity\n            try:\n                candidate.decode('utf-8')\n            except UnicodeDecodeError as e:\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped utf-8 bytes\"\n                    )\n                elif errors == 'replace':\n                    result.extend(b'?')\n                    i += 4\n                    continue\n                elif errors == 'ignore':\n                    i += 4\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped utf-8 bytes\"\n                    )\n            result.append(byte_val)\n            i += 4\n        else:\n            # Normal character, encode with utf-8 and append\n            char = text[i]\n            try:\n                encoded_char = char.encode('utf-8', errors)\n            except UnicodeEncodeError:\n                # Prepare UnicodeEncodeError for strict\n                if errors == 'strict':\n                    raise\n                elif errors == 'replace':\n                    encoded_char = b'?'\n                elif errors == 'ignore':\n                    encoded_char = b''\n                else:\n                    raise\n            result.extend(encoded_char)\n            i += 1\n\n    return bytes(result), i"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    result_bytes = bytearray()\n    i = 0\n    length = len(text)\n\n    # Pattern to match escaped hex bytes like \\xHH\n    escape_pattern = re.compile(r'\\\\x([0-9A-Fa-f]{2})')\n\n    while i < length:\n        char = text[i]\n\n        if char == '\\\\' and i + 3 < length and text[i+1] == 'x':\n            # Attempt to parse escaped hex byte\n            hex_part = text[i+2:i+4]\n            if re.fullmatch(r'[0-9A-Fa-f]{2}', hex_part):\n                byte_val = int(hex_part, 16)\n                # Validate if the byte_val can be part of a valid utf8 byte sequence\n                # For this, we need to parse the bytes to utf8.\n                # We will collect all consecutive \\xHH bytes and then decode.\n\n                # Collect consecutive escaped hex bytes\n                start = i\n                bytes_buffer = bytearray()\n                while (i + 3 < length and text[i] == '\\\\' and text[i+1] == 'x' and\n                       re.fullmatch(r'[0-9A-Fa-f]{2}', text[i+2:i+4])):\n                    bytes_buffer.append(int(text[i+2:i+4], 16))\n                    i += 4\n\n                # Validate UTF-8 decoding\n                try:\n                    bytes_buffer.decode('utf-8')\n                except UnicodeDecodeError as e:\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"utf-8\", text, start, i,\n                            \"invalid UTF-8 bytes escaped sequence\"\n                        ) from e\n                    elif errors == 'ignore':\n                        # Skip the invalid sequence\n                        continue\n                    elif errors == 'replace':\n                        # Replace invalid sequence with '?' bytes\n                        bytes_buffer = b'?'\n                    else:\n                        # Fallback to raising error\n                        raise UnicodeEncodeError(\n                            \"utf-8\", text, start, i,\n                            \"invalid UTF-8 bytes escaped sequence\"\n                        ) from e\n\n                result_bytes.extend(bytes_buffer)\n                continue\n            else:\n                # Not a valid escaped hex byte, encode the backslash as utf8\n                result_bytes.extend(char.encode('utf-8', errors=errors))\n                i += 1\n        else:\n            # Normal character; encode with utf8\n            result_bytes.extend(char.encode('utf-8', errors=errors))\n            i += 1\n\n    return bytes(result_bytes), length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    def is_valid_utf8(byte_seq):\n        try:\n            byte_seq.decode('utf-8')\n            return True\n        except UnicodeDecodeError:\n            return False\n\n    bytes_out = bytearray()\n    i = 0\n    length = len(text)\n    while i < length:\n        ch = text[i]\n        if ch == '\\\\' and i + 3 < length and text[i+1] == 'x':\n            # Attempt to parse escaped hex\n            hex_part = text[i+2:i+4]\n            if re.fullmatch(r'[0-9a-fA-F]{2}', hex_part):\n                byte_val = int(hex_part, 16)\n                candidate = bytes_out + bytes([byte_val])\n                if not is_valid_utf8(candidate):\n                    # unicode error if adding this byte would cause invalid utf8\n                    raise UnicodeEncodeError(\"utf-8\", text, i, i+4,\n                                             \"escaped hex byte leads to invalid utf-8\")\n                bytes_out.append(byte_val)\n                i += 4\n                continue\n            else:\n                # Invalid hex digits after \\x, fallback\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\"utf-8\", text, i, i+4, \"invalid hex digits after '\\\\x'\")\n                elif errors == 'replace':\n                    bytes_out.append(ord('?'))\n                    i += 4\n                    continue\n                elif errors == 'ignore':\n                    i += 4\n                    continue\n                else:\n                    raise ValueError(f\"Unknown error handler: {errors}\")\n        else:\n            # Encode character to UTF-8 normally\n            encoded = ch.encode('utf-8', errors=errors)\n            bytes_out.extend(encoded)\n            i += 1\n\n    return bytes(bytes_out), i\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    result = bytearray()\n    pos = 0\n    length = len(text)\n\n    # Regex to match escaped hex bytes like \\xHH\n    escaped_hex_re = re.compile(r'\\\\x([0-9A-Fa-f]{2})')\n\n    while pos < length:\n        char = text[pos]\n        if char == '\\\\':\n            # Check if this is an escaped hex byte\n            match = escaped_hex_re.match(text, pos)\n            if match:\n                hex_byte = match.group(1)\n                try:\n                    byte_value = int(hex_byte, 16)\n                except ValueError as e:\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"utf-8\", text, pos, pos + 4,\n                            \"invalid escaped hex byte\"\n                        ) from e\n                    elif errors == 'ignore':\n                        pos += 4\n                        continue\n                    elif errors == 'replace':\n                        result.extend(b'?')\n                        pos += 4\n                        continue\n                    else:\n                        raise\n                # Validate this byte can be part of a utf-8 sequence by collecting\n                # subsequent bytes if necessary.\n                # For simplicity, accumulate bytes and then validate entire bytes sequence.\n                # We'll decode after the full byte sequence is read.\n                # But since we read one byte at a time, we can append and validate after.\n\n                # Try to decode the last bytes to check if valid UTF-8 so far\n                # But here we don't have a clear boundary; so instead, accumulate all bytes\n                # until next non-escaped char or end.\n\n                # We'll do a look-ahead to find next non-escaped byte or append only this byte and continue.\n\n                # For correctness, just append the byte and later decode whole result\n\n                result.append(byte_value)\n                pos += 4\n            else:\n                # It is a backslash not followed by xHH, treat the backslash as escaped byte\n                # Like '\\\\' => one backslash byte 0x5c\n                # Or '\\n','\\t' etc are not mentioned, so treat backslash literal\n                result.append(ord('\\\\'))\n                pos += 1\n        else:\n            # Non-backslash character: encode it to utf-8 bytes and add\n            encoded_bytes = char.encode('utf-8', errors)\n            result.extend(encoded_bytes)\n            pos += 1\n\n    # Now validate entire bytearray is valid utf-8\n    try:\n        result.decode('utf-8')\n    except UnicodeDecodeError as e:\n        if errors == 'strict':\n            raise UnicodeEncodeError(\n                \"utf-8\", text, e.start, e.end,\n                \"invalid utf8 bytes in escaped sequence\"\n            ) from e\n        elif errors == 'ignore':\n            # Remove invalid bytes and continue\n            valid_bytes = bytearray()\n            i = 0\n            while i < len(result):\n                try:\n                    # Test decode from i to i+1, increasing length until valid UTF-8 char found\n                    for j in range(i+1, len(result)+1):\n                        try:\n                            result[i:j].decode('utf-8')\n                        except UnicodeDecodeError:\n                            continue\n                        else:\n                            valid_bytes.extend(result[i:j])\n                            i = j\n                            break\n                    else:\n                        # no valid decode found, skip one byte\n                        i += 1\n                except UnicodeDecodeError:\n                    i += 1\n            result = valid_bytes\n        elif errors == 'replace':\n            decoded = result.decode('utf-8', 'replace')\n            result = decoded.encode('utf-8')\n        else:\n            raise\n\n    return bytes(result), length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    consumed = 0\n    result_bytes = bytearray()\n    i = 0\n    length = len(text)\n\n    def decode_hex_escape(seq: str) -> int:\n        try:\n            return int(seq, 16)\n        except ValueError:\n            raise UnicodeEncodeError(\n                \"utf-8\", text, i, i+4,\n                f\"illegal hex escape sequence '\\\\x{seq}'\"\n            )\n\n    while i < length:\n        c = text[i]\n        if c == '\\\\' and i + 3 < length and text[i+1] == 'x':\n            hex_seq = text[i+2:i+4]\n            byte_val = decode_hex_escape(hex_seq)\n            # check if byte_val is a valid UTF-8 byte start or continuation\n            # It is probably enough to check that byte_val is in 0-255, which it always is.\n            # The check required is if the resulted bytes together are valid UTF-8,\n            # but since we process byte by byte, defer to try decode later.\n            result_bytes.append(byte_val)\n            i += 4\n            consumed += 4\n        else:\n            # encode c as utf-8 bytes\n            encoded = c.encode('utf-8', errors)\n            result_bytes.extend(encoded)\n            i += 1\n            consumed += 1\n\n    # validate that the resulting bytes form valid utf-8\n    try:\n        result_bytes.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\"utf-8\", text, e.start, e.end, \"invalid utf-8 byte sequence\") from None\n\n    return bytes(result_bytes), consumed\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    import re\n\n    result = bytearray()\n    i = 0\n    n = len(text)\n\n    while i < n:\n        if text[i] == '\\\\' and i + 3 < n and text[i+1] == 'x':\n            # Try to parse escaped hex byte\n            hex_part = text[i+2:i+4]\n            try:\n                byte_val = int(hex_part, 16)\n            except ValueError:\n                # Not a valid hex, treat it as literal backslash\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped hex byte\"\n                    )\n                elif errors == 'replace':\n                    result.extend(b'?')\n                    i += 4\n                    continue\n                elif errors == 'ignore':\n                    i += 4\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped hex byte\"\n                    )\n            # Validate the byte as part of a valid UTF-8 sequence\n            candidate = bytes(result) + bytes([byte_val])\n            # We won't fully decode here, but ensure valid UTF-8 prefix\n            # Attempt to decode candidate to check validity\n            try:\n                candidate.decode('utf-8')\n            except UnicodeDecodeError as e:\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped utf-8 bytes\"\n                    )\n                elif errors == 'replace':\n                    result.extend(b'?')\n                    i += 4\n                    continue\n                elif errors == 'ignore':\n                    i += 4\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"utf-8\", text, i, i+4,\n                        \"invalid escaped utf-8 bytes\"\n                    )\n            result.append(byte_val)\n            i += 4\n        else:\n            # Normal character, encode with utf-8 and append\n            char = text[i]\n            try:\n                encoded_char = char.encode('utf-8', errors)\n            except UnicodeEncodeError:\n                # Prepare UnicodeEncodeError for strict\n                if errors == 'strict':\n                    raise\n                elif errors == 'replace':\n                    encoded_char = b'?'\n                elif errors == 'ignore':\n                    encoded_char = b''\n                else:\n                    raise\n            result.extend(encoded_char)\n            i += 1\n\n    return bytes(result), i\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()"]}
{"task_id": 141, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    import codecs\n\n    # Pattern to match escaped hex values like \\xHH\n    pattern = re.compile(rb'\\\\x([0-9a-fA-F]{2})')\n\n    # Convert data to bytes if it's memoryview or bytearray\n    if not isinstance(data, bytes):\n        data_bytes = bytes(data)\n    else:\n        data_bytes = data\n\n    # Replace escaped hex \\xHH with actual byte values\n    try:\n        decoded_bytes = pattern.sub(lambda m: bytes([int(m.group(1), 16)]), data_bytes)\n    except Exception as e:\n        if errors == 'strict':\n            raise UnicodeDecodeError(\n                \"utf-8\", data_bytes, 0, len(data_bytes),\n                f\"Invalid escaped hex sequence: {e}\"\n            )\n        elif errors == 'ignore':\n            decoded_bytes = b''\n        elif errors == 'replace':\n            decoded_bytes = b'?'\n        else:\n            raise\n\n    # Decode the resulting bytes as utf-8\n    try:\n        decoded_str = decoded_bytes.decode('utf-8', errors=errors)\n    except UnicodeDecodeError as e:\n        raise e\n\n    # Number of bytes consumed is the length of the input data\n    consumed = len(data_bytes)\n    return (decoded_str, consumed)", "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    import codecs\n\n    # pattern to find escaped hex bytes like \\xhh\n    pattern = re.compile(rb'\\\\x([0-9A-Fa-f]{2})')\n    \n    # build bytearray by replacing escaped hex bytes with actual bytes\n    output_bytes = bytearray()\n    idx = 0\n    length = len(data)\n    while idx < length:\n        if data[idx] == ord('\\\\') and idx + 3 < length and data[idx+1] == ord('x'):\n            hex_pair = data[idx+2:idx+4]\n            try:\n                byte = int(hex_pair.decode('ascii'), 16)\n            except ValueError:\n                # malformed hex sequence; raise UnicodeDecodeError\n                raise UnicodeDecodeError(\"utf-8\", data, idx, idx + 4,\n                                         \"invalid escaped hex sequence\")\n            output_bytes.append(byte)\n            idx += 4\n        else:\n            output_bytes.append(data[idx])\n            idx += 1\n\n    # decode using utf-8 with given error handling scheme\n    decoded_str = output_bytes.decode('utf-8', errors)\n    return decoded_str, length", "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    import codecs\n\n    # The pattern matches escaped hexadecimal bytes like \\xNN\n    pattern = re.compile(br'\\\\x([0-9A-Fa-f]{2})')\n\n    # Prepare a bytearray to hold the decoded bytes\n    decoded_bytes = bytearray()\n\n    i = 0\n    length = len(data)\n    while i < length:\n        if data[i:i+2] == b'\\\\x' and i + 3 < length:\n            match = pattern.match(data, i)\n            if match:\n                hex_byte = match.group(1)\n                try:\n                    byte_val = int(hex_byte, 16)\n                except ValueError as e:\n                    if errors == 'strict':\n                        raise UnicodeDecodeError(\"utf-8\", data, i, i+4, \"invalid hexadecimal escape\") from e\n                    elif errors == 'ignore':\n                        i += 4\n                        continue\n                    elif errors == 'replace':\n                        decoded_bytes.append(ord('?'))\n                        i += 4\n                        continue\n                    else:\n                        raise\n                decoded_bytes.append(byte_val)\n                i += 4\n            else:\n                # Not a valid \\xNN sequence, treat as literal\n                if errors == 'strict':\n                    raise UnicodeDecodeError(\"utf-8\", data, i, i+2, \"invalid escape sequence\")\n                elif errors == 'ignore':\n                    i += 2\n                    continue\n                elif errors == 'replace':\n                    decoded_bytes.append(ord('?'))\n                    i += 2\n                    continue\n                else:\n                    raise\n        else:\n            # Not an escape sequence, copy the literal byte\n            decoded_bytes.append(data[i])\n            i += 1\n\n    # Now decode the bytes as utf-8\n    decoded_str = decoded_bytes.decode('utf-8', errors=errors)\n    return decoded_str, i", "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    # Pattern to find escaped hex bytes like \\xHH\n    pattern = re.compile(rb'\\\\x([0-9A-Fa-f]{2})')\n\n    # Replace all escaped hex bytes with their byte values\n    try:\n        decoded_bytes = pattern.sub(lambda m: bytes([int(m.group(1), 16)]), data)\n    except Exception as e:\n        if errors == 'strict':\n            raise UnicodeDecodeError(\"utf-8\", data, 0, len(data), str(e))\n        elif errors == 'ignore':\n            # Ignore invalid sequences by removing them\n            decoded_bytes = pattern.sub(b'', data)\n        elif errors == 'replace':\n            decoded_bytes = pattern.sub(lambda m: b'\\xef\\xbf\\xbd', data)  # Unicode replacement char\n        else:\n            raise e\n\n    # Decode the resulting bytes to string using utf-8 with the specified error handler\n    decoded_str = decoded_bytes.decode('utf-8', errors=errors)\n    return decoded_str, len(data)", "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import codecs\n    \n    # data is bytes with escaped hexadecimal sequences, e.g. b'\\\\xe2\\\\x82\\\\xac'\n    # We want to interpret those escapes as bytes and then decode the resulting bytes as utf-8.\n\n    # Decode the escaped hex string to raw bytes\n    try:\n        raw_bytes = codecs.escape_decode(data)[0]\n    except Exception as e:\n        if errors == 'strict':\n            raise\n        elif errors == 'ignore':\n            raw_bytes = b\"\"\n        elif errors == 'replace':\n            raw_bytes = b'?'\n        else:\n            # use strict if unknown error handler\n            raise\n\n    # Decode the raw bytes as UTF-8 string\n    decoded_str = raw_bytes.decode('utf-8', errors)\n\n    # Number of bytes consumed = length of input data\n    consumed = len(data)\n\n    return decoded_str, consumed"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    import codecs\n\n    # Pattern to match escaped hex values like \\xHH\n    pattern = re.compile(rb'\\\\x([0-9a-fA-F]{2})')\n\n    # Convert data to bytes if it's memoryview or bytearray\n    if not isinstance(data, bytes):\n        data_bytes = bytes(data)\n    else:\n        data_bytes = data\n\n    # Replace escaped hex \\xHH with actual byte values\n    try:\n        decoded_bytes = pattern.sub(lambda m: bytes([int(m.group(1), 16)]), data_bytes)\n    except Exception as e:\n        if errors == 'strict':\n            raise UnicodeDecodeError(\n                \"utf-8\", data_bytes, 0, len(data_bytes),\n                f\"Invalid escaped hex sequence: {e}\"\n            )\n        elif errors == 'ignore':\n            decoded_bytes = b''\n        elif errors == 'replace':\n            decoded_bytes = b'?'\n        else:\n            raise\n\n    # Decode the resulting bytes as utf-8\n    try:\n        decoded_str = decoded_bytes.decode('utf-8', errors=errors)\n    except UnicodeDecodeError as e:\n        raise e\n\n    # Number of bytes consumed is the length of the input data\n    consumed = len(data_bytes)\n    return (decoded_str, consumed)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    import codecs\n\n    # pattern to find escaped hex bytes like \\xhh\n    pattern = re.compile(rb'\\\\x([0-9A-Fa-f]{2})')\n    \n    # build bytearray by replacing escaped hex bytes with actual bytes\n    output_bytes = bytearray()\n    idx = 0\n    length = len(data)\n    while idx < length:\n        if data[idx] == ord('\\\\') and idx + 3 < length and data[idx+1] == ord('x'):\n            hex_pair = data[idx+2:idx+4]\n            try:\n                byte = int(hex_pair.decode('ascii'), 16)\n            except ValueError:\n                # malformed hex sequence; raise UnicodeDecodeError\n                raise UnicodeDecodeError(\"utf-8\", data, idx, idx + 4,\n                                         \"invalid escaped hex sequence\")\n            output_bytes.append(byte)\n            idx += 4\n        else:\n            output_bytes.append(data[idx])\n            idx += 1\n\n    # decode using utf-8 with given error handling scheme\n    decoded_str = output_bytes.decode('utf-8', errors)\n    return decoded_str, length\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    import codecs\n\n    # The pattern matches escaped hexadecimal bytes like \\xNN\n    pattern = re.compile(br'\\\\x([0-9A-Fa-f]{2})')\n\n    # Prepare a bytearray to hold the decoded bytes\n    decoded_bytes = bytearray()\n\n    i = 0\n    length = len(data)\n    while i < length:\n        if data[i:i+2] == b'\\\\x' and i + 3 < length:\n            match = pattern.match(data, i)\n            if match:\n                hex_byte = match.group(1)\n                try:\n                    byte_val = int(hex_byte, 16)\n                except ValueError as e:\n                    if errors == 'strict':\n                        raise UnicodeDecodeError(\"utf-8\", data, i, i+4, \"invalid hexadecimal escape\") from e\n                    elif errors == 'ignore':\n                        i += 4\n                        continue\n                    elif errors == 'replace':\n                        decoded_bytes.append(ord('?'))\n                        i += 4\n                        continue\n                    else:\n                        raise\n                decoded_bytes.append(byte_val)\n                i += 4\n            else:\n                # Not a valid \\xNN sequence, treat as literal\n                if errors == 'strict':\n                    raise UnicodeDecodeError(\"utf-8\", data, i, i+2, \"invalid escape sequence\")\n                elif errors == 'ignore':\n                    i += 2\n                    continue\n                elif errors == 'replace':\n                    decoded_bytes.append(ord('?'))\n                    i += 2\n                    continue\n                else:\n                    raise\n        else:\n            # Not an escape sequence, copy the literal byte\n            decoded_bytes.append(data[i])\n            i += 1\n\n    # Now decode the bytes as utf-8\n    decoded_str = decoded_bytes.decode('utf-8', errors=errors)\n    return decoded_str, i\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import re\n    # Pattern to find escaped hex bytes like \\xHH\n    pattern = re.compile(rb'\\\\x([0-9A-Fa-f]{2})')\n\n    # Replace all escaped hex bytes with their byte values\n    try:\n        decoded_bytes = pattern.sub(lambda m: bytes([int(m.group(1), 16)]), data)\n    except Exception as e:\n        if errors == 'strict':\n            raise UnicodeDecodeError(\"utf-8\", data, 0, len(data), str(e))\n        elif errors == 'ignore':\n            # Ignore invalid sequences by removing them\n            decoded_bytes = pattern.sub(b'', data)\n        elif errors == 'replace':\n            decoded_bytes = pattern.sub(lambda m: b'\\xef\\xbf\\xbd', data)  # Unicode replacement char\n        else:\n            raise e\n\n    # Decode the resulting bytes to string using utf-8 with the specified error handler\n    decoded_str = decoded_bytes.decode('utf-8', errors=errors)\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    import codecs\n    \n    # data is bytes with escaped hexadecimal sequences, e.g. b'\\\\xe2\\\\x82\\\\xac'\n    # We want to interpret those escapes as bytes and then decode the resulting bytes as utf-8.\n\n    # Decode the escaped hex string to raw bytes\n    try:\n        raw_bytes = codecs.escape_decode(data)[0]\n    except Exception as e:\n        if errors == 'strict':\n            raise\n        elif errors == 'ignore':\n            raw_bytes = b\"\"\n        elif errors == 'replace':\n            raw_bytes = b'?'\n        else:\n            # use strict if unknown error handler\n            raise\n\n    # Decode the raw bytes as UTF-8 string\n    decoded_str = raw_bytes.decode('utf-8', errors)\n\n    # Number of bytes consumed = length of input data\n    consumed = len(data)\n\n    return decoded_str, consumed\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()"]}
{"task_id": 142, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)", "def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)", "def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)", "def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)", "def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n"]}
{"task_id": 143, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False", "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False", "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    return any(callable(getattr(obj, attr, None)) for attr in attrs)", "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    return any(callable(getattr(obj, attr, None)) for attr in attrs)", "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    return any(callable(getattr(obj, attr, None)) for attr in attrs)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    return any(callable(getattr(obj, attr, None)) for attr in attrs)\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    return any(callable(getattr(obj, attr, None)) for attr in attrs)\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    return any(callable(getattr(obj, attr, None)) for attr in attrs)\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n"]}
{"task_id": 144, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    # Exclude None and bool explicitly\n    if obj is None or isinstance(obj, bool):\n        return False\n\n    # Exclude bytes and str explicitly\n    if isinstance(obj, (bytes, str)):\n        return False\n\n    # Also exclude numbers explicitly\n    if isinstance(obj, (int, float, decimal.Decimal)):\n        return False\n\n    # Exclude collections that are explicitly excluded\n    excluded_collections = (\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        dict,\n    )\n\n    if isinstance(obj, excluded_collections):\n        return False\n\n    # Check if obj is instance of list-like collections\n    list_like_collections = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    if isinstance(obj, list_like_collections):\n        return True\n\n    # Lastly, check that obj is iterable (but exclude strings and bytes which are already excluded above)\n    if hasattr(obj, '__iter__'):\n        # But we don't want to count dict or dict subclasses here\n        if isinstance(obj, dict):\n            return False\n        try:\n            iter(obj)\n            return True\n        except TypeError:\n            return False\n\n    return False", "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    # Define the allowed list-like types\n    list_like_types = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    # Define disallowed explicit types\n    disallowed_types = (\n        type(None),\n        bool,\n        bytes,\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        decimal.Decimal,\n        dict,\n        float,\n        int,\n        str,\n    )\n\n    if obj is None:\n        return False\n    if isinstance(obj, disallowed_types):\n        return False\n    if isinstance(obj, list_like_types):\n        return True\n    # Finally, check if the object is iterable and not str/bytes/bool which are ruled out\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n    # The given docstring says things like str and bytes are not list-like; confirmed above.\n    # So, here we ensure that.\n    if isinstance(obj, (str, bytes, bool)):\n        return False\n    return True", "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    list_like_types = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    not_list_like_types = (\n        type(None),\n        bool,\n        bytes,\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        decimal.Decimal,\n        dict,\n        float,\n        int,\n        str,\n    )\n\n    if obj is None:\n        return False\n\n    if isinstance(obj, not_list_like_types):\n        return False\n\n    if isinstance(obj, list_like_types):\n        return True\n\n    # Exclude string, bytes and other non-iterables here by testing for __iter__\n    if hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes)):\n        return True\n\n    return False", "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    from collections import UserList, deque\n    from collections.abc import Iterator, KeysView, ValuesView\n    import collections\n    import decimal\n    import typing\n\n    # Exclude None explicitly\n    if obj is None:\n        return False\n\n    # Exclude bool\n    if isinstance(obj, bool):\n        return False\n\n    # Exclude bytes\n    if isinstance(obj, bytes):\n        return False\n\n    # Exclude str\n    if isinstance(obj, str):\n        return False\n\n    # Exclude float, int\n    if isinstance(obj, (int, float)):\n        return False\n\n    # Exclude dict and its subclasses_UserDict, defaultdict, OrderedDict, ChainMap\n    # Checking for dict and common dict-like classes to exclude - to consider collections.abc.Mapping\n    # But UserDict etc do not inherit collections.abc.Mapping? Actually UserDict derives from MutableMapping\n    # So we can handle them with isinstance(obj, collections.abc.Mapping):\n    if isinstance(obj, (\n        dict,\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.defaultdict,\n    )):\n        return False\n\n    # Exclude UserString (which is a string subclass from collections)\n    if isinstance(obj, collections.UserString):\n        return False\n\n    # Exclude Decimal\n    if isinstance(obj, decimal.Decimal):\n        return False\n\n    # Check if obj is instance of one of the allowed list-like types\n    if isinstance(obj, (\n        UserList,\n        Iterator,\n        KeysView,\n        ValuesView,\n        deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )):\n        return True\n\n    # Additionally check if it's iterable and not excluded type like string or bytes\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    # Exclude all other known primitives that are not allowed:\n    # We already excluded bool, bytes, str, int, float and None above\n    # Now fall back to checking if it's a sequence (but exclude Mapping or MappingView to prevent dict-like)\n    # But since many types are covered and we're allowing Iterator and views,\n    # restrict to iterable objects that implement __getitem__ or are recognized as sequence\n    # We want to avoid dict or Mapping types, so exclude these:\n    if isinstance(obj, collections.abc.Mapping) or isinstance(obj, collections.abc.MappingView):\n        return False\n\n    # To confirm it's list-like, check if it's iterable and has __getitem__ or is iterator\n    if hasattr(obj, '__getitem__') or isinstance(obj, collections.abc.Iterator):\n        return True\n\n    return False", "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    # Exclude types explicitly NOT considered list-like\n    if obj is None:\n        return False\n    if isinstance(obj, (bool, bytes, bytearray, str, memoryview)):\n        return False\n    if isinstance(obj, (dict,\n                        collections.ChainMap,\n                        collections.Counter,\n                        collections.OrderedDict,\n                        collections.UserDict,\n                        collections.UserString,\n                        collections.defaultdict,\n                        decimal.Decimal,\n                        float,\n                        int)):\n        return False\n\n    # Include types explicitly considered list-like\n    list_like_classes = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n    if isinstance(obj, list_like_classes):\n        return True\n\n    # Also check if the object is iterable (duck-typing)\n    # but exclude strings, bytes and other non-list-like as above\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    # Exclude None and bool explicitly\n    if obj is None or isinstance(obj, bool):\n        return False\n\n    # Exclude bytes and str explicitly\n    if isinstance(obj, (bytes, str)):\n        return False\n\n    # Also exclude numbers explicitly\n    if isinstance(obj, (int, float, decimal.Decimal)):\n        return False\n\n    # Exclude collections that are explicitly excluded\n    excluded_collections = (\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        dict,\n    )\n\n    if isinstance(obj, excluded_collections):\n        return False\n\n    # Check if obj is instance of list-like collections\n    list_like_collections = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    if isinstance(obj, list_like_collections):\n        return True\n\n    # Lastly, check that obj is iterable (but exclude strings and bytes which are already excluded above)\n    if hasattr(obj, '__iter__'):\n        # But we don't want to count dict or dict subclasses here\n        if isinstance(obj, dict):\n            return False\n        try:\n            iter(obj)\n            return True\n        except TypeError:\n            return False\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    # Define the allowed list-like types\n    list_like_types = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    # Define disallowed explicit types\n    disallowed_types = (\n        type(None),\n        bool,\n        bytes,\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        decimal.Decimal,\n        dict,\n        float,\n        int,\n        str,\n    )\n\n    if obj is None:\n        return False\n    if isinstance(obj, disallowed_types):\n        return False\n    if isinstance(obj, list_like_types):\n        return True\n    # Finally, check if the object is iterable and not str/bytes/bool which are ruled out\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n    # The given docstring says things like str and bytes are not list-like; confirmed above.\n    # So, here we ensure that.\n    if isinstance(obj, (str, bytes, bool)):\n        return False\n    return True\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    list_like_types = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    not_list_like_types = (\n        type(None),\n        bool,\n        bytes,\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.UserString,\n        collections.defaultdict,\n        decimal.Decimal,\n        dict,\n        float,\n        int,\n        str,\n    )\n\n    if obj is None:\n        return False\n\n    if isinstance(obj, not_list_like_types):\n        return False\n\n    if isinstance(obj, list_like_types):\n        return True\n\n    # Exclude string, bytes and other non-iterables here by testing for __iter__\n    if hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes)):\n        return True\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    from collections import UserList, deque\n    from collections.abc import Iterator, KeysView, ValuesView\n    import collections\n    import decimal\n    import typing\n\n    # Exclude None explicitly\n    if obj is None:\n        return False\n\n    # Exclude bool\n    if isinstance(obj, bool):\n        return False\n\n    # Exclude bytes\n    if isinstance(obj, bytes):\n        return False\n\n    # Exclude str\n    if isinstance(obj, str):\n        return False\n\n    # Exclude float, int\n    if isinstance(obj, (int, float)):\n        return False\n\n    # Exclude dict and its subclasses_UserDict, defaultdict, OrderedDict, ChainMap\n    # Checking for dict and common dict-like classes to exclude - to consider collections.abc.Mapping\n    # But UserDict etc do not inherit collections.abc.Mapping? Actually UserDict derives from MutableMapping\n    # So we can handle them with isinstance(obj, collections.abc.Mapping):\n    if isinstance(obj, (\n        dict,\n        collections.ChainMap,\n        collections.Counter,\n        collections.OrderedDict,\n        collections.UserDict,\n        collections.defaultdict,\n    )):\n        return False\n\n    # Exclude UserString (which is a string subclass from collections)\n    if isinstance(obj, collections.UserString):\n        return False\n\n    # Exclude Decimal\n    if isinstance(obj, decimal.Decimal):\n        return False\n\n    # Check if obj is instance of one of the allowed list-like types\n    if isinstance(obj, (\n        UserList,\n        Iterator,\n        KeysView,\n        ValuesView,\n        deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )):\n        return True\n\n    # Additionally check if it's iterable and not excluded type like string or bytes\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    # Exclude all other known primitives that are not allowed:\n    # We already excluded bool, bytes, str, int, float and None above\n    # Now fall back to checking if it's a sequence (but exclude Mapping or MappingView to prevent dict-like)\n    # But since many types are covered and we're allowing Iterator and views,\n    # restrict to iterable objects that implement __getitem__ or are recognized as sequence\n    # We want to avoid dict or Mapping types, so exclude these:\n    if isinstance(obj, collections.abc.Mapping) or isinstance(obj, collections.abc.MappingView):\n        return False\n\n    # To confirm it's list-like, check if it's iterable and has __getitem__ or is iterator\n    if hasattr(obj, '__getitem__') or isinstance(obj, collections.abc.Iterator):\n        return True\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    import collections\n    import collections.abc\n    import decimal\n\n    # Exclude types explicitly NOT considered list-like\n    if obj is None:\n        return False\n    if isinstance(obj, (bool, bytes, bytearray, str, memoryview)):\n        return False\n    if isinstance(obj, (dict,\n                        collections.ChainMap,\n                        collections.Counter,\n                        collections.OrderedDict,\n                        collections.UserDict,\n                        collections.UserString,\n                        collections.defaultdict,\n                        decimal.Decimal,\n                        float,\n                        int)):\n        return False\n\n    # Include types explicitly considered list-like\n    list_like_classes = (\n        collections.UserList,\n        collections.abc.Iterator,\n        collections.abc.KeysView,\n        collections.abc.ValuesView,\n        collections.deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n    if isinstance(obj, list_like_classes):\n        return True\n\n    # Also check if the object is iterable (duck-typing)\n    # but exclude strings, bytes and other non-list-like as above\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n"]}
{"task_id": 145, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    obj_cls = obj if isinstance(obj, type) else type(obj)\n    return any(issubclass(obj_cls, cls) for cls in classes)", "def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # Helper to safely get class of obj\n    try:\n        obj_cls = obj if isinstance(obj, type) else type(obj)\n    except Exception:\n        return False\n\n    return any(issubclass(obj_cls, cls) for cls in classes if isinstance(cls, type))", "def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        cls = obj if isinstance(obj, type) else type(obj)\n    except Exception:\n        return False\n    return any(issubclass(cls, c) for c in classes if isinstance(c, type))", "def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        cls = obj if isinstance(obj, type) else type(obj)\n        return any(issubclass(cls, c) for c in classes)\n    except TypeError:\n        return False", "def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        obj_class = obj if isinstance(obj, type) else obj.__class__\n    except AttributeError:\n        return False\n    return any(issubclass(obj_class, cls) for cls in classes)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    obj_cls = obj if isinstance(obj, type) else type(obj)\n    return any(issubclass(obj_cls, cls) for cls in classes)\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # Helper to safely get class of obj\n    try:\n        obj_cls = obj if isinstance(obj, type) else type(obj)\n    except Exception:\n        return False\n\n    return any(issubclass(obj_cls, cls) for cls in classes if isinstance(cls, type))\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        cls = obj if isinstance(obj, type) else type(obj)\n    except Exception:\n        return False\n    return any(issubclass(cls, c) for c in classes if isinstance(c, type))\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        cls = obj if isinstance(obj, type) else type(obj)\n        return any(issubclass(cls, c) for c in classes)\n    except TypeError:\n        return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        obj_class = obj if isinstance(obj, type) else obj.__class__\n    except AttributeError:\n        return False\n    return any(issubclass(obj_class, cls) for cls in classes)\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n"]}
