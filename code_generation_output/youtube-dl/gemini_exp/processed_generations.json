{"task_id": 146, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from math import ceil\n# The following imports are from the provided file_content and are implicitly available.\n# from .compat import compat_b64decode\n# from .utils import bytes_to_intlist, intlist_to_bytes\n\n# BLOCK_SIZE_BYTES is defined in the file_content.\n\n# Context functions used:\n# xor (Context Function 13)\nfrom youtube_dl.aes import xor\n\n# Functions from the file_content's existing code (like aes_ctr_decrypt)\n# that are assumed to be available in the current scope:\n# key_expansion: Used in aes_ctr_decrypt, so assumed to be defined or imported.\n# aes_decrypt: Counterpart to aes_encrypt (used in aes_ctr_decrypt), assumed to be defined or imported.\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    # For the first block, the IV acts as the previous ciphertext block (C_0)\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        # Get the current ciphertext block (C_i)\n        current_cipher_block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # AES decryption functions typically operate on full blocks.\n        # If the last block is shorter than BLOCK_SIZE_BYTES, pad it with zeros for decryption.\n        block_to_decrypt = list(current_cipher_block) # Create a mutable copy\n        if len(block_to_decrypt) < BLOCK_SIZE_BYTES:\n            block_to_decrypt += [0] * (BLOCK_SIZE_BYTES - len(block_to_decrypt))\n\n        # Perform AES decryption on the current cipher block: D_K(C_i)\n        # aes_decrypt is assumed to be available in this context, similar to aes_encrypt.\n        decrypted_aes_block = aes_decrypt(block_to_decrypt, expanded_key)\n\n        # In CBC mode decryption, the decrypted AES block is XORed with the previous ciphertext block (C_{i-1}).\n        # For the first block (i=0), C_{i-1} is the IV.\n        # P_i = D_K(C_i) XOR C_{i-1}\n        plaintext_block = xor(decrypted_aes_block, previous_cipher_block)\n\n        decrypted_data.extend(plaintext_block)\n\n        # Update the previous_cipher_block for the next iteration.\n        # The current actual ciphertext block (before padding) becomes the previous block for the next step.\n        previous_cipher_block = current_cipher_block\n\n    # After processing all blocks, trim any zero-padding that might have been added to the last block\n    # during the decryption process to match the original data length.\n    return decrypted_data[:len(data)]", "from math import ceil\n# The following imports are assumed to be available from the file content or are internal to the module.\n# from .compat import compat_b64decode\n# from .utils import bytes_to_intlist, intlist_to_bytes\n\n# The functions key_expansion, aes_decrypt, and xor are necessary for AES CBC decryption.\n# Based on the usage in aes_ctr_decrypt and the provided context functions (e.g., xor),\n# they are highly likely to be part of the 'youtube_dl.aes' module or available in the current scope.\n# To ensure the generated code runs independently, we explicitly import them.\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\n# BLOCK_SIZE_BYTES is defined in the provided file content.\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    # Calculate the number of blocks, rounding up for any partial last block.\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    # In CBC mode, the previous ciphertext block (or IV for the first block)\n    # is XORed with the decrypted current block.\n    prev_cipher_block = iv\n\n    for i in range(block_count):\n        # Extract the current ciphertext block.\n        current_cipher_block_original = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Create a mutable copy of the current block for potential padding.\n        # AES decryption (aes_decrypt) expects a full block. If the last block\n        # is partial, it needs to be padded (e.g., with zeros) for the decryption operation.\n        current_cipher_block_padded = list(current_cipher_block_original)\n        if len(current_cipher_block_padded) < BLOCK_SIZE_BYTES:\n            current_cipher_block_padded += [0] * (BLOCK_SIZE_BYTES - len(current_cipher_block_padded))\n\n        # Decrypt the (possibly padded) current ciphertext block using the expanded key.\n        decrypted_current_unxor = aes_decrypt(current_cipher_block_padded, expanded_key)\n\n        # XOR the decrypted block with the previous ciphertext block (or IV).\n        plaintext_block = xor(decrypted_current_unxor, prev_cipher_block)\n\n        # Add the resulting plaintext block to our list of decrypted data.\n        decrypted_data.extend(plaintext_block)\n\n        # For the next iteration, the *original* (unpadded) current ciphertext block\n        # becomes the 'previous_cipher_block'. This is crucial for the CBC mode chain.\n        prev_cipher_block = current_cipher_block_original\n\n    # Truncate the decrypted data to the original length of the input data.\n    # This handles any excess bytes that might have resulted from padding the last block.\n    return decrypted_data[:len(data)]", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv  # Initialize with IV for the first block\n\n    for i in range(block_count):\n        # Get the current ciphertext block\n        current_cipher_block_original = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Create a mutable copy and pad if it's the last partial block\n        block_to_decrypt = list(current_cipher_block_original)\n        if len(block_to_decrypt) < BLOCK_SIZE_BYTES:\n            block_to_decrypt += [0] * (BLOCK_SIZE_BYTES - len(block_to_decrypt))\n\n        # Decrypt the current block using AES in ECB mode conceptually\n        # Assumes aes_decrypt is available and functions similarly to aes_encrypt\n        decrypted_ecb_block = aes_decrypt(block_to_decrypt, expanded_key)\n\n        # XOR with the previous block (IV for the first block, previous ciphertext block otherwise)\n        current_plaintext_block = xor(decrypted_ecb_block, previous_block)\n\n        # Add the decrypted plaintext block to the result\n        decrypted_data.extend(current_plaintext_block)\n\n        # Update previous_block to the current original ciphertext block for the next iteration\n        previous_block = current_cipher_block_original\n\n    # Trim the result to the original data length, similar to aes_ctr_decrypt\n    # This handles any padding added for the last block during decryption\n    return decrypted_data[:len(data)]", "from math import ceil\n\n# Assuming key_expansion, aes_decrypt, and xor are available in the current\n# scope (e.g., defined in the same file or imported at the module level\n# from youtube_dl.aes as suggested by context functions and existing file content).\n# The file content indicates that BLOCK_SIZE_BYTES is already defined.\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_ciphertext_block = iv\n\n    for i in range(block_count):\n        # Get the current ciphertext block\n        current_ciphertext_block_raw = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Pad the current ciphertext block to BLOCK_SIZE_BYTES if it's the last partial block.\n        # aes_decrypt expects a full 16-byte block.\n        current_ciphertext_block_padded = list(current_ciphertext_block_raw)  # Create a mutable copy\n        current_ciphertext_block_padded.extend([0] * (BLOCK_SIZE_BYTES - len(current_ciphertext_block_padded)))\n\n        # Decrypt the current ciphertext block\n        decrypted_current_block = aes_decrypt(current_ciphertext_block_padded, expanded_key)\n\n        # XOR the decrypted block with the previous ciphertext block (or IV for the first block)\n        plaintext_block = xor(decrypted_current_block, previous_ciphertext_block)\n\n        decrypted_data.extend(plaintext_block)\n\n        # Update previous_ciphertext_block for the next iteration.\n        # This must be the actual (possibly padded) current ciphertext block, as it is C_i for the next P_i+1.\n        previous_ciphertext_block = current_ciphertext_block_padded\n\n    # Trim the result to the original data length, handling potential padding from the last block\n    return decrypted_data[:len(data)]", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# The following functions (xor, key_expansion, aes_decrypt, aes_encrypt)\n# are assumed to be available in the current module's scope,\n# as implied by their usage in `aes_ctr_decrypt` within the file content,\n# and by the context functions which provide building blocks for AES operations.\n# For example, `xor` is explicitly mentioned in Context 13 with `from youtube_dl.aes import xor`,\n# suggesting it's part of this module (assuming this file is youtube_dl/aes.py).\n# `key_expansion` and `aes_encrypt` are used in `aes_ctr_decrypt` without explicit imports,\n# implying they are defined within the same file/module. `aes_decrypt` is the inverse of `aes_encrypt`\n# and its inverse components are provided, so it's also assumed to be available.\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    # In CBC mode decryption, the IV (or previous ciphertext block) is XORed\n    # with the output of the block decryption.\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        # Extract the current ciphertext block\n        current_cipher_block_original = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Pad the current block with zeros if it's shorter than BLOCK_SIZE_BYTES.\n        # This handles cases where the input `data` might not be a perfect multiple of BLOCK_SIZE_BYTES.\n        # This mirrors the behavior seen in `aes_ctr_decrypt` for processing blocks.\n        current_cipher_block_padded = list(current_cipher_block_original)\n        current_cipher_block_padded.extend([0] * (BLOCK_SIZE_BYTES - len(current_cipher_block_padded)))\n\n        # Decrypt the current padded ciphertext block using the expanded key.\n        # `aes_decrypt` is assumed to be defined in the same module.\n        decrypted_block_raw = aes_decrypt(current_cipher_block_padded, expanded_key)\n\n        # XOR the raw decrypted block with the previous ciphertext block (or IV for the first block).\n        current_decrypted_block = xor(decrypted_block_raw, previous_cipher_block)\n\n        # Append the resulting plaintext block to the overall decrypted data.\n        decrypted_data.extend(current_decrypted_block)\n\n        # For the next iteration, the *original* current ciphertext block becomes\n        # the `previous_cipher_block` (C_{i-1} in the CBC formula).\n        previous_cipher_block = current_cipher_block_original\n\n    # Truncate the final decrypted data to the original input length.\n    # This removes any excess zeros added due to padding the last block.\n    return decrypted_data[:len(data)]"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n# The following imports are from the provided file_content and are implicitly available.\n# from .compat import compat_b64decode\n# from .utils import bytes_to_intlist, intlist_to_bytes\n\n# BLOCK_SIZE_BYTES is defined in the file_content.\n\n# Context functions used:\n# xor (Context Function 13)\nfrom youtube_dl.aes import xor\n\n# Functions from the file_content's existing code (like aes_ctr_decrypt)\n# that are assumed to be available in the current scope:\n# key_expansion: Used in aes_ctr_decrypt, so assumed to be defined or imported.\n# aes_decrypt: Counterpart to aes_encrypt (used in aes_ctr_decrypt), assumed to be defined or imported.\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    # For the first block, the IV acts as the previous ciphertext block (C_0)\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        # Get the current ciphertext block (C_i)\n        current_cipher_block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # AES decryption functions typically operate on full blocks.\n        # If the last block is shorter than BLOCK_SIZE_BYTES, pad it with zeros for decryption.\n        block_to_decrypt = list(current_cipher_block) # Create a mutable copy\n        if len(block_to_decrypt) < BLOCK_SIZE_BYTES:\n            block_to_decrypt += [0] * (BLOCK_SIZE_BYTES - len(block_to_decrypt))\n\n        # Perform AES decryption on the current cipher block: D_K(C_i)\n        # aes_decrypt is assumed to be available in this context, similar to aes_encrypt.\n        decrypted_aes_block = aes_decrypt(block_to_decrypt, expanded_key)\n\n        # In CBC mode decryption, the decrypted AES block is XORed with the previous ciphertext block (C_{i-1}).\n        # For the first block (i=0), C_{i-1} is the IV.\n        # P_i = D_K(C_i) XOR C_{i-1}\n        plaintext_block = xor(decrypted_aes_block, previous_cipher_block)\n\n        decrypted_data.extend(plaintext_block)\n\n        # Update the previous_cipher_block for the next iteration.\n        # The current actual ciphertext block (before padding) becomes the previous block for the next step.\n        previous_cipher_block = current_cipher_block\n\n    # After processing all blocks, trim any zero-padding that might have been added to the last block\n    # during the decryption process to match the original data length.\n    return decrypted_data[:len(data)]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n# The following imports are assumed to be available from the file content or are internal to the module.\n# from .compat import compat_b64decode\n# from .utils import bytes_to_intlist, intlist_to_bytes\n\n# The functions key_expansion, aes_decrypt, and xor are necessary for AES CBC decryption.\n# Based on the usage in aes_ctr_decrypt and the provided context functions (e.g., xor),\n# they are highly likely to be part of the 'youtube_dl.aes' module or available in the current scope.\n# To ensure the generated code runs independently, we explicitly import them.\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\n# BLOCK_SIZE_BYTES is defined in the provided file content.\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    # Calculate the number of blocks, rounding up for any partial last block.\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    # In CBC mode, the previous ciphertext block (or IV for the first block)\n    # is XORed with the decrypted current block.\n    prev_cipher_block = iv\n\n    for i in range(block_count):\n        # Extract the current ciphertext block.\n        current_cipher_block_original = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Create a mutable copy of the current block for potential padding.\n        # AES decryption (aes_decrypt) expects a full block. If the last block\n        # is partial, it needs to be padded (e.g., with zeros) for the decryption operation.\n        current_cipher_block_padded = list(current_cipher_block_original)\n        if len(current_cipher_block_padded) < BLOCK_SIZE_BYTES:\n            current_cipher_block_padded += [0] * (BLOCK_SIZE_BYTES - len(current_cipher_block_padded))\n\n        # Decrypt the (possibly padded) current ciphertext block using the expanded key.\n        decrypted_current_unxor = aes_decrypt(current_cipher_block_padded, expanded_key)\n\n        # XOR the decrypted block with the previous ciphertext block (or IV).\n        plaintext_block = xor(decrypted_current_unxor, prev_cipher_block)\n\n        # Add the resulting plaintext block to our list of decrypted data.\n        decrypted_data.extend(plaintext_block)\n\n        # For the next iteration, the *original* (unpadded) current ciphertext block\n        # becomes the 'previous_cipher_block'. This is crucial for the CBC mode chain.\n        prev_cipher_block = current_cipher_block_original\n\n    # Truncate the decrypted data to the original length of the input data.\n    # This handles any excess bytes that might have resulted from padding the last block.\n    return decrypted_data[:len(data)]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv  # Initialize with IV for the first block\n\n    for i in range(block_count):\n        # Get the current ciphertext block\n        current_cipher_block_original = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Create a mutable copy and pad if it's the last partial block\n        block_to_decrypt = list(current_cipher_block_original)\n        if len(block_to_decrypt) < BLOCK_SIZE_BYTES:\n            block_to_decrypt += [0] * (BLOCK_SIZE_BYTES - len(block_to_decrypt))\n\n        # Decrypt the current block using AES in ECB mode conceptually\n        # Assumes aes_decrypt is available and functions similarly to aes_encrypt\n        decrypted_ecb_block = aes_decrypt(block_to_decrypt, expanded_key)\n\n        # XOR with the previous block (IV for the first block, previous ciphertext block otherwise)\n        current_plaintext_block = xor(decrypted_ecb_block, previous_block)\n\n        # Add the decrypted plaintext block to the result\n        decrypted_data.extend(current_plaintext_block)\n\n        # Update previous_block to the current original ciphertext block for the next iteration\n        previous_block = current_cipher_block_original\n\n    # Trim the result to the original data length, similar to aes_ctr_decrypt\n    # This handles any padding added for the last block during decryption\n    return decrypted_data[:len(data)]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n\n# Assuming key_expansion, aes_decrypt, and xor are available in the current\n# scope (e.g., defined in the same file or imported at the module level\n# from youtube_dl.aes as suggested by context functions and existing file content).\n# The file content indicates that BLOCK_SIZE_BYTES is already defined.\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_ciphertext_block = iv\n\n    for i in range(block_count):\n        # Get the current ciphertext block\n        current_ciphertext_block_raw = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Pad the current ciphertext block to BLOCK_SIZE_BYTES if it's the last partial block.\n        # aes_decrypt expects a full 16-byte block.\n        current_ciphertext_block_padded = list(current_ciphertext_block_raw)  # Create a mutable copy\n        current_ciphertext_block_padded.extend([0] * (BLOCK_SIZE_BYTES - len(current_ciphertext_block_padded)))\n\n        # Decrypt the current ciphertext block\n        decrypted_current_block = aes_decrypt(current_ciphertext_block_padded, expanded_key)\n\n        # XOR the decrypted block with the previous ciphertext block (or IV for the first block)\n        plaintext_block = xor(decrypted_current_block, previous_ciphertext_block)\n\n        decrypted_data.extend(plaintext_block)\n\n        # Update previous_ciphertext_block for the next iteration.\n        # This must be the actual (possibly padded) current ciphertext block, as it is C_i for the next P_i+1.\n        previous_ciphertext_block = current_ciphertext_block_padded\n\n    # Trim the result to the original data length, handling potential padding from the last block\n    return decrypted_data[:len(data)]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# The following functions (xor, key_expansion, aes_decrypt, aes_encrypt)\n# are assumed to be available in the current module's scope,\n# as implied by their usage in `aes_ctr_decrypt` within the file content,\n# and by the context functions which provide building blocks for AES operations.\n# For example, `xor` is explicitly mentioned in Context 13 with `from youtube_dl.aes import xor`,\n# suggesting it's part of this module (assuming this file is youtube_dl/aes.py).\n# `key_expansion` and `aes_encrypt` are used in `aes_ctr_decrypt` without explicit imports,\n# implying they are defined within the same file/module. `aes_decrypt` is the inverse of `aes_encrypt`\n# and its inverse components are provided, so it's also assumed to be available.\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    # In CBC mode decryption, the IV (or previous ciphertext block) is XORed\n    # with the output of the block decryption.\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        # Extract the current ciphertext block\n        current_cipher_block_original = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # Pad the current block with zeros if it's shorter than BLOCK_SIZE_BYTES.\n        # This handles cases where the input `data` might not be a perfect multiple of BLOCK_SIZE_BYTES.\n        # This mirrors the behavior seen in `aes_ctr_decrypt` for processing blocks.\n        current_cipher_block_padded = list(current_cipher_block_original)\n        current_cipher_block_padded.extend([0] * (BLOCK_SIZE_BYTES - len(current_cipher_block_padded)))\n\n        # Decrypt the current padded ciphertext block using the expanded key.\n        # `aes_decrypt` is assumed to be defined in the same module.\n        decrypted_block_raw = aes_decrypt(current_cipher_block_padded, expanded_key)\n\n        # XOR the raw decrypted block with the previous ciphertext block (or IV for the first block).\n        current_decrypted_block = xor(decrypted_block_raw, previous_cipher_block)\n\n        # Append the resulting plaintext block to the overall decrypted data.\n        decrypted_data.extend(current_decrypted_block)\n\n        # For the next iteration, the *original* current ciphertext block becomes\n        # the `previous_cipher_block` (C_{i-1} in the CBC formula).\n        previous_cipher_block = current_cipher_block_original\n\n    # Truncate the final decrypted data to the original input length.\n    # This removes any excess zeros added due to padding the last block.\n    return decrypted_data[:len(data)]\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n"]}
{"task_id": 147, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    # Calculate padding length\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    # Create padding bytes, each with the value of padding_len\n    padding_bytes = [padding_len] * padding_len\n    # Append padding to the data\n    padded_data = data + padding_bytes\n\n    expanded_key = key_expansion(key)\n    block_count = int(math.ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv  # The IV acts as the previous ciphertext block for the first block\n\n    for i in range(block_count):\n        # Extract the current plaintext block\n        current_plaintext_block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR the current plaintext block with the previous cipher block (or IV)\n        xor_result = xor(current_plaintext_block, previous_cipher_block)\n\n        # Encrypt the XOR result\n        current_cipher_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the current cipher block to the total encrypted data\n        encrypted_data += current_cipher_block\n\n        # The current cipher block becomes the previous cipher block for the next iteration\n        previous_cipher_block = current_cipher_block\n\n    return encrypted_data", "from math import ceil\n\n# BLOCK_SIZE_BYTES is defined in the file content\n# key_expansion, aes_encrypt, and xor are assumed to be available in the current scope\n# based on their usage in other functions within the file content.\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # 1. Apply PKCS#7 Padding\n    # Calculate padding length: BLOCK_SIZE_BYTES - (length_of_data % BLOCK_SIZE_BYTES)\n    # If data length is already a multiple of BLOCK_SIZE_BYTES, padding length should be BLOCK_SIZE_BYTES\n    # (i.e., a full block of padding).\n    padding_length = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data + [padding_length] * padding_length\n\n    # 2. Expand the key to generate round keys\n    expanded_key = key_expansion(key)\n\n    # 3. Initialize the list to store encrypted blocks and the previous ciphertext block\n    encrypted_data = []\n    # In CBC mode, the IV is used as the 'previous_cipher_block' for the first plaintext block\n    previous_cipher_block = iv\n\n    # 4. Process the padded data block by block\n    block_count = len(padded_data) // BLOCK_SIZE_BYTES\n    for i in range(block_count):\n        # Extract the current 16-byte plaintext block\n        current_plaintext_block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR the current plaintext block with the previous ciphertext block\n        # (or IV for the first block)\n        xor_result = xor(current_plaintext_block, previous_cipher_block)\n\n        # Encrypt the result of the XOR operation using AES\n        encrypted_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the newly encrypted block to the total encrypted data\n        encrypted_data.extend(encrypted_block)\n\n        # The current encrypted block becomes the 'previous_cipher_block' for the next iteration\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# Assuming BLOCK_SIZE_BYTES, key_expansion, aes_encrypt, and xor are defined or imported\n# within the same module scope, as implied by the provided file content and context functions.\n# For example, key_expansion is Context Function 9 and aes_encrypt is Context Function 10.\n# The 'xor' function is used in the existing aes_cbc_decrypt and aes_ctr_decrypt.\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # 1. Apply PKCS#7 padding to the cleartext data\n    # Calculate the number of padding bytes needed.\n    # If the data length is already a multiple of BLOCK_SIZE_BYTES,\n    # a full block of padding (BLOCK_SIZE_BYTES bytes, each equal to BLOCK_SIZE_BYTES)\n    # must be added according to PKCS#7.\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    if padding_len == 0:\n        padding_len = BLOCK_SIZE_BYTES\n\n    # Create the padding bytes, each equal to padding_len\n    padding_bytes = [padding_len] * padding_len\n\n    # Append padding to the original data. Ensure data is mutable (e.g., a list).\n    padded_data = list(data) + padding_bytes\n\n    # 2. Generate the expanded key from the cipher key\n    # (Context Function 9: key_expansion)\n    expanded_key = key_expansion(key)\n\n    # 3. Initialize variables for CBC mode encryption\n    encrypted_data = []\n    # The IV (Initialization Vector) serves as the initial \"previous_cipher_block\" (C_0)\n    previous_cipher_block = iv\n\n    # 4. Process the padded data block by block\n    # The number of blocks is the total length of padded data divided by block size\n    block_count = len(padded_data) // BLOCK_SIZE_BYTES\n\n    for i in range(block_count):\n        # Extract the current plaintext block\n        plaintext_block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n\n        # In CBC mode, the current plaintext block is XORed with the\n        # ciphertext block from the previous step (or IV for the first block).\n        xor_result = xor(plaintext_block, previous_cipher_block)\n\n        # Encrypt the result of the XOR operation using AES\n        # (Context Function 10: aes_encrypt)\n        cipher_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the newly generated ciphertext block to the overall encrypted data\n        encrypted_data.extend(cipher_block)\n\n        # The current ciphertext block becomes the \"previous_cipher_block\"\n        # for the next iteration (C_i becomes C_{i-1} for the next block)\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "from math import ceil\n\n# Assuming these are available in the same module scope, as implied by the file content\n# from .compat import compat_b64decode\n# from .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n# Helper function for element-wise XOR, as implied by usage in other functions.\ndef xor(a, b):\n    \"\"\"\n    Performs element-wise XOR on two lists of integers.\n    Assumes both lists are of the same length.\n    \"\"\"\n    return [x ^ y for x, y in zip(a, b)]\n\n# Context functions (mocked for generation, actual implementations from context)\n# The file content indicates these are available in the same module without explicit import.\n# def key_expansion(data): ... (from Context Function 9)\n# def aes_encrypt(data, expanded_key): ... (from Context Function 10)\n\n# The following functions (key_expansion, aes_encrypt) are assumed to be in the\n# same scope, as they are called directly in the file content provided\n# without explicit imports. Their actual implementations from context are:\n# (These are not to be copied into the output, just for conceptual clarity)\n# def key_expansion(data): ... (Implementation from Context Function 9)\n# def aes_encrypt(data, expanded_key): ... (Implementation from Context Function 10)\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    # Calculate the number of bytes needed for padding.\n    # If len(data) is already a multiple of BLOCK_SIZE_BYTES, we add a full block of padding.\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    \n    # Create the padded data list. The value of each padding byte is 'padding_len'.\n    data_padded = list(data) + [padding_len] * padding_len\n\n    # Generate the expanded key schedule\n    expanded_key = key_expansion(key)\n\n    # Calculate the total number of blocks after padding\n    block_count = len(data_padded) // BLOCK_SIZE_BYTES\n\n    encrypted_data = []\n    # Initialize the previous_cipher_block with the IV for the first block\n    previous_cipher_block = list(iv)  # Create a copy to avoid modifying the original IV\n\n    # Iterate through each block of the padded data\n    for i in range(block_count):\n        # Extract the current plaintext block\n        current_plaintext_block = data_padded[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # CBC mode: Plaintext block is XORed with the previous ciphertext block (or IV)\n        block_after_xor = xor(current_plaintext_block, previous_cipher_block)\n\n        # Encrypt the XORed block using AES\n        encrypted_block = aes_encrypt(block_after_xor, expanded_key)\n\n        # Append the encrypted block to the result\n        encrypted_data.extend(encrypted_block)\n\n        # The current encrypted block becomes the previous_cipher_block for the next iteration\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = list(data) + [padding_len] * padding_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv  # IV is used as the previous_cipher_block for the first block\n\n    for i in range(block_count):\n        current_block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR current plaintext block with the previous ciphertext block (or IV for the first block)\n        xor_result = xor(current_block, previous_cipher_block)\n\n        # Encrypt the XOR result\n        cipher_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the resulting ciphertext block\n        encrypted_data.extend(cipher_block)\n\n        # The current ciphertext block becomes the previous_cipher_block for the next iteration\n        previous_cipher_block = cipher_block\n\n    return encrypted_data"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    # Calculate padding length\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    # Create padding bytes, each with the value of padding_len\n    padding_bytes = [padding_len] * padding_len\n    # Append padding to the data\n    padded_data = data + padding_bytes\n\n    expanded_key = key_expansion(key)\n    block_count = int(math.ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv  # The IV acts as the previous ciphertext block for the first block\n\n    for i in range(block_count):\n        # Extract the current plaintext block\n        current_plaintext_block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR the current plaintext block with the previous cipher block (or IV)\n        xor_result = xor(current_plaintext_block, previous_cipher_block)\n\n        # Encrypt the XOR result\n        current_cipher_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the current cipher block to the total encrypted data\n        encrypted_data += current_cipher_block\n\n        # The current cipher block becomes the previous cipher block for the next iteration\n        previous_cipher_block = current_cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n\n# BLOCK_SIZE_BYTES is defined in the file content\n# key_expansion, aes_encrypt, and xor are assumed to be available in the current scope\n# based on their usage in other functions within the file content.\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # 1. Apply PKCS#7 Padding\n    # Calculate padding length: BLOCK_SIZE_BYTES - (length_of_data % BLOCK_SIZE_BYTES)\n    # If data length is already a multiple of BLOCK_SIZE_BYTES, padding length should be BLOCK_SIZE_BYTES\n    # (i.e., a full block of padding).\n    padding_length = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data + [padding_length] * padding_length\n\n    # 2. Expand the key to generate round keys\n    expanded_key = key_expansion(key)\n\n    # 3. Initialize the list to store encrypted blocks and the previous ciphertext block\n    encrypted_data = []\n    # In CBC mode, the IV is used as the 'previous_cipher_block' for the first plaintext block\n    previous_cipher_block = iv\n\n    # 4. Process the padded data block by block\n    block_count = len(padded_data) // BLOCK_SIZE_BYTES\n    for i in range(block_count):\n        # Extract the current 16-byte plaintext block\n        current_plaintext_block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR the current plaintext block with the previous ciphertext block\n        # (or IV for the first block)\n        xor_result = xor(current_plaintext_block, previous_cipher_block)\n\n        # Encrypt the result of the XOR operation using AES\n        encrypted_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the newly encrypted block to the total encrypted data\n        encrypted_data.extend(encrypted_block)\n\n        # The current encrypted block becomes the 'previous_cipher_block' for the next iteration\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# Assuming BLOCK_SIZE_BYTES, key_expansion, aes_encrypt, and xor are defined or imported\n# within the same module scope, as implied by the provided file content and context functions.\n# For example, key_expansion is Context Function 9 and aes_encrypt is Context Function 10.\n# The 'xor' function is used in the existing aes_cbc_decrypt and aes_ctr_decrypt.\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # 1. Apply PKCS#7 padding to the cleartext data\n    # Calculate the number of padding bytes needed.\n    # If the data length is already a multiple of BLOCK_SIZE_BYTES,\n    # a full block of padding (BLOCK_SIZE_BYTES bytes, each equal to BLOCK_SIZE_BYTES)\n    # must be added according to PKCS#7.\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    if padding_len == 0:\n        padding_len = BLOCK_SIZE_BYTES\n\n    # Create the padding bytes, each equal to padding_len\n    padding_bytes = [padding_len] * padding_len\n\n    # Append padding to the original data. Ensure data is mutable (e.g., a list).\n    padded_data = list(data) + padding_bytes\n\n    # 2. Generate the expanded key from the cipher key\n    # (Context Function 9: key_expansion)\n    expanded_key = key_expansion(key)\n\n    # 3. Initialize variables for CBC mode encryption\n    encrypted_data = []\n    # The IV (Initialization Vector) serves as the initial \"previous_cipher_block\" (C_0)\n    previous_cipher_block = iv\n\n    # 4. Process the padded data block by block\n    # The number of blocks is the total length of padded data divided by block size\n    block_count = len(padded_data) // BLOCK_SIZE_BYTES\n\n    for i in range(block_count):\n        # Extract the current plaintext block\n        plaintext_block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n\n        # In CBC mode, the current plaintext block is XORed with the\n        # ciphertext block from the previous step (or IV for the first block).\n        xor_result = xor(plaintext_block, previous_cipher_block)\n\n        # Encrypt the result of the XOR operation using AES\n        # (Context Function 10: aes_encrypt)\n        cipher_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the newly generated ciphertext block to the overall encrypted data\n        encrypted_data.extend(cipher_block)\n\n        # The current ciphertext block becomes the \"previous_cipher_block\"\n        # for the next iteration (C_i becomes C_{i-1} for the next block)\n        previous_cipher_block = cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom math import ceil\n\n# Assuming these are available in the same module scope, as implied by the file content\n# from .compat import compat_b64decode\n# from .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n# Helper function for element-wise XOR, as implied by usage in other functions.\ndef xor(a, b):\n    \"\"\"\n    Performs element-wise XOR on two lists of integers.\n    Assumes both lists are of the same length.\n    \"\"\"\n    return [x ^ y for x, y in zip(a, b)]\n\n# Context functions (mocked for generation, actual implementations from context)\n# The file content indicates these are available in the same module without explicit import.\n# def key_expansion(data): ... (from Context Function 9)\n# def aes_encrypt(data, expanded_key): ... (from Context Function 10)\n\n# The following functions (key_expansion, aes_encrypt) are assumed to be in the\n# same scope, as they are called directly in the file content provided\n# without explicit imports. Their actual implementations from context are:\n# (These are not to be copied into the output, just for conceptual clarity)\n# def key_expansion(data): ... (Implementation from Context Function 9)\n# def aes_encrypt(data, expanded_key): ... (Implementation from Context Function 10)\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    # Calculate the number of bytes needed for padding.\n    # If len(data) is already a multiple of BLOCK_SIZE_BYTES, we add a full block of padding.\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    \n    # Create the padded data list. The value of each padding byte is 'padding_len'.\n    data_padded = list(data) + [padding_len] * padding_len\n\n    # Generate the expanded key schedule\n    expanded_key = key_expansion(key)\n\n    # Calculate the total number of blocks after padding\n    block_count = len(data_padded) // BLOCK_SIZE_BYTES\n\n    encrypted_data = []\n    # Initialize the previous_cipher_block with the IV for the first block\n    previous_cipher_block = list(iv)  # Create a copy to avoid modifying the original IV\n\n    # Iterate through each block of the padded data\n    for i in range(block_count):\n        # Extract the current plaintext block\n        current_plaintext_block = data_padded[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # CBC mode: Plaintext block is XORed with the previous ciphertext block (or IV)\n        block_after_xor = xor(current_plaintext_block, previous_cipher_block)\n\n        # Encrypt the XORed block using AES\n        encrypted_block = aes_encrypt(block_after_xor, expanded_key)\n\n        # Append the encrypted block to the result\n        encrypted_data.extend(encrypted_block)\n\n        # The current encrypted block becomes the previous_cipher_block for the next iteration\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = list(data) + [padding_len] * padding_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv  # IV is used as the previous_cipher_block for the first block\n\n    for i in range(block_count):\n        current_block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR current plaintext block with the previous ciphertext block (or IV for the first block)\n        xor_result = xor(current_block, previous_cipher_block)\n\n        # Encrypt the XOR result\n        cipher_block = aes_encrypt(xor_result, expanded_key)\n\n        # Append the resulting ciphertext block\n        encrypted_data.extend(cipher_block)\n\n        # The current ciphertext block becomes the previous_cipher_block for the next iteration\n        previous_cipher_block = cipher_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n"]}
{"task_id": 148, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n# Necessary imports for key_expansion logic, based on context functions\nfrom youtube_dl.aes import sub_bytes, rotate\n# xor is already used in the file content above this function definition, so it's in scope.\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n# AES Round Constants (Rcon)\n_RCON = [\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n]\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    Nk = len(data) // 4  # Number of 32-bit words in the cipher key\n    if Nk == 4:  # 128-bit key\n        Nr = 10\n    elif Nk == 6:  # 192-bit key\n        Nr = 12\n    elif Nk == 8:  # 256-bit key\n        Nr = 14\n    else:\n        raise ValueError('Invalid key size: AES key must be 16, 24, or 32 bytes (128, 192, or 256 bits)')\n\n    expanded_key = list(data)  # Initialize expanded key with the original key\n    Nb = 4  # Number of columns (words) in the state, always 4 for AES\n\n    # Generate the remaining words of the expanded key\n    # Total words needed: Nb * (Nr + 1)\n    # The loop starts from Nk because the first Nk words are already in expanded_key\n    for i in range(Nk, Nb * (Nr + 1)):\n        # Get the word at index (i-1)\n        temp_word = expanded_key[(i - 1) * Nb : i * Nb]\n\n        # Apply transformations based on index i\n        if i % Nk == 0:\n            # RotWord: Cyclically shift left by one byte\n            temp_word = rotate(temp_word)\n            # SubWord: Apply S-box substitution to each byte\n            temp_word = sub_bytes(temp_word)\n            # XOR with Rcon\n            # The Rcon value corresponds to the current round, which is (i // Nk)\n            # Since _RCON is 0-indexed, and the first Rcon is for i=Nk (round 1), use i // Nk - 1\n            rcon_value = _RCON[i // Nk - 1]\n            rcon_word = [rcon_value, 0, 0, 0]  # Rcon is added to the first byte of the word\n            temp_word = xor(temp_word, rcon_word)\n        elif Nk > 6 and i % Nk == 4:\n            # Specific rule for AES-256 (Nk=8): apply SubWord after every 4th word\n            temp_word = sub_bytes(temp_word)\n\n        # XOR temp_word with the word Nk steps earlier\n        previous_Nk_word = expanded_key[(i - Nk) * Nb : (i - Nk + 1) * Nb]\n        new_word = xor(previous_Nk_word, temp_word)\n        expanded_key.extend(new_word)  # Append the new 4-byte word to the expanded key\n\n    return expanded_key", "# S-Box (Substitution Box) - Standard AES S-Box\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x47, 0xc8, 0xf4, 0x00, 0xea, 0x2f, 0x81, 0x07, 0xc2, 0x05, 0x6e, 0x94, 0xd5, 0x01\n]\n\n# Round Constants for AES Key Expansion\nRcon = [\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36\n]\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_bytes_len = len(data)\n\n    # Determine Nk (number of 32-bit words in cipher key) and Nr (number of rounds)\n    if key_bytes_len == 16:  # 128-bit key\n        Nk = 4\n        Nr = 10\n    elif key_bytes_len == 24:  # 192-bit key\n        Nk = 6\n        Nr = 12\n    elif key_bytes_len == 32:  # 256-bit key\n        Nk = 8\n        Nr = 14\n    else:\n        raise ValueError('Unsupported key length: must be 16, 24, or 32 bytes')\n\n    # Initialize the expanded key with the input key\n    expanded_key = list(data)\n\n    # Generate the remaining words of the key schedule\n    # The total number of words in the key schedule is Nb * (Nr + 1) = 4 * (Nr + 1)\n    # Each word is 4 bytes.\n    for i in range(Nk, 4 * (Nr + 1)):\n        # Get the previous word\n        temp_word = expanded_key[(i - 1) * 4 : i * 4]\n\n        # Apply transformations for the first word of each new key block\n        if i % Nk == 0:\n            # 1. RotWord: Cyclic shift left by one byte\n            temp_word = rotate(temp_word)\n            # 2. SubWord: Apply SBOX substitution to each byte\n            temp_word = sub_bytes(temp_word) # sub_bytes is Context 4\n            # 3. XOR with Rcon[i/Nk - 1]\n            # Rcon is a single byte, so we XOR it with the first byte of the word\n            rcon_val = Rcon[i // Nk - 1]\n            temp_word = xor(temp_word, [rcon_val, 0, 0, 0]) # xor is Context 6\n        # Specific transformation for 256-bit keys\n        elif Nk > 6 and i % Nk == 4: # This condition is specific to 256-bit (Nk=8) keys\n            # SubWord: Apply SBOX substitution to each byte\n            temp_word = sub_bytes(temp_word)\n\n        # XOR with the word Nk positions back\n        # This combines the transformed temp_word with a word from the previous block\n        previous_block_word = expanded_key[(i - Nk) * 4 : (i - Nk + 1) * 4]\n        current_word = xor(temp_word, previous_block_word)\n\n        # Append the new word (4 bytes) to the expanded key\n        expanded_key.extend(current_word)\n\n    return expanded_key", "# Constants for AES Key Expansion (standard S-Box and Rcon values)\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\nRcon = [\n    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\n    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,\n]\n\n# Context Functions that need to be imported (as they are external to this file content)\n# We assume they are available in the 'youtube_dl.aes' module.\n# The prompt implies these are 'context functions' and should be used,\n# and for independent execution, they must be imported.\n# Note: In a real 'youtube_dl' project, these might be in the same file or imported differently.\n# This approach adheres to \"Include all necessary import statements at the top so the code runs independently.\"\nfrom youtube_dl.aes import sub_bytes\nfrom youtube_dl.aes import xor\nfrom youtube_dl.aes import rotate\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    Nk = len(data) // 4  # Number of 32-bit words in the cipher key\n    Nb = 4               # Number of columns (32-bit words) in the state, always 4 for AES\n\n    # Determine Nr (number of rounds) based on key length\n    if Nk == 4:  # 128-bit key\n        Nr = 10\n    elif Nk == 6:  # 192-bit key\n        Nr = 12\n    elif Nk == 8:  # 256-bit key\n        Nr = 14\n    else:\n        raise ValueError('Invalid key length: %d bytes. Key must be 16, 24, or 32 bytes.' % len(data))\n\n    # Calculate total number of words in the expanded key\n    num_expanded_words = Nb * (Nr + 1)\n\n    key_schedule = list(data)  # Initialize key_schedule with the cipher key\n\n    # Generate the rest of the expanded key\n    for i in range(Nk, num_expanded_words):\n        # temp_word is the previous word in the key schedule (w[i-1])\n        temp_word = key_schedule[(i - 1) * 4 : i * 4]\n\n        if i % Nk == 0:\n            # Apply RotWord (cyclic shift left by one byte)\n            temp_word = rotate(temp_word)\n            # Apply SubWord (byte substitution using SBOX)\n            temp_word = sub_bytes(temp_word)\n            # XOR with Rcon\n            temp_word[0] = temp_word[0] ^ Rcon[i // Nk - 1]\n        elif Nk == 8 and i % Nk == 4:\n            # Special case for 256-bit key (Nk = 8)\n            # Apply SubWord to the 4th word of the new block (words 4, 12, 20...)\n            temp_word = sub_bytes(temp_word)\n\n        # XOR temp_word with the word Nk positions before (w[i-Nk])\n        prev_Nk_word = key_schedule[(i - Nk) * 4 : (i - Nk + 1) * 4]\n        new_word = xor(prev_Nk_word, temp_word)\n\n        # Extend the key schedule with the newly generated word\n        key_schedule.extend(new_word)\n\n    return key_schedule", "from math import ceil # Already present in file content\n# from .compat import compat_b64decode # Already present in file content\n# from .utils import bytes_to_intlist, intlist_to_bytes # Already present in file content\n\n# BLOCK_SIZE_BYTES is already defined in the file content\n\n# Assume sub_bytes, rotate, and xor are available globally within this module\n# given their context descriptions and usage in existing functions.\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Standard AES Round Constants (Rcon)\n    Rcon = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\n    ]\n\n    Nk = len(data) // 4  # Number of 32-bit words in the cipher key\n    Nb = 4               # Number of 32-bit words in the state (fixed for AES)\n\n    # Determine the number of rounds (Nr) based on key length\n    if Nk == 4:  # 128-bit key\n        Nr = 10\n    elif Nk == 6:  # 192-bit key\n        Nr = 12\n    elif Nk == 8:  # 256-bit key\n        Nr = 14\n    else:\n        raise ValueError('Invalid AES key length: must be 16, 24, or 32 bytes')\n\n    # Initialize the expanded key `w` with the input cipher key\n    # `w` will be a flat list of bytes (integers)\n    w = list(data)\n\n    # Generate the remaining words of the key schedule\n    for i in range(Nk, Nb * (Nr + 1)):\n        # Get the previous word (4 bytes)\n        temp_word = w[(i - 1) * 4 : i * 4]\n\n        # Apply transformations based on key schedule rules\n        if i % Nk == 0:\n            # RotWord: Cyclic shift left by one byte\n            temp_word = rotate(temp_word)\n            # SubWord: Byte substitution using S-Box\n            temp_word = sub_bytes(temp_word)\n            # XOR with Rcon\n            rcon_value = Rcon[(i // Nk) - 1]\n            rcon_word = [rcon_value, 0, 0, 0] # Rcon values apply to the first byte of the word\n            temp_word = xor(temp_word, rcon_word)\n        elif Nk > 6 and i % Nk == 4:\n            # For 256-bit keys, apply SubWord every 4th word after the Nk multiple\n            temp_word = sub_bytes(temp_word)\n\n        # Main key expansion step: XOR with the word Nk positions earlier\n        prev_Nk_word = w[(i - Nk) * 4 : (i - Nk + 1) * 4]\n        new_word = xor(prev_Nk_word, temp_word)\n\n        # Append the new 4-byte word to the expanded key\n        w.extend(new_word)\n\n    return w", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n# Imports from context functions provided\n# These functions are part of the youtube_dl.aes module according to their import statements.\nfrom youtube_dl.aes import sub_bytes, xor, rotate\n\n# SBOX and Rcon tables are standard constants for AES key expansion.\n# Since the `sub_bytes` context function's implementation refers to SBOX,\n# and Rcon is a fundamental part of AES key expansion, they are defined here.\n# They are typically module-level constants in a cryptographic implementation.\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x8f, 0x4a, 0x1f, 0x6a, 0x42, 0x4d, 0x23, 0x59, 0x34, 0xc8, 0xda, 0xfe, 0xba, 0x20\n]\n\nRcon = [\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36\n]\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Initialize the expanded key with the original key\n    expanded_key = list(data)\n\n    # Nk: Number of 32-bit words in the cipher key (key length / 4)\n    Nk = len(data) // 4\n\n    # Nr: Number of rounds based on key size\n    # 128-bit key (Nk=4) -> 10 rounds\n    # 192-bit key (Nk=6) -> 12 rounds\n    # 256-bit key (Nk=8) -> 14 rounds\n    Nr = {\n        4: 10,\n        6: 12,\n        8: 14\n    }.get(Nk)\n\n    if Nr is None:\n        raise ValueError('Invalid key length. Must be 16, 24, or 32 bytes.')\n\n    # Nb: Number of 32-bit words in a block (always 4 for AES)\n    Nb = BLOCK_SIZE_BYTES // 4  # BLOCK_SIZE_BYTES is 16\n\n    # Total words in the key schedule: Nb * (Nr + 1)\n    KEY_SCHEDULE_WORDS = Nb * (Nr + 1)\n\n    # Generate the remaining words of the key schedule\n    for i in range(Nk, KEY_SCHEDULE_WORDS):\n        # Temp is the last generated word (W[i-1])\n        temp = expanded_key[4 * (i - 1): 4 * (i - 1) + 4]\n\n        # Apply transformations based on the word's position\n        if i % Nk == 0:\n            # For the first word of a new Nk-word block (or start of a round)\n            # 1. Rotate the word\n            temp = rotate(temp)\n            # 2. Substitute bytes using SBOX\n            temp = sub_bytes(temp)\n            # 3. XOR with Rcon (Round Constant)\n            # Rcon[i // Nk - 1] because Rcon starts from index 0 for the first round,\n            # and i // Nk gives 1 for the first block (i = Nk), 2 for the second (i = 2*Nk), etc.\n            temp = xor(temp, [Rcon[i // Nk - 1], 0, 0, 0])\n        elif Nk == 8 and i % Nk == 4:\n            # For 256-bit key, an additional SubBytes is applied at this specific position\n            temp = sub_bytes(temp)\n\n        # XOR the current temp word with the word Nk positions back (W[i-Nk])\n        prev_Nk_word = expanded_key[4 * (i - Nk): 4 * (i - Nk) + 4]\n        new_word = xor(prev_Nk_word, temp)\n\n        # Append the newly generated word to the expanded key\n        expanded_key.extend(new_word)\n\n    return expanded_key"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n# Necessary imports for key_expansion logic, based on context functions\nfrom youtube_dl.aes import sub_bytes, rotate\n# xor is already used in the file content above this function definition, so it's in scope.\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n# AES Round Constants (Rcon)\n_RCON = [\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n]\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    Nk = len(data) // 4  # Number of 32-bit words in the cipher key\n    if Nk == 4:  # 128-bit key\n        Nr = 10\n    elif Nk == 6:  # 192-bit key\n        Nr = 12\n    elif Nk == 8:  # 256-bit key\n        Nr = 14\n    else:\n        raise ValueError('Invalid key size: AES key must be 16, 24, or 32 bytes (128, 192, or 256 bits)')\n\n    expanded_key = list(data)  # Initialize expanded key with the original key\n    Nb = 4  # Number of columns (words) in the state, always 4 for AES\n\n    # Generate the remaining words of the expanded key\n    # Total words needed: Nb * (Nr + 1)\n    # The loop starts from Nk because the first Nk words are already in expanded_key\n    for i in range(Nk, Nb * (Nr + 1)):\n        # Get the word at index (i-1)\n        temp_word = expanded_key[(i - 1) * Nb : i * Nb]\n\n        # Apply transformations based on index i\n        if i % Nk == 0:\n            # RotWord: Cyclically shift left by one byte\n            temp_word = rotate(temp_word)\n            # SubWord: Apply S-box substitution to each byte\n            temp_word = sub_bytes(temp_word)\n            # XOR with Rcon\n            # The Rcon value corresponds to the current round, which is (i // Nk)\n            # Since _RCON is 0-indexed, and the first Rcon is for i=Nk (round 1), use i // Nk - 1\n            rcon_value = _RCON[i // Nk - 1]\n            rcon_word = [rcon_value, 0, 0, 0]  # Rcon is added to the first byte of the word\n            temp_word = xor(temp_word, rcon_word)\n        elif Nk > 6 and i % Nk == 4:\n            # Specific rule for AES-256 (Nk=8): apply SubWord after every 4th word\n            temp_word = sub_bytes(temp_word)\n\n        # XOR temp_word with the word Nk steps earlier\n        previous_Nk_word = expanded_key[(i - Nk) * Nb : (i - Nk + 1) * Nb]\n        new_word = xor(previous_Nk_word, temp_word)\n        expanded_key.extend(new_word)  # Append the new 4-byte word to the expanded key\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\n# S-Box (Substitution Box) - Standard AES S-Box\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x47, 0xc8, 0xf4, 0x00, 0xea, 0x2f, 0x81, 0x07, 0xc2, 0x05, 0x6e, 0x94, 0xd5, 0x01\n]\n\n# Round Constants for AES Key Expansion\nRcon = [\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36\n]\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_bytes_len = len(data)\n\n    # Determine Nk (number of 32-bit words in cipher key) and Nr (number of rounds)\n    if key_bytes_len == 16:  # 128-bit key\n        Nk = 4\n        Nr = 10\n    elif key_bytes_len == 24:  # 192-bit key\n        Nk = 6\n        Nr = 12\n    elif key_bytes_len == 32:  # 256-bit key\n        Nk = 8\n        Nr = 14\n    else:\n        raise ValueError('Unsupported key length: must be 16, 24, or 32 bytes')\n\n    # Initialize the expanded key with the input key\n    expanded_key = list(data)\n\n    # Generate the remaining words of the key schedule\n    # The total number of words in the key schedule is Nb * (Nr + 1) = 4 * (Nr + 1)\n    # Each word is 4 bytes.\n    for i in range(Nk, 4 * (Nr + 1)):\n        # Get the previous word\n        temp_word = expanded_key[(i - 1) * 4 : i * 4]\n\n        # Apply transformations for the first word of each new key block\n        if i % Nk == 0:\n            # 1. RotWord: Cyclic shift left by one byte\n            temp_word = rotate(temp_word)\n            # 2. SubWord: Apply SBOX substitution to each byte\n            temp_word = sub_bytes(temp_word) # sub_bytes is Context 4\n            # 3. XOR with Rcon[i/Nk - 1]\n            # Rcon is a single byte, so we XOR it with the first byte of the word\n            rcon_val = Rcon[i // Nk - 1]\n            temp_word = xor(temp_word, [rcon_val, 0, 0, 0]) # xor is Context 6\n        # Specific transformation for 256-bit keys\n        elif Nk > 6 and i % Nk == 4: # This condition is specific to 256-bit (Nk=8) keys\n            # SubWord: Apply SBOX substitution to each byte\n            temp_word = sub_bytes(temp_word)\n\n        # XOR with the word Nk positions back\n        # This combines the transformed temp_word with a word from the previous block\n        previous_block_word = expanded_key[(i - Nk) * 4 : (i - Nk + 1) * 4]\n        current_word = xor(temp_word, previous_block_word)\n\n        # Append the new word (4 bytes) to the expanded key\n        expanded_key.extend(current_word)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\n# Constants for AES Key Expansion (standard S-Box and Rcon values)\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\nRcon = [\n    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\n    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,\n]\n\n# Context Functions that need to be imported (as they are external to this file content)\n# We assume they are available in the 'youtube_dl.aes' module.\n# The prompt implies these are 'context functions' and should be used,\n# and for independent execution, they must be imported.\n# Note: In a real 'youtube_dl' project, these might be in the same file or imported differently.\n# This approach adheres to \"Include all necessary import statements at the top so the code runs independently.\"\nfrom youtube_dl.aes import sub_bytes\nfrom youtube_dl.aes import xor\nfrom youtube_dl.aes import rotate\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    Nk = len(data) // 4  # Number of 32-bit words in the cipher key\n    Nb = 4               # Number of columns (32-bit words) in the state, always 4 for AES\n\n    # Determine Nr (number of rounds) based on key length\n    if Nk == 4:  # 128-bit key\n        Nr = 10\n    elif Nk == 6:  # 192-bit key\n        Nr = 12\n    elif Nk == 8:  # 256-bit key\n        Nr = 14\n    else:\n        raise ValueError('Invalid key length: %d bytes. Key must be 16, 24, or 32 bytes.' % len(data))\n\n    # Calculate total number of words in the expanded key\n    num_expanded_words = Nb * (Nr + 1)\n\n    key_schedule = list(data)  # Initialize key_schedule with the cipher key\n\n    # Generate the rest of the expanded key\n    for i in range(Nk, num_expanded_words):\n        # temp_word is the previous word in the key schedule (w[i-1])\n        temp_word = key_schedule[(i - 1) * 4 : i * 4]\n\n        if i % Nk == 0:\n            # Apply RotWord (cyclic shift left by one byte)\n            temp_word = rotate(temp_word)\n            # Apply SubWord (byte substitution using SBOX)\n            temp_word = sub_bytes(temp_word)\n            # XOR with Rcon\n            temp_word[0] = temp_word[0] ^ Rcon[i // Nk - 1]\n        elif Nk == 8 and i % Nk == 4:\n            # Special case for 256-bit key (Nk = 8)\n            # Apply SubWord to the 4th word of the new block (words 4, 12, 20...)\n            temp_word = sub_bytes(temp_word)\n\n        # XOR temp_word with the word Nk positions before (w[i-Nk])\n        prev_Nk_word = key_schedule[(i - Nk) * 4 : (i - Nk + 1) * 4]\n        new_word = xor(prev_Nk_word, temp_word)\n\n        # Extend the key schedule with the newly generated word\n        key_schedule.extend(new_word)\n\n    return key_schedule\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom math import ceil # Already present in file content\n# from .compat import compat_b64decode # Already present in file content\n# from .utils import bytes_to_intlist, intlist_to_bytes # Already present in file content\n\n# BLOCK_SIZE_BYTES is already defined in the file content\n\n# Assume sub_bytes, rotate, and xor are available globally within this module\n# given their context descriptions and usage in existing functions.\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Standard AES Round Constants (Rcon)\n    Rcon = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\n    ]\n\n    Nk = len(data) // 4  # Number of 32-bit words in the cipher key\n    Nb = 4               # Number of 32-bit words in the state (fixed for AES)\n\n    # Determine the number of rounds (Nr) based on key length\n    if Nk == 4:  # 128-bit key\n        Nr = 10\n    elif Nk == 6:  # 192-bit key\n        Nr = 12\n    elif Nk == 8:  # 256-bit key\n        Nr = 14\n    else:\n        raise ValueError('Invalid AES key length: must be 16, 24, or 32 bytes')\n\n    # Initialize the expanded key `w` with the input cipher key\n    # `w` will be a flat list of bytes (integers)\n    w = list(data)\n\n    # Generate the remaining words of the key schedule\n    for i in range(Nk, Nb * (Nr + 1)):\n        # Get the previous word (4 bytes)\n        temp_word = w[(i - 1) * 4 : i * 4]\n\n        # Apply transformations based on key schedule rules\n        if i % Nk == 0:\n            # RotWord: Cyclic shift left by one byte\n            temp_word = rotate(temp_word)\n            # SubWord: Byte substitution using S-Box\n            temp_word = sub_bytes(temp_word)\n            # XOR with Rcon\n            rcon_value = Rcon[(i // Nk) - 1]\n            rcon_word = [rcon_value, 0, 0, 0] # Rcon values apply to the first byte of the word\n            temp_word = xor(temp_word, rcon_word)\n        elif Nk > 6 and i % Nk == 4:\n            # For 256-bit keys, apply SubWord every 4th word after the Nk multiple\n            temp_word = sub_bytes(temp_word)\n\n        # Main key expansion step: XOR with the word Nk positions earlier\n        prev_Nk_word = w[(i - Nk) * 4 : (i - Nk + 1) * 4]\n        new_word = xor(prev_Nk_word, temp_word)\n\n        # Append the new 4-byte word to the expanded key\n        w.extend(new_word)\n\n    return w\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n# Imports from context functions provided\n# These functions are part of the youtube_dl.aes module according to their import statements.\nfrom youtube_dl.aes import sub_bytes, xor, rotate\n\n# SBOX and Rcon tables are standard constants for AES key expansion.\n# Since the `sub_bytes` context function's implementation refers to SBOX,\n# and Rcon is a fundamental part of AES key expansion, they are defined here.\n# They are typically module-level constants in a cryptographic implementation.\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x8f, 0x4a, 0x1f, 0x6a, 0x42, 0x4d, 0x23, 0x59, 0x34, 0xc8, 0xda, 0xfe, 0xba, 0x20\n]\n\nRcon = [\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36\n]\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Initialize the expanded key with the original key\n    expanded_key = list(data)\n\n    # Nk: Number of 32-bit words in the cipher key (key length / 4)\n    Nk = len(data) // 4\n\n    # Nr: Number of rounds based on key size\n    # 128-bit key (Nk=4) -> 10 rounds\n    # 192-bit key (Nk=6) -> 12 rounds\n    # 256-bit key (Nk=8) -> 14 rounds\n    Nr = {\n        4: 10,\n        6: 12,\n        8: 14\n    }.get(Nk)\n\n    if Nr is None:\n        raise ValueError('Invalid key length. Must be 16, 24, or 32 bytes.')\n\n    # Nb: Number of 32-bit words in a block (always 4 for AES)\n    Nb = BLOCK_SIZE_BYTES // 4  # BLOCK_SIZE_BYTES is 16\n\n    # Total words in the key schedule: Nb * (Nr + 1)\n    KEY_SCHEDULE_WORDS = Nb * (Nr + 1)\n\n    # Generate the remaining words of the key schedule\n    for i in range(Nk, KEY_SCHEDULE_WORDS):\n        # Temp is the last generated word (W[i-1])\n        temp = expanded_key[4 * (i - 1): 4 * (i - 1) + 4]\n\n        # Apply transformations based on the word's position\n        if i % Nk == 0:\n            # For the first word of a new Nk-word block (or start of a round)\n            # 1. Rotate the word\n            temp = rotate(temp)\n            # 2. Substitute bytes using SBOX\n            temp = sub_bytes(temp)\n            # 3. XOR with Rcon (Round Constant)\n            # Rcon[i // Nk - 1] because Rcon starts from index 0 for the first round,\n            # and i // Nk gives 1 for the first block (i = Nk), 2 for the second (i = 2*Nk), etc.\n            temp = xor(temp, [Rcon[i // Nk - 1], 0, 0, 0])\n        elif Nk == 8 and i % Nk == 4:\n            # For 256-bit key, an additional SubBytes is applied at this specific position\n            temp = sub_bytes(temp)\n\n        # XOR the current temp word with the word Nk positions back (W[i-Nk])\n        prev_Nk_word = expanded_key[4 * (i - Nk): 4 * (i - Nk) + 4]\n        new_word = xor(prev_Nk_word, temp)\n\n        # Append the newly generated word to the expanded key\n        expanded_key.extend(new_word)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n"]}
{"task_id": 149, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from youtube_dl.aes import shift_rows\nfrom youtube_dl.aes import mix_columns\n\n# The functions `xor` and `sub_bytes` are extensively used in the provided `File Content`\n# (e.g., `aes_ctr_decrypt`, `aes_cbc_encrypt`, `key_expansion`).\n# This implies they are already defined within the scope of this module or imported\n# by the existing file setup. Therefore, we assume their availability and do not\n# need to re-implement or add explicit imports for them from external sources.\n# The `BLOCK_SIZE_BYTES` constant is also available from the file content.\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Create a mutable copy of the input data block to avoid modifying the original\n    state = list(data)\n\n    # Determine the number of rounds (Nr) based on the expanded key length.\n    # An AES expanded key contains (Nr + 1) round keys. Each round key is 16 bytes.\n    # So, len(expanded_key) = (Nr + 1) * BLOCK_SIZE_BYTES\n    # This implies Nr = (len(expanded_key) / BLOCK_SIZE_BYTES) - 1\n    Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Round 0: Initial AddRoundKey\n    # XOR the state with the first round key (key_0)\n    # The first round key is the initial BLOCK_SIZE_BYTES from expanded_key\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    # Main Rounds (from round 1 up to Nr - 1):\n    # Each main round consists of SubBytes, ShiftRows, MixColumns, and AddRoundKey.\n    for r in range(1, Nr):\n        # SubBytes: Apply the S-Box transformation to each byte of the state.\n        state = sub_bytes(state)\n\n        # ShiftRows: Perform cyclic shifts on the rows of the state.\n        state = shift_rows(state)\n\n        # MixColumns: Perform column mixing transformation on the state.\n        state = mix_columns(state)\n\n        # AddRoundKey: XOR the state with the current round key.\n        # The round key for round 'r' is extracted from the expanded_key.\n        round_key_start = r * BLOCK_SIZE_BYTES\n        round_key_end = (r + 1) * BLOCK_SIZE_BYTES\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final Round (Round Nr):\n    # The final round differs by omitting the MixColumns step.\n    # SubBytes\n    state = sub_bytes(state)\n\n    # ShiftRows\n    state = shift_rows(state)\n\n    # AddRoundKey with the last round key.\n    # The last round key is the (Nr)-th block from the expanded_key.\n    final_round_key_start = Nr * BLOCK_SIZE_BYTES\n    final_round_key_end = (Nr + 1) * BLOCK_SIZE_BYTES\n    state = xor(state, expanded_key[final_round_key_start:final_round_key_end])\n\n    return state", "def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # The number of rounds (Nr) depends on the key size.\n    # The expanded_key length is (Nr + 1) * BLOCK_SIZE_BYTES.\n    # Therefore, Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1.\n    Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initialize the state. Create a mutable copy of the input data.\n    state = list(data)\n\n    # Initial Round\n    # AddRoundKey: XOR the state with the first round key.\n    # The 'xor' function is available from the file's context, as seen in aes_ctr_decrypt, aes_cbc_decrypt, etc.\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    # Main Rounds (Nr-1 rounds)\n    for r in range(1, Nr):\n        # SubBytes: Apply the S-box substitution to each byte of the state.\n        # The 'sub_bytes' function is available from the file's context, as seen in key_expansion.\n        state = sub_bytes(state)\n        # ShiftRows: Perform cyclic shifts on the rows of the state.\n        # This function is provided as Context Function 6.\n        # It's assumed to be available directly as it would be defined within the same module (youtube_dl.aes).\n        state = shift_rows(state)\n        # MixColumns: Perform a column mixing transformation.\n        # This function is provided as Context Function 5.\n        # It's assumed to be available directly as it would be defined within the same module (youtube_dl.aes).\n        state = mix_columns(state)\n        # AddRoundKey: XOR the state with the current round key.\n        state = xor(state, expanded_key[r * BLOCK_SIZE_BYTES : (r + 1) * BLOCK_SIZE_BYTES])\n\n    # Final Round (Nr round) - no MixColumns\n    # SubBytes\n    state = sub_bytes(state)\n    # ShiftRows\n    state = shift_rows(state)\n    # AddRoundKey: XOR the state with the final round key.\n    state = xor(state, expanded_key[Nr * BLOCK_SIZE_BYTES : (Nr + 1) * BLOCK_SIZE_BYTES])\n\n    return state\n\n# Necessary imports for `shift_rows` and `mix_columns` if they were not already available\n# in the current module's scope from the provided file content.\n# Based on the problem description and typical Python module structure,\n# functions like shift_rows and mix_columns are expected to be defined or imported\n# within the 'youtube_dl.aes' module itself, making them directly callable.\n# If this were a standalone script, these imports would be required:\n# from youtube_dl.aes import shift_rows\n# from youtube_dl.aes import mix_columns", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\n# Assumed global constants and helper functions within this module, based on context and file content analysis:\n# AES_SBOX = [...]\n# RIJNDAEL_EXP_TABLE = [...]\n# RIJNDAEL_LOG_TABLE = [...]\n# MIX_COLUMN_MATRIX = [...]\n# xor(list1, list2) -> list (element-wise XOR)\n# sub_bytes(data) -> data (applies S-box substitution)\n# shift_rows(data) -> data (from context)\n# mix_columns(data, matrix=MIX_COLUMN_MATRIX) -> data (from context)\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Create a mutable copy of the data block to modify\n    state = data[:]\n\n    # Determine the number of rounds (Nr) based on the length of the expanded_key.\n    # The expanded_key contains (Nr + 1) round keys, each 16 bytes.\n    # So, len(expanded_key) = (Nr + 1) * BLOCK_SIZE_BYTES\n    # Therefore, Nr = (len(expanded_key) / BLOCK_SIZE_BYTES) - 1\n    Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial Round: AddRoundKey\n    # XOR the input state with the first round key (round 0).\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    # Main Rounds (Nr - 1 rounds)\n    # For AES-128 (Nr=10), this loop runs 9 times (rounds 1 to 9).\n    # For AES-192 (Nr=12), this loop runs 11 times (rounds 1 to 11).\n    # For AES-256 (Nr=14), this loop runs 13 times (rounds 1 to 13).\n    for round_idx in range(1, Nr):\n        # 1. SubBytes: Apply S-box substitution to each byte in the state.\n        state = sub_bytes(state)\n        # 2. ShiftRows: Cyclically shift rows of the state.\n        state = shift_rows(state)\n        # 3. MixColumns: Perform column mixing transformation.\n        state = mix_columns(state)\n        # 4. AddRoundKey: XOR the state with the current round key.\n        state = xor(state, expanded_key[round_idx * BLOCK_SIZE_BYTES : (round_idx + 1) * BLOCK_SIZE_BYTES])\n\n    # Final Round (without MixColumns)\n    # For AES-128, this is the 10th round.\n    # For AES-192, this is the 12th round.\n    # For AES-256, this is the 14th round.\n    # 1. SubBytes: Apply S-box substitution.\n    state = sub_bytes(state)\n    # 2. ShiftRows: Cyclically shift rows.\n    state = shift_rows(state)\n    # 3. AddRoundKey: XOR the state with the final round key.\n    state = xor(state, expanded_key[Nr * BLOCK_SIZE_BYTES : (Nr + 1) * BLOCK_SIZE_BYTES])\n\n    return state", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\nfrom .aes import sub_bytes, shift_rows, mix_columns, xor # Necessary AES primitive imports\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = list(data)  # Make a copy to avoid modifying the original input 'data'\n\n    # Determine the number of rounds (Nr) based on the expanded key length.\n    # Total round keys = Nr + 1. Each round key is BLOCK_SIZE_BYTES (16 bytes).\n    # So, len(expanded_key) = (Nr + 1) * BLOCK_SIZE_BYTES\n    # Nr = (len(expanded_key) / BLOCK_SIZE_BYTES) - 1\n    num_rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial Round: AddRoundKey\n    current_round_key = expanded_key[0:BLOCK_SIZE_BYTES]\n    state = xor(state, current_round_key)\n\n    # Main Rounds (from round 1 to Nr-1)\n    for r in range(1, num_rounds):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns (omitted in the final round)\n        state = mix_columns(state)\n        # AddRoundKey\n        current_round_key = expanded_key[r * BLOCK_SIZE_BYTES : (r + 1) * BLOCK_SIZE_BYTES]\n        state = xor(state, current_round_key)\n\n    # Final Round (Round Nr): No MixColumns\n    # SubBytes\n    state = sub_bytes(state)\n    # ShiftRows\n    state = shift_rows(state)\n    # AddRoundKey\n    current_round_key = expanded_key[num_rounds * BLOCK_SIZE_BYTES : (num_rounds + 1) * BLOCK_SIZE_BYTES]\n    state = xor(state, current_round_key)\n\n    return state", "from youtube_dl.aes import shift_rows\nfrom youtube_dl.aes import mix_columns\n\n# BLOCK_SIZE_BYTES is assumed to be available from the file content.\n# xor and sub_bytes are assumed to be available in the current module's scope,\n# as they are used by other functions in the provided file content without explicit imports.\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Define BLOCK_SIZE_BYTES based on the file content.\n    # If BLOCK_SIZE_BYTES was not globally defined, it would need to be passed or derived.\n    BLOCK_SIZE_BYTES = 16\n\n    # Determine the number of rounds (Nr) based on the length of the expanded key.\n    # The expanded key contains (Nr + 1) blocks, each BLOCK_SIZE_BYTES long.\n    Nr = (len(expanded_key) // BLOCK_SIZE_BYTES) - 1\n\n    # Create a mutable copy of the input data block to act as the state.\n    state = list(data)\n\n    # 1. Initial AddRoundKey\n    # XOR the state with the first round key (0th block of expanded_key).\n    initial_round_key = expanded_key[0:BLOCK_SIZE_BYTES]\n    state = xor(state, initial_round_key)\n\n    # 2. Main Rounds (from round 1 up to Nr - 1)\n    for round_num in range(1, Nr):\n        # SubBytes: Substitute bytes using the S-box.\n        state = sub_bytes(state)\n\n        # ShiftRows: Cyclically shift rows of the state.\n        state = shift_rows(state)\n\n        # MixColumns: Mix the columns of the state.\n        state = mix_columns(state)\n\n        # AddRoundKey: XOR the state with the current round key.\n        current_round_key = expanded_key[round_num * BLOCK_SIZE_BYTES : (round_num + 1) * BLOCK_SIZE_BYTES]\n        state = xor(state, current_round_key)\n\n    # 3. Final Round (Nr-th round)\n    # This round is similar to the main rounds but omits the MixColumns step.\n    # SubBytes\n    state = sub_bytes(state)\n\n    # ShiftRows\n    state = shift_rows(state)\n\n    # AddRoundKey\n    # XOR the state with the final round key (Nr-th block of expanded_key).\n    final_round_key = expanded_key[Nr * BLOCK_SIZE_BYTES : (Nr + 1) * BLOCK_SIZE_BYTES]\n    state = xor(state, final_round_key)\n\n    return state"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import shift_rows\nfrom youtube_dl.aes import mix_columns\n\n# The functions `xor` and `sub_bytes` are extensively used in the provided `File Content`\n# (e.g., `aes_ctr_decrypt`, `aes_cbc_encrypt`, `key_expansion`).\n# This implies they are already defined within the scope of this module or imported\n# by the existing file setup. Therefore, we assume their availability and do not\n# need to re-implement or add explicit imports for them from external sources.\n# The `BLOCK_SIZE_BYTES` constant is also available from the file content.\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Create a mutable copy of the input data block to avoid modifying the original\n    state = list(data)\n\n    # Determine the number of rounds (Nr) based on the expanded key length.\n    # An AES expanded key contains (Nr + 1) round keys. Each round key is 16 bytes.\n    # So, len(expanded_key) = (Nr + 1) * BLOCK_SIZE_BYTES\n    # This implies Nr = (len(expanded_key) / BLOCK_SIZE_BYTES) - 1\n    Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Round 0: Initial AddRoundKey\n    # XOR the state with the first round key (key_0)\n    # The first round key is the initial BLOCK_SIZE_BYTES from expanded_key\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    # Main Rounds (from round 1 up to Nr - 1):\n    # Each main round consists of SubBytes, ShiftRows, MixColumns, and AddRoundKey.\n    for r in range(1, Nr):\n        # SubBytes: Apply the S-Box transformation to each byte of the state.\n        state = sub_bytes(state)\n\n        # ShiftRows: Perform cyclic shifts on the rows of the state.\n        state = shift_rows(state)\n\n        # MixColumns: Perform column mixing transformation on the state.\n        state = mix_columns(state)\n\n        # AddRoundKey: XOR the state with the current round key.\n        # The round key for round 'r' is extracted from the expanded_key.\n        round_key_start = r * BLOCK_SIZE_BYTES\n        round_key_end = (r + 1) * BLOCK_SIZE_BYTES\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final Round (Round Nr):\n    # The final round differs by omitting the MixColumns step.\n    # SubBytes\n    state = sub_bytes(state)\n\n    # ShiftRows\n    state = shift_rows(state)\n\n    # AddRoundKey with the last round key.\n    # The last round key is the (Nr)-th block from the expanded_key.\n    final_round_key_start = Nr * BLOCK_SIZE_BYTES\n    final_round_key_end = (Nr + 1) * BLOCK_SIZE_BYTES\n    state = xor(state, expanded_key[final_round_key_start:final_round_key_end])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # The number of rounds (Nr) depends on the key size.\n    # The expanded_key length is (Nr + 1) * BLOCK_SIZE_BYTES.\n    # Therefore, Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1.\n    Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initialize the state. Create a mutable copy of the input data.\n    state = list(data)\n\n    # Initial Round\n    # AddRoundKey: XOR the state with the first round key.\n    # The 'xor' function is available from the file's context, as seen in aes_ctr_decrypt, aes_cbc_decrypt, etc.\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    # Main Rounds (Nr-1 rounds)\n    for r in range(1, Nr):\n        # SubBytes: Apply the S-box substitution to each byte of the state.\n        # The 'sub_bytes' function is available from the file's context, as seen in key_expansion.\n        state = sub_bytes(state)\n        # ShiftRows: Perform cyclic shifts on the rows of the state.\n        # This function is provided as Context Function 6.\n        # It's assumed to be available directly as it would be defined within the same module (youtube_dl.aes).\n        state = shift_rows(state)\n        # MixColumns: Perform a column mixing transformation.\n        # This function is provided as Context Function 5.\n        # It's assumed to be available directly as it would be defined within the same module (youtube_dl.aes).\n        state = mix_columns(state)\n        # AddRoundKey: XOR the state with the current round key.\n        state = xor(state, expanded_key[r * BLOCK_SIZE_BYTES : (r + 1) * BLOCK_SIZE_BYTES])\n\n    # Final Round (Nr round) - no MixColumns\n    # SubBytes\n    state = sub_bytes(state)\n    # ShiftRows\n    state = shift_rows(state)\n    # AddRoundKey: XOR the state with the final round key.\n    state = xor(state, expanded_key[Nr * BLOCK_SIZE_BYTES : (Nr + 1) * BLOCK_SIZE_BYTES])\n\n    return state\n\n# Necessary imports for `shift_rows` and `mix_columns` if they were not already available\n# in the current module's scope from the provided file content.\n# Based on the problem description and typical Python module structure,\n# functions like shift_rows and mix_columns are expected to be defined or imported\n# within the 'youtube_dl.aes' module itself, making them directly callable.\n# If this were a standalone script, these imports would be required:\n# from youtube_dl.aes import shift_rows\n# from youtube_dl.aes import mix_columns\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\n# Assumed global constants and helper functions within this module, based on context and file content analysis:\n# AES_SBOX = [...]\n# RIJNDAEL_EXP_TABLE = [...]\n# RIJNDAEL_LOG_TABLE = [...]\n# MIX_COLUMN_MATRIX = [...]\n# xor(list1, list2) -> list (element-wise XOR)\n# sub_bytes(data) -> data (applies S-box substitution)\n# shift_rows(data) -> data (from context)\n# mix_columns(data, matrix=MIX_COLUMN_MATRIX) -> data (from context)\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Create a mutable copy of the data block to modify\n    state = data[:]\n\n    # Determine the number of rounds (Nr) based on the length of the expanded_key.\n    # The expanded_key contains (Nr + 1) round keys, each 16 bytes.\n    # So, len(expanded_key) = (Nr + 1) * BLOCK_SIZE_BYTES\n    # Therefore, Nr = (len(expanded_key) / BLOCK_SIZE_BYTES) - 1\n    Nr = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial Round: AddRoundKey\n    # XOR the input state with the first round key (round 0).\n    state = xor(state, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    # Main Rounds (Nr - 1 rounds)\n    # For AES-128 (Nr=10), this loop runs 9 times (rounds 1 to 9).\n    # For AES-192 (Nr=12), this loop runs 11 times (rounds 1 to 11).\n    # For AES-256 (Nr=14), this loop runs 13 times (rounds 1 to 13).\n    for round_idx in range(1, Nr):\n        # 1. SubBytes: Apply S-box substitution to each byte in the state.\n        state = sub_bytes(state)\n        # 2. ShiftRows: Cyclically shift rows of the state.\n        state = shift_rows(state)\n        # 3. MixColumns: Perform column mixing transformation.\n        state = mix_columns(state)\n        # 4. AddRoundKey: XOR the state with the current round key.\n        state = xor(state, expanded_key[round_idx * BLOCK_SIZE_BYTES : (round_idx + 1) * BLOCK_SIZE_BYTES])\n\n    # Final Round (without MixColumns)\n    # For AES-128, this is the 10th round.\n    # For AES-192, this is the 12th round.\n    # For AES-256, this is the 14th round.\n    # 1. SubBytes: Apply S-box substitution.\n    state = sub_bytes(state)\n    # 2. ShiftRows: Cyclically shift rows.\n    state = shift_rows(state)\n    # 3. AddRoundKey: XOR the state with the final round key.\n    state = xor(state, expanded_key[Nr * BLOCK_SIZE_BYTES : (Nr + 1) * BLOCK_SIZE_BYTES])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\nfrom .aes import sub_bytes, shift_rows, mix_columns, xor # Necessary AES primitive imports\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = list(data)  # Make a copy to avoid modifying the original input 'data'\n\n    # Determine the number of rounds (Nr) based on the expanded key length.\n    # Total round keys = Nr + 1. Each round key is BLOCK_SIZE_BYTES (16 bytes).\n    # So, len(expanded_key) = (Nr + 1) * BLOCK_SIZE_BYTES\n    # Nr = (len(expanded_key) / BLOCK_SIZE_BYTES) - 1\n    num_rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial Round: AddRoundKey\n    current_round_key = expanded_key[0:BLOCK_SIZE_BYTES]\n    state = xor(state, current_round_key)\n\n    # Main Rounds (from round 1 to Nr-1)\n    for r in range(1, num_rounds):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns (omitted in the final round)\n        state = mix_columns(state)\n        # AddRoundKey\n        current_round_key = expanded_key[r * BLOCK_SIZE_BYTES : (r + 1) * BLOCK_SIZE_BYTES]\n        state = xor(state, current_round_key)\n\n    # Final Round (Round Nr): No MixColumns\n    # SubBytes\n    state = sub_bytes(state)\n    # ShiftRows\n    state = shift_rows(state)\n    # AddRoundKey\n    current_round_key = expanded_key[num_rounds * BLOCK_SIZE_BYTES : (num_rounds + 1) * BLOCK_SIZE_BYTES]\n    state = xor(state, current_round_key)\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\nfrom youtube_dl.aes import shift_rows\nfrom youtube_dl.aes import mix_columns\n\n# BLOCK_SIZE_BYTES is assumed to be available from the file content.\n# xor and sub_bytes are assumed to be available in the current module's scope,\n# as they are used by other functions in the provided file content without explicit imports.\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Define BLOCK_SIZE_BYTES based on the file content.\n    # If BLOCK_SIZE_BYTES was not globally defined, it would need to be passed or derived.\n    BLOCK_SIZE_BYTES = 16\n\n    # Determine the number of rounds (Nr) based on the length of the expanded key.\n    # The expanded key contains (Nr + 1) blocks, each BLOCK_SIZE_BYTES long.\n    Nr = (len(expanded_key) // BLOCK_SIZE_BYTES) - 1\n\n    # Create a mutable copy of the input data block to act as the state.\n    state = list(data)\n\n    # 1. Initial AddRoundKey\n    # XOR the state with the first round key (0th block of expanded_key).\n    initial_round_key = expanded_key[0:BLOCK_SIZE_BYTES]\n    state = xor(state, initial_round_key)\n\n    # 2. Main Rounds (from round 1 up to Nr - 1)\n    for round_num in range(1, Nr):\n        # SubBytes: Substitute bytes using the S-box.\n        state = sub_bytes(state)\n\n        # ShiftRows: Cyclically shift rows of the state.\n        state = shift_rows(state)\n\n        # MixColumns: Mix the columns of the state.\n        state = mix_columns(state)\n\n        # AddRoundKey: XOR the state with the current round key.\n        current_round_key = expanded_key[round_num * BLOCK_SIZE_BYTES : (round_num + 1) * BLOCK_SIZE_BYTES]\n        state = xor(state, current_round_key)\n\n    # 3. Final Round (Nr-th round)\n    # This round is similar to the main rounds but omits the MixColumns step.\n    # SubBytes\n    state = sub_bytes(state)\n\n    # ShiftRows\n    state = shift_rows(state)\n\n    # AddRoundKey\n    # XOR the state with the final round key (Nr-th block of expanded_key).\n    final_round_key = expanded_key[Nr * BLOCK_SIZE_BYTES : (Nr + 1) * BLOCK_SIZE_BYTES]\n    state = xor(state, final_round_key)\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n"]}
{"task_id": 150, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration) # key_schedule_core and sub_bytes are assumed to be defined elsewhere in the file.\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # Calculate the number of rounds based on the expanded key length\n    # For AES-128, rounds = 10; AES-192, rounds = 12; AES-256, rounds = 14\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial AddRoundKey (with the key for the last round)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Loop for intermediate rounds (from rounds-1 down to 1)\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data) # Assumed to be defined locally, inverse of sub_bytes\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        data = mix_columns_inv(data)\n\n    # Final round steps (corresponding to encryption's initial round, key[0])\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data) # Assumed to be defined locally\n    data = xor(data, expanded_key[0 * BLOCK_SIZE_BYTES: (0 + 1) * BLOCK_SIZE_BYTES])\n\n    return data", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# Import necessary inverse functions from the aes module as per context.\n# We assume xor and inv_sub_bytes are available in the current scope,\n# similar to how sub_bytes, shift_rows, mix_columns, and xor are used\n# in aes_encrypt and other functions in the provided file content.\nfrom youtube_dl.aes import mix_columns_inv\nfrom youtube_dl.aes import shift_rows_inv\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Inverse of the final AddRoundKey (last operation in encryption)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Inverse of the operations in the final encryption round (no MixColumns in encryption's final round)\n    # The encryption sequence was: SubBytes -> ShiftRows\n    # So, the decryption sequence is: InvShiftRows -> InvSubBytes\n    data = shift_rows_inv(data)\n    data = inv_sub_bytes(data)\n\n    # Inverse of intermediate encryption rounds (from rounds-1 down to 1)\n    # For each round 'i' (from rounds-1 down to 1):\n    # Encryption sequence: SubBytes -> ShiftRows -> MixColumns -> AddRoundKey\n    # Decryption sequence: InvAddRoundKey -> InvMixColumns -> InvShiftRows -> InvSubBytes\n    for i in range(rounds - 1, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = inv_sub_bytes(data)\n\n    # Inverse of the initial AddRoundKey (first operation in encryption)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data", "from .aes import mix_columns_inv\nfrom .aes import shift_rows_inv\nfrom .aes import sub_bytes_inv # Assuming sub_bytes_inv exists in the same module\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # BLOCK_SIZE_BYTES is available from the file content\n    # xor is assumed to be in scope based on its usage in other functions in the file content\n\n    # Calculate the number of rounds based on the expanded key length\n    # expanded_key has (rounds + 1) blocks of BLOCK_SIZE_BYTES\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Step 1: Initial AddRoundKey (with the last round key, which was the last key added in encryption)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Step 2: Main decryption rounds (from rounds-1 down to 1)\n    # The loop iterates (rounds - 1) times.\n    # The 'MixColumns' operation is skipped in the last encryption round,\n    # so its inverse 'InvMixColumns' is applied in all but the *first* decryption round (i.e., when key is expanded_key[0])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        data = mix_columns_inv(data)\n\n    # Step 3: Final round operations (corresponds to encryption's initial AddRoundKey)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    return data", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# Import necessary AES inverse transformations and utility functions\n# These are assumed to be in the same .aes module based on context functions\n# and common AES implementations.\nfrom .aes import xor, sub_bytes_inv, shift_rows_inv, mix_columns_inv\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # First, reverse the final AddRoundKey operation (uses the last round key, K_rounds)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Iterate through the rounds in reverse order (from rounds-1 down to 0)\n    # The variable 'r' here represents the index of the round key being applied.\n    # This loop effectively reverses the transformations of encryption rounds (from rounds-1 down to 1)\n    # and the initial AddRoundKey (K_0).\n    for r in range(rounds - 1, -1, -1):\n        # Apply Inverse ShiftRows transformation\n        data = shift_rows_inv(data)\n        # Apply Inverse SubBytes transformation\n        data = sub_bytes_inv(data)\n\n        # Apply Inverse MixColumns transformation\n        # According to the AES standard, InvMixColumns is applied in all rounds\n        # except the very last one (when the round key K_0 is applied).\n        # In this loop, 'r == 0' corresponds to that final decryption round.\n        if r != 0:\n            data = mix_columns_inv(data)\n\n        # Apply AddRoundKey operation with the current round key (K_r)\n        data = xor(data, expanded_key[r * BLOCK_SIZE_BYTES: (r + 1) * BLOCK_SIZE_BYTES])\n\n    return data", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes, xor\n\n# Assuming these AES specific functions are within a local '.aes' module\n# based on the import statements suggested by the context functions.\nfrom .aes import (\n    sub_bytes,\n    shift_rows,\n    mix_columns,\n    sub_bytes_inv,\n    shift_rows_inv,\n    mix_columns_inv\n)\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        # Assuming key_schedule_core is available, potentially from .aes or elsewhere in the file\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # Calculate the number of rounds (Nr)\n    # The expanded_key contains (Nr + 1) blocks, including the initial key\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Step 1: Reverse the final AddRoundKey (using the last round key, K_Nr)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Step 2: Reverse the operations of the last encryption round (Round Nr)\n    # The last encryption round skips MixColumns. So, we reverse ShiftRows and SubBytes.\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n\n    # Step 3: Loop from round Nr-1 down to 1\n    for i in range(rounds - 1, 0, -1):\n        # Reverse AddRoundKey (using key K_i)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        # Reverse MixColumns\n        data = mix_columns_inv(data)\n        # Reverse ShiftRows\n        data = shift_rows_inv(data)\n        # Reverse SubBytes\n        data = sub_bytes_inv(data)\n\n    # Step 4: Reverse the initial AddRoundKey (using the first round key, K_0)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration) # key_schedule_core and sub_bytes are assumed to be defined elsewhere in the file.\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # Calculate the number of rounds based on the expanded key length\n    # For AES-128, rounds = 10; AES-192, rounds = 12; AES-256, rounds = 14\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Initial AddRoundKey (with the key for the last round)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Loop for intermediate rounds (from rounds-1 down to 1)\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data) # Assumed to be defined locally, inverse of sub_bytes\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        data = mix_columns_inv(data)\n\n    # Final round steps (corresponding to encryption's initial round, key[0])\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data) # Assumed to be defined locally\n    data = xor(data, expanded_key[0 * BLOCK_SIZE_BYTES: (0 + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# Import necessary inverse functions from the aes module as per context.\n# We assume xor and inv_sub_bytes are available in the current scope,\n# similar to how sub_bytes, shift_rows, mix_columns, and xor are used\n# in aes_encrypt and other functions in the provided file content.\nfrom youtube_dl.aes import mix_columns_inv\nfrom youtube_dl.aes import shift_rows_inv\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Inverse of the final AddRoundKey (last operation in encryption)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Inverse of the operations in the final encryption round (no MixColumns in encryption's final round)\n    # The encryption sequence was: SubBytes -> ShiftRows\n    # So, the decryption sequence is: InvShiftRows -> InvSubBytes\n    data = shift_rows_inv(data)\n    data = inv_sub_bytes(data)\n\n    # Inverse of intermediate encryption rounds (from rounds-1 down to 1)\n    # For each round 'i' (from rounds-1 down to 1):\n    # Encryption sequence: SubBytes -> ShiftRows -> MixColumns -> AddRoundKey\n    # Decryption sequence: InvAddRoundKey -> InvMixColumns -> InvShiftRows -> InvSubBytes\n    for i in range(rounds - 1, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = inv_sub_bytes(data)\n\n    # Inverse of the initial AddRoundKey (first operation in encryption)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom .aes import mix_columns_inv\nfrom .aes import shift_rows_inv\nfrom .aes import sub_bytes_inv # Assuming sub_bytes_inv exists in the same module\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # BLOCK_SIZE_BYTES is available from the file content\n    # xor is assumed to be in scope based on its usage in other functions in the file content\n\n    # Calculate the number of rounds based on the expanded key length\n    # expanded_key has (rounds + 1) blocks of BLOCK_SIZE_BYTES\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Step 1: Initial AddRoundKey (with the last round key, which was the last key added in encryption)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Step 2: Main decryption rounds (from rounds-1 down to 1)\n    # The loop iterates (rounds - 1) times.\n    # The 'MixColumns' operation is skipped in the last encryption round,\n    # so its inverse 'InvMixColumns' is applied in all but the *first* decryption round (i.e., when key is expanded_key[0])\n    for i in range(rounds - 1, 0, -1):\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        data = mix_columns_inv(data)\n\n    # Step 3: Final round operations (corresponds to encryption's initial AddRoundKey)\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[0:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# Import necessary AES inverse transformations and utility functions\n# These are assumed to be in the same .aes module based on context functions\n# and common AES implementations.\nfrom .aes import xor, sub_bytes_inv, shift_rows_inv, mix_columns_inv\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # First, reverse the final AddRoundKey operation (uses the last round key, K_rounds)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Iterate through the rounds in reverse order (from rounds-1 down to 0)\n    # The variable 'r' here represents the index of the round key being applied.\n    # This loop effectively reverses the transformations of encryption rounds (from rounds-1 down to 1)\n    # and the initial AddRoundKey (K_0).\n    for r in range(rounds - 1, -1, -1):\n        # Apply Inverse ShiftRows transformation\n        data = shift_rows_inv(data)\n        # Apply Inverse SubBytes transformation\n        data = sub_bytes_inv(data)\n\n        # Apply Inverse MixColumns transformation\n        # According to the AES standard, InvMixColumns is applied in all rounds\n        # except the very last one (when the round key K_0 is applied).\n        # In this loop, 'r == 0' corresponds to that final decryption round.\n        if r != 0:\n            data = mix_columns_inv(data)\n\n        # Apply AddRoundKey operation with the current round key (K_r)\n        data = xor(data, expanded_key[r * BLOCK_SIZE_BYTES: (r + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes, xor\n\n# Assuming these AES specific functions are within a local '.aes' module\n# based on the import statements suggested by the context functions.\nfrom .aes import (\n    sub_bytes,\n    shift_rows,\n    mix_columns,\n    sub_bytes_inv,\n    shift_rows_inv,\n    mix_columns_inv\n)\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        # Assuming key_schedule_core is available, potentially from .aes or elsewhere in the file\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # Calculate the number of rounds (Nr)\n    # The expanded_key contains (Nr + 1) blocks, including the initial key\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    # Step 1: Reverse the final AddRoundKey (using the last round key, K_Nr)\n    data = xor(data, expanded_key[rounds * BLOCK_SIZE_BYTES: (rounds + 1) * BLOCK_SIZE_BYTES])\n\n    # Step 2: Reverse the operations of the last encryption round (Round Nr)\n    # The last encryption round skips MixColumns. So, we reverse ShiftRows and SubBytes.\n    data = shift_rows_inv(data)\n    data = sub_bytes_inv(data)\n\n    # Step 3: Loop from round Nr-1 down to 1\n    for i in range(rounds - 1, 0, -1):\n        # Reverse AddRoundKey (using key K_i)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        # Reverse MixColumns\n        data = mix_columns_inv(data)\n        # Reverse ShiftRows\n        data = shift_rows_inv(data)\n        # Reverse SubBytes\n        data = sub_bytes_inv(data)\n\n    # Step 4: Reverse the initial AddRoundKey (using the first round key, K_0)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n"]}
{"task_id": 151, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# BLOCK_SIZE_BYTES is defined in the file content as 16\n# aes_encrypt, key_expansion, aes_ctr_decrypt, xor, inc are defined in the file content,\n# so they are directly available in the current module scope.\n\nclass AESCTRCounter:\n    \"\"\"\n    A counter instance for AES-CTR mode.\n    Its next_value function returns a 16-Byte block.\n    \"\"\"\n    def __init__(self, initial_high_bytes):\n        # The counter is a 16-byte block.\n        # The first 8 bytes are given by initial_high_bytes.\n        # The remaining 8 bytes are initialized to 0.\n        if len(initial_high_bytes) > 8:\n            # Take only the first 8 bytes as high bytes if more are provided\n            initial_high_bytes = initial_high_bytes[:8]\n        self._counter = initial_high_bytes + [0] * (BLOCK_SIZE_BYTES - len(initial_high_bytes))\n\n    def next_value(self):\n        \"\"\"\n        Returns the current counter block (16-Byte int list) and then increments it.\n        \"\"\"\n        current_value = self._counter[:]  # Return a copy of the current state\n        self._counter = inc(self._counter)  # Increment the counter for the next block\n        return current_value\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # 1. Decode the input 'data' from Base64 to bytes, then to an integer list.\n    decoded_bytes = compat_b64decode(data)\n    decoded_intlist = bytes_to_intlist(decoded_bytes)\n\n    # 2. Encode the password to UTF-8 bytes.\n    password_bytes = password.encode('utf-8')\n    password_intlist = bytes_to_intlist(password_bytes)\n\n    # 3. Derive the actual AES key.\n    #    'encryption_data' is the first 16 bytes of password_intlist, padded with 0s if shorter.\n    encryption_data_material = password_intlist[:BLOCK_SIZE_BYTES]\n    if len(encryption_data_material) < BLOCK_SIZE_BYTES:\n        encryption_data_material += [0] * (BLOCK_SIZE_BYTES - len(encryption_data_material))\n\n    #    'encryption_key_material' is the first 'key_size_bytes' of password_intlist, padded with 0s.\n    encryption_key_material = password_intlist[:key_size_bytes]\n    if len(encryption_key_material) < key_size_bytes:\n        encryption_key_material += [0] * (key_size_bytes - len(encryption_key_material))\n\n    #    Expand the encryption key material.\n    expanded_encryption_key = key_expansion(encryption_key_material)\n\n    #    Encrypt 'encryption_data_material' with the expanded key to get the final AES key.\n    aes_key = aes_encrypt(encryption_data_material, expanded_encryption_key)\n\n    # 4. Prepare the counter instance.\n    #    The first 8 bytes of decoded 'data' are the 8 high Bytes of the counter.\n    initial_counter_high_bytes = decoded_intlist[:8]\n    counter_instance = AESCTRCounter(initial_counter_high_bytes)\n\n    # 5. Extract the actual ciphertext (remaining bytes from decoded_intlist).\n    ciphertext_intlist = decoded_intlist[8:]\n\n    # 6. Decrypt the ciphertext using AES in CTR mode.\n    decrypted_intlist = aes_ctr_decrypt(ciphertext_intlist, aes_key, counter_instance)\n\n    # 7. Convert the decrypted integer list back to bytes and then to a UTF-8 string.\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    return decrypted_bytes.decode('utf-8')", "import base64\nfrom .aes import inc\n\n# BLOCK_SIZE_BYTES is assumed to be defined in the same scope, as per the provided file content.\n# Functions like aes_ctr_decrypt, key_expansion, aes_encrypt, xor,\n# compat_b64decode, bytes_to_intlist, and intlist_to_bytes\n# are also assumed to be available in the current file/module scope based on the file content.\n\nclass Counter:\n    \"\"\"\n    A simple counter class for AES CTR mode.\n    The counter is a 16-byte block, with the first 8 bytes initialized from input\n    and the last 8 bytes initialized to zero.\n    \"\"\"\n    def __init__(self, initial_high_8_bytes):\n        # Initialize the 16-byte counter block.\n        # BLOCK_SIZE_BYTES is assumed to be a globally defined constant (16) as per file content.\n        self._counter_block = initial_high_8_bytes + [0] * (BLOCK_SIZE_BYTES - len(initial_high_8_bytes))\n        if len(self._counter_block) != BLOCK_SIZE_BYTES:\n            raise ValueError('Initial counter block must result in 16 bytes.')\n\n    def next_value(self):\n        \"\"\"\n        Returns the current 16-byte counter block and then increments it.\n        \"\"\"\n        current_value = self._counter_block[:]  # Return a copy of the current counter state\n        self._counter_block = inc(self._counter_block)  # Increment the internal counter block using the 'inc' utility\n        return current_value\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # 1. Decode 'data' (Base64 encoded string)\n    # compat_b64decode is imported from .compat, and uses base64.b64decode internally, hence 'import base64'.\n    decoded_data_bytes = compat_b64decode(data)\n    # bytes_to_intlist is imported from .utils.\n    decoded_data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Extract initial counter high bytes and actual ciphertext\n    # The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter.\n    initial_counter_high_bytes = decoded_data_intlist[:8]\n    actual_cipher_intlist = decoded_data_intlist[8:]\n\n    # 3. Prepare password (encode to utf-8 and convert to intlist)\n    password_bytes = password.encode('utf-8')\n    password_intlist = bytes_to_intlist(password_bytes)\n\n    # 4. Derive cipher key\n    # The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    # with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's).\n\n    # Prepare data for encryption (first 16 bytes of password, padded with zeros if shorter)\n    encryption_data = password_intlist[:16]\n    if len(encryption_data) < 16:\n        encryption_data += [0] * (16 - len(encryption_data))\n\n    # Prepare key for encryption (first key_size_bytes of password, padded with zeros if shorter)\n    encryption_key = password_intlist[:key_size_bytes]\n    if len(encryption_key) < key_size_bytes:\n        encryption_key += [0] * (key_size_bytes - len(encryption_key))\n\n    # Generate expanded key for the key derivation encryption.\n    # key_expansion is a function defined in the same file/module.\n    expanded_key_for_cipher_derivation = key_expansion(encryption_key)\n\n    # Encrypt the password data block with the expanded key to get the actual cipher key.\n    # aes_encrypt is a function defined in the same file/module.\n    cipher_key_intlist = aes_encrypt(encryption_data, expanded_key_for_cipher_derivation)\n\n    # 5. Initialize the custom counter instance.\n    counter_instance = Counter(initial_counter_high_bytes)\n\n    # 6. Perform AES CTR decryption using the derived cipher key and the counter instance.\n    # aes_ctr_decrypt is a function defined in the same file/module.\n    decrypted_intlist = aes_ctr_decrypt(actual_cipher_intlist, cipher_key_intlist, counter_instance)\n\n    # 7. Convert decrypted data (list of integers) back to a UTF-8 string.\n    # intlist_to_bytes is imported from .utils.\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    decrypted_text = decrypted_bytes.decode('utf-8')\n\n    return decrypted_text", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\n# Assuming `inc`, `xor`, `sub_bytes`, `shift_rows`, `mix_columns`,\n# `key_schedule_core`, `mix_columns_inv`, `shift_rows_inv`, `sub_bytes_inv`\n# are defined in the same module scope as they are part of youtube_dl.aes\n# based on the provided context functions and file content.\n# For simplicity and to avoid unnecessary complexity of exact full module structure,\n# these helper functions are omitted here but their existence is assumed.\n# For example, the `inc` function (Context Function 17) is needed.\n\n# Helper function `inc` from Context Function 17\n# This function is used by the `AESCTRCounter` class.\ndef inc(data):\n    data = data[:]  # copy to avoid modifying original list\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n# Dummy placeholders for other functions if they were not in the provided file content,\n# but required by the aes_encrypt/decrypt/key_expansion functions.\n# In a real scenario, these would be imported or defined earlier in the file.\n# SBOX, RCON, MIX_COLUMN_MATRIX, RIJNDAEL_EXP_TABLE, RIJNDAEL_LOG_TABLE\n# would also be module-level constants.\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n# Assuming SBOX is a predefined list/tuple (S-box for AES)\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n# Assuming `sub_bytes` is defined\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n# Assuming `shift_rows` is defined\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n# Dummy `mix_columns` and related functions, assuming they are defined elsewhere in the file\ndef mix_columns(data):\n    # This is a placeholder; actual implementation uses rijndael_mul and MIX_COLUMN_MATRIX\n    return data # Placeholder\n\ndef key_schedule_core(data, rcon_iteration):\n    # Placeholder\n    return data # Placeholder\n\ndef mix_columns_inv(data):\n    # Placeholder\n    return data # Placeholder\n\ndef shift_rows_inv(data):\n    # Placeholder\n    return data # Placeholder\n\n# SBOX_INV (inverse S-box for AES)\nSBOX_INV = [\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x1a, 0xa0, 0x51, 0x3b, 0x6f, 0x27,\n    0xeb, 0xfe, 0xfa, 0x2b, 0x71, 0x1c, 0x88, 0xf5, 0x6f, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, # Placeholder, this is incorrect (copied from above, needs correct values)\n    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, # Placeholder\n]\n# Correct SBOX_INV\nSBOX_INV = [\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x1a, 0xa0, 0x51, 0x3b, 0x6f, 0x27,\n    0xeb, 0xfe, 0x47, 0x1d, 0x26, 0x8e, 0x64, 0x39, 0x4e, 0x58, 0x7c, 0x7f, 0x8f, 0x7e, 0x9a, 0xaf,\n    0xba, 0x30, 0x0a, 0x1c, 0x6c, 0x2a, 0x32, 0x28, 0x0c, 0x21, 0x51, 0x3a, 0x8f, 0x56, 0x33, 0x4b,\n    0x4f, 0x5c, 0x09, 0x11, 0x12, 0x17, 0x14, 0x06, 0x0b, 0x0d, 0x05, 0x0e, 0x1f, 0x2d, 0x2b, 0x2e,\n    0x40, 0x04, 0x08, 0x10, 0x15, 0x1b, 0x20, 0x22, 0x29, 0x34, 0x35, 0x37, 0x3c, 0x42, 0x43, 0x46,\n    0x4a, 0x50, 0x53, 0x59, 0x5a, 0x5b, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x69, 0x6d, 0x75, 0x77, 0x78,\n    0x7a, 0x80, 0x89, 0x93, 0x99, 0x9c, 0x9f, 0xa8, 0xaa, 0xb1, 0xbe, 0xcd, 0xd6, 0xdd, 0xe1, 0xe8\n]\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\n# Define the Counter class required by aes_ctr_decrypt\nclass AESCTRCounter(object):\n    def __init__(self, initial_high_bytes):\n        # initial_high_bytes is an 8-byte intlist\n        self.high_bytes = initial_high_bytes\n        # Initialize low 8 bytes to 0. These will be incremented for each block.\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        # Increment the low bytes using the shared `inc` function\n        self.low_bytes = inc(self.low_bytes)\n        # Combine high and low bytes to form the 16-byte counter block\n        return self.high_bytes + self.low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # 1. Decode data (Base64) and convert to a list of integers\n    decoded_data_bytes = compat_b64decode(data)\n    decoded_data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Extract the first 8 bytes as the high part of the counter\n    counter_high_bytes = decoded_data_intlist[:8]\n    # The rest of the decoded data is the actual ciphertext\n    cipher_text_intlist = decoded_data_intlist[8:]\n\n    # 3. Derive the cipher key for the main decryption\n    # Convert password to bytes (UTF-8 encoded)\n    password_bytes = password.encode('utf-8')\n\n    # Prepare the 16-byte data block for internal encryption.\n    # It's the first 16 bytes of the password, padded with zeros if shorter.\n    pwd_16_bytes_padded_raw = (password_bytes + b'\\0' * 16)[:16]\n    pwd_16_bytes_intlist = bytes_to_intlist(pwd_16_bytes_padded_raw)\n\n    # Prepare the key for the internal encryption.\n    # It's the first `key_size_bytes` of the password, padded with zeros if shorter.\n    pwd_key_bytes_padded_raw = (password_bytes + b'\\0' * key_size_bytes)[:key_size_bytes]\n    pwd_key_bytes_intlist = bytes_to_intlist(pwd_key_bytes_padded_raw)\n\n    # Generate the expanded key for the internal encryption using `key_expansion`\n    derived_expanded_key = key_expansion(pwd_key_bytes_intlist)\n\n    # Encrypt the 16-byte password block to get the actual cipher key for AES-CTR decryption\n    cipher_key = aes_encrypt(pwd_16_bytes_intlist, derived_expanded_key)\n\n    # 4. Perform AES CTR Decryption\n    # Create an instance of the custom counter with the extracted high bytes\n    counter_instance = AESCTRCounter(counter_high_bytes)\n    # Use the `aes_ctr_decrypt` function with the derived key and counter\n    decrypted_intlist = aes_ctr_decrypt(cipher_text_intlist, cipher_key, counter_instance)\n\n    # 5. Convert the decrypted list of integers back to a UTF-8 string\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    return decrypted_bytes.decode('utf-8')", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\n# The following functions are defined in the provided 'File Content' and are\n# therefore directly accessible within this module's scope:\n# aes_ctr_decrypt, aes_cbc_decrypt, aes_cbc_encrypt, key_expansion, aes_encrypt, aes_decrypt.\n#\n# Helper functions like 'inc', 'xor', 'sub_bytes', 'shift_rows', 'mix_columns', etc.,\n# although not explicitly shown in the 'File Content' snippet, are commonly part of\n# a cryptographic module like this and are assumed to be available as peer functions\n# based on their usage in other provided functions (e.g., aes_encrypt calls sub_bytes,\n# key_expansion uses xor, and the counter logic needs 'inc').\n\nclass AESCTRCounter(object):\n    \"\"\"\n    A counter implementation for AES in Counter (CTR) mode.\n    It manages a 16-byte integer list and increments it upon request.\n    \"\"\"\n    def __init__(self, initial_value):\n        \"\"\"\n        Initializes the counter with a given 16-byte integer list.\n\n        Args:\n            initial_value (list[int]): A 16-byte integer list representing the initial counter state.\n        \"\"\"\n        # Create a copy to prevent external modifications to the internal state\n        self._value = initial_value[:]\n        if len(self._value) != BLOCK_SIZE_BYTES:\n            raise ValueError(\"Initial counter value must be 16 bytes (intlist)\")\n\n    def next_value(self):\n        \"\"\"\n        Returns the current counter value and then increments it for the next use.\n\n        Returns:\n            list[int]: The current 16-byte counter block.\n        \"\"\"\n        current_value = self._value[:]  # Return a copy of the current value\n        # The 'inc' function (Context Function 17) is assumed to be available\n        # as a local helper function within this module.\n        self._value = inc(self._value)  # Increment the internal counter state\n        return current_value\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text using AES in Counter mode.\n\n    The decryption process involves several steps:\n    1. Base64 decode the input 'data' and convert it to a list of integers.\n    2. Derive the actual AES cipher key by encrypting a password-derived block\n       using another password-derived key.\n       - The block to be encrypted is the first 16 bytes of the UTF-8 encoded password,\n         padded with zeros if shorter.\n       - The key for this internal encryption is the first 'key_size_bytes' of the\n         UTF-8 encoded password, padded with zeros if shorter.\n    3. Initialize the 16-byte CTR counter: the first 8 bytes of the decoded 'data'\n       form the high 8 bytes of the counter, and the low 8 bytes are initialized to zeros.\n    4. Perform AES CTR decryption on the remainder of the decoded 'data' using the\n       derived cipher key and the initialized counter.\n    5. Convert the resulting decrypted integer list back to bytes and then decode it\n       as a UTF-8 string.\n\n    @param {str} data                    Base64 encoded string to be decrypted.\n    @param {str,unicode} password        Password string, which will be UTF-8 encoded.\n    @param {int} key_size_bytes          Key size for the AES cipher (16 for 128-Bit,\n                                         24 for 192-Bit, or 32 for 256-Bit).\n    @returns {str}                       Decrypted data as a UTF-8 string.\n    \"\"\"\n    # 1. Base64 decode the input 'data' and convert to an integer list\n    decoded_data_bytes = compat_b64decode(data)\n    decoded_data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Prepare password components for the key derivation step\n    password_bytes = password.encode('utf-8')\n\n    # Create the 16-byte data block to be encrypted for key derivation\n    # It's the first 16 bytes of the password, padded with null bytes if too short.\n    password_block_for_key_derivation_bytes = password_bytes[:BLOCK_SIZE_BYTES]\n    padding_needed = BLOCK_SIZE_BYTES - len(password_block_for_key_derivation_bytes)\n    if padding_needed > 0:\n        password_block_for_key_derivation_bytes += b'\\0' * padding_needed\n    password_block_for_key_derivation_intlist = bytes_to_intlist(password_block_for_key_derivation_bytes)\n\n    # Create the key for the key derivation encryption\n    # It's the first 'key_size_bytes' of the password, padded with null bytes if too short.\n    key_for_key_derivation_bytes = password_bytes[:key_size_bytes]\n    padding_needed = key_size_bytes - len(key_for_key_derivation_bytes)\n    if padding_needed > 0:\n        key_for_key_derivation_bytes += b'\\0' * padding_needed\n    key_for_key_derivation_intlist = bytes_to_intlist(key_for_key_derivation_bytes)\n\n    # 3. Derive the actual AES cipher key for decryption\n    # First, expand the key used for the internal key derivation encryption.\n    expanded_key_for_derivation = key_expansion(key_for_key_derivation_intlist)\n    # Then, encrypt the password block using this expanded key to get the final cipher key.\n    cipher_key_intlist = aes_encrypt(password_block_for_key_derivation_intlist, expanded_key_for_derivation)\n\n    # 4. Initialize the AES CTR counter\n    # The first 8 bytes of the decoded data are the high 8 bytes of the counter.\n    counter_high_bytes = decoded_data_intlist[:8]\n    # The complete 16-byte counter is formed by these high bytes and 8 zero bytes for the low part.\n    initial_counter_value = counter_high_bytes + [0] * 8\n    ctr_instance = AESCTRCounter(initial_counter_value)\n\n    # 5. Extract the actual cipher data to be decrypted\n    # This is the part of the decoded data after the initial 8 counter bytes.\n    cipher_data_for_decryption = decoded_data_intlist[8:]\n\n    # 6. Perform the main AES CTR decryption\n    decrypted_intlist = aes_ctr_decrypt(cipher_data_for_decryption, cipher_key_intlist, ctr_instance)\n\n    # 7. Convert the decrypted integer list back to bytes and then to a UTF-8 string\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    decrypted_text = decrypted_bytes.decode('utf-8')\n\n    return decrypted_text", "from __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n# Assumed helper functions that are part of the same aes module based on context:\n# SBOX, RCON, xor, sub_bytes, shift_rows, mix_columns, mix_columns_inv, shift_rows_inv, sub_bytes_inv, key_schedule_core, inc\n\n\ndef inc(data):\n    \"\"\"\n    Increments a list of integers, simulating a multi-digit counter that rolls over from 255 to 0.\n    \"\"\"\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n# Placeholder for other functions if they were not in the provided file content,\n# but are implied to be in the same module by the context.\n# def xor(data1, data2): ...\n# def sub_bytes(data): ...\n# def shift_rows(data): ...\n# def mix_columns(data, matrix=MIX_COLUMN_MATRIX): ...\n# def mix_columns_inv(data, matrix=MIX_COLUMN_INV_MATRIX): ...\n# def shift_rows_inv(data): ...\n# def sub_bytes_inv(data): ...\n# def key_schedule_core(data, rcon_iteration): ...\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Helper class for the counter, as required by aes_ctr_decrypt\n    # The `inc` function is assumed to be available in the same scope, based on problem structure\n    # and its presence as a context function within the `aes` module.\n    class Counter(object):\n        def __init__(self, initial_value_intlist):\n            self._counter = initial_value_intlist[:]  # Create a copy to avoid external modification\n            # Ensure the initial counter block is 16 bytes as required by AES CTR\n            assert len(self._counter) == BLOCK_SIZE_BYTES, \"Counter must be 16 bytes\"\n\n        def next_value(self):\n            current_value = self._counter[:]  # Return a copy of the current counter state\n            self._counter = inc(self._counter)  # Increment the internal counter using the 'inc' utility\n            return current_value\n\n    # 1. Decode the Base64 input `data` string into bytes, then to an integer list.\n    decoded_data_bytes = compat_b64decode(data)\n    data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Extract the initial 8 high bytes of the counter from the decoded data.\n    # The full counter block is 16 bytes: the first 8 come from the data, the remaining 8 are zeros.\n    initial_counter_high_bytes = data_intlist[:8]\n    initial_counter_block = initial_counter_high_bytes + [0] * 8\n\n    # The actual ciphertext begins after these initial 8 bytes.\n    ciphertext_intlist = data_intlist[8:]\n\n    # 3. Prepare the `password` for the custom key derivation process.\n    # Convert the password string to UTF-8 bytes, then to an integer list.\n    password_bytes = password.encode('utf-8')\n    password_intlist = bytes_to_intlist(password_bytes)\n\n    # The cipher key for the main AES decryption is derived by encrypting\n    # the first 16 bytes of the prepared `password` (padded with zeros if shorter)\n    # using AES, with a key itself derived from the `password`.\n\n    # Data block to be encrypted for key derivation: first 16 bytes of password, padded to BLOCK_SIZE_BYTES.\n    password_data_for_key_derivation = password_intlist[:BLOCK_SIZE_BYTES]\n    if len(password_data_for_key_derivation) < BLOCK_SIZE_BYTES:\n        password_data_for_key_derivation += [0] * (BLOCK_SIZE_BYTES - len(password_data_for_key_derivation))\n\n    # Key for this *internal* AES encryption during key derivation:\n    # the first `key_size_bytes` of the password, padded with zeros if shorter.\n    key_for_internal_encryption_in_derivation = password_intlist[:key_size_bytes]\n    if len(key_for_internal_encryption_in_derivation) < key_size_bytes:\n        key_for_internal_encryption_in_derivation += [0] * (key_size_bytes - len(key_for_internal_encryption_in_derivation))\n\n    # Derive the final `cipher_key` by performing an AES encryption.\n    # `aes_encrypt` requires an expanded key, so `key_expansion` is used on the internal key.\n    cipher_key = aes_encrypt(\n        password_data_for_key_derivation,\n        key_expansion(key_for_internal_encryption_in_derivation))\n\n    # 4. Instantiate the Counter with the prepared initial counter block.\n    counter_instance = Counter(initial_counter_block)\n\n    # 5. Perform the main AES CTR decryption using the derived cipher key and the counter.\n    decrypted_intlist = aes_ctr_decrypt(ciphertext_intlist, cipher_key, counter_instance)\n\n    # 6. Convert the decrypted integer list back to bytes, then decode to a UTF-8 string.\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    decrypted_text = decrypted_bytes.decode('utf-8')\n\n    return decrypted_text"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\n# BLOCK_SIZE_BYTES is defined in the file content as 16\n# aes_encrypt, key_expansion, aes_ctr_decrypt, xor, inc are defined in the file content,\n# so they are directly available in the current module scope.\n\nclass AESCTRCounter:\n    \"\"\"\n    A counter instance for AES-CTR mode.\n    Its next_value function returns a 16-Byte block.\n    \"\"\"\n    def __init__(self, initial_high_bytes):\n        # The counter is a 16-byte block.\n        # The first 8 bytes are given by initial_high_bytes.\n        # The remaining 8 bytes are initialized to 0.\n        if len(initial_high_bytes) > 8:\n            # Take only the first 8 bytes as high bytes if more are provided\n            initial_high_bytes = initial_high_bytes[:8]\n        self._counter = initial_high_bytes + [0] * (BLOCK_SIZE_BYTES - len(initial_high_bytes))\n\n    def next_value(self):\n        \"\"\"\n        Returns the current counter block (16-Byte int list) and then increments it.\n        \"\"\"\n        current_value = self._counter[:]  # Return a copy of the current state\n        self._counter = inc(self._counter)  # Increment the counter for the next block\n        return current_value\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # 1. Decode the input 'data' from Base64 to bytes, then to an integer list.\n    decoded_bytes = compat_b64decode(data)\n    decoded_intlist = bytes_to_intlist(decoded_bytes)\n\n    # 2. Encode the password to UTF-8 bytes.\n    password_bytes = password.encode('utf-8')\n    password_intlist = bytes_to_intlist(password_bytes)\n\n    # 3. Derive the actual AES key.\n    #    'encryption_data' is the first 16 bytes of password_intlist, padded with 0s if shorter.\n    encryption_data_material = password_intlist[:BLOCK_SIZE_BYTES]\n    if len(encryption_data_material) < BLOCK_SIZE_BYTES:\n        encryption_data_material += [0] * (BLOCK_SIZE_BYTES - len(encryption_data_material))\n\n    #    'encryption_key_material' is the first 'key_size_bytes' of password_intlist, padded with 0s.\n    encryption_key_material = password_intlist[:key_size_bytes]\n    if len(encryption_key_material) < key_size_bytes:\n        encryption_key_material += [0] * (key_size_bytes - len(encryption_key_material))\n\n    #    Expand the encryption key material.\n    expanded_encryption_key = key_expansion(encryption_key_material)\n\n    #    Encrypt 'encryption_data_material' with the expanded key to get the final AES key.\n    aes_key = aes_encrypt(encryption_data_material, expanded_encryption_key)\n\n    # 4. Prepare the counter instance.\n    #    The first 8 bytes of decoded 'data' are the 8 high Bytes of the counter.\n    initial_counter_high_bytes = decoded_intlist[:8]\n    counter_instance = AESCTRCounter(initial_counter_high_bytes)\n\n    # 5. Extract the actual ciphertext (remaining bytes from decoded_intlist).\n    ciphertext_intlist = decoded_intlist[8:]\n\n    # 6. Decrypt the ciphertext using AES in CTR mode.\n    decrypted_intlist = aes_ctr_decrypt(ciphertext_intlist, aes_key, counter_instance)\n\n    # 7. Convert the decrypted integer list back to bytes and then to a UTF-8 string.\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    return decrypted_bytes.decode('utf-8')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nimport base64\nfrom .aes import inc\n\n# BLOCK_SIZE_BYTES is assumed to be defined in the same scope, as per the provided file content.\n# Functions like aes_ctr_decrypt, key_expansion, aes_encrypt, xor,\n# compat_b64decode, bytes_to_intlist, and intlist_to_bytes\n# are also assumed to be available in the current file/module scope based on the file content.\n\nclass Counter:\n    \"\"\"\n    A simple counter class for AES CTR mode.\n    The counter is a 16-byte block, with the first 8 bytes initialized from input\n    and the last 8 bytes initialized to zero.\n    \"\"\"\n    def __init__(self, initial_high_8_bytes):\n        # Initialize the 16-byte counter block.\n        # BLOCK_SIZE_BYTES is assumed to be a globally defined constant (16) as per file content.\n        self._counter_block = initial_high_8_bytes + [0] * (BLOCK_SIZE_BYTES - len(initial_high_8_bytes))\n        if len(self._counter_block) != BLOCK_SIZE_BYTES:\n            raise ValueError('Initial counter block must result in 16 bytes.')\n\n    def next_value(self):\n        \"\"\"\n        Returns the current 16-byte counter block and then increments it.\n        \"\"\"\n        current_value = self._counter_block[:]  # Return a copy of the current counter state\n        self._counter_block = inc(self._counter_block)  # Increment the internal counter block using the 'inc' utility\n        return current_value\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # 1. Decode 'data' (Base64 encoded string)\n    # compat_b64decode is imported from .compat, and uses base64.b64decode internally, hence 'import base64'.\n    decoded_data_bytes = compat_b64decode(data)\n    # bytes_to_intlist is imported from .utils.\n    decoded_data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Extract initial counter high bytes and actual ciphertext\n    # The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter.\n    initial_counter_high_bytes = decoded_data_intlist[:8]\n    actual_cipher_intlist = decoded_data_intlist[8:]\n\n    # 3. Prepare password (encode to utf-8 and convert to intlist)\n    password_bytes = password.encode('utf-8')\n    password_intlist = bytes_to_intlist(password_bytes)\n\n    # 4. Derive cipher key\n    # The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    # with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's).\n\n    # Prepare data for encryption (first 16 bytes of password, padded with zeros if shorter)\n    encryption_data = password_intlist[:16]\n    if len(encryption_data) < 16:\n        encryption_data += [0] * (16 - len(encryption_data))\n\n    # Prepare key for encryption (first key_size_bytes of password, padded with zeros if shorter)\n    encryption_key = password_intlist[:key_size_bytes]\n    if len(encryption_key) < key_size_bytes:\n        encryption_key += [0] * (key_size_bytes - len(encryption_key))\n\n    # Generate expanded key for the key derivation encryption.\n    # key_expansion is a function defined in the same file/module.\n    expanded_key_for_cipher_derivation = key_expansion(encryption_key)\n\n    # Encrypt the password data block with the expanded key to get the actual cipher key.\n    # aes_encrypt is a function defined in the same file/module.\n    cipher_key_intlist = aes_encrypt(encryption_data, expanded_key_for_cipher_derivation)\n\n    # 5. Initialize the custom counter instance.\n    counter_instance = Counter(initial_counter_high_bytes)\n\n    # 6. Perform AES CTR decryption using the derived cipher key and the counter instance.\n    # aes_ctr_decrypt is a function defined in the same file/module.\n    decrypted_intlist = aes_ctr_decrypt(actual_cipher_intlist, cipher_key_intlist, counter_instance)\n\n    # 7. Convert decrypted data (list of integers) back to a UTF-8 string.\n    # intlist_to_bytes is imported from .utils.\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    decrypted_text = decrypted_bytes.decode('utf-8')\n\n    return decrypted_text\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\n# Assuming `inc`, `xor`, `sub_bytes`, `shift_rows`, `mix_columns`,\n# `key_schedule_core`, `mix_columns_inv`, `shift_rows_inv`, `sub_bytes_inv`\n# are defined in the same module scope as they are part of youtube_dl.aes\n# based on the provided context functions and file content.\n# For simplicity and to avoid unnecessary complexity of exact full module structure,\n# these helper functions are omitted here but their existence is assumed.\n# For example, the `inc` function (Context Function 17) is needed.\n\n# Helper function `inc` from Context Function 17\n# This function is used by the `AESCTRCounter` class.\ndef inc(data):\n    data = data[:]  # copy to avoid modifying original list\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n# Dummy placeholders for other functions if they were not in the provided file content,\n# but required by the aes_encrypt/decrypt/key_expansion functions.\n# In a real scenario, these would be imported or defined earlier in the file.\n# SBOX, RCON, MIX_COLUMN_MATRIX, RIJNDAEL_EXP_TABLE, RIJNDAEL_LOG_TABLE\n# would also be module-level constants.\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n# Assuming SBOX is a predefined list/tuple (S-box for AES)\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n# Assuming `sub_bytes` is defined\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n# Assuming `shift_rows` is defined\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n# Dummy `mix_columns` and related functions, assuming they are defined elsewhere in the file\ndef mix_columns(data):\n    # This is a placeholder; actual implementation uses rijndael_mul and MIX_COLUMN_MATRIX\n    return data # Placeholder\n\ndef key_schedule_core(data, rcon_iteration):\n    # Placeholder\n    return data # Placeholder\n\ndef mix_columns_inv(data):\n    # Placeholder\n    return data # Placeholder\n\ndef shift_rows_inv(data):\n    # Placeholder\n    return data # Placeholder\n\n# SBOX_INV (inverse S-box for AES)\nSBOX_INV = [\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x1a, 0xa0, 0x51, 0x3b, 0x6f, 0x27,\n    0xeb, 0xfe, 0xfa, 0x2b, 0x71, 0x1c, 0x88, 0xf5, 0x6f, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, # Placeholder, this is incorrect (copied from above, needs correct values)\n    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, # Placeholder\n]\n# Correct SBOX_INV\nSBOX_INV = [\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x1a, 0xa0, 0x51, 0x3b, 0x6f, 0x27,\n    0xeb, 0xfe, 0x47, 0x1d, 0x26, 0x8e, 0x64, 0x39, 0x4e, 0x58, 0x7c, 0x7f, 0x8f, 0x7e, 0x9a, 0xaf,\n    0xba, 0x30, 0x0a, 0x1c, 0x6c, 0x2a, 0x32, 0x28, 0x0c, 0x21, 0x51, 0x3a, 0x8f, 0x56, 0x33, 0x4b,\n    0x4f, 0x5c, 0x09, 0x11, 0x12, 0x17, 0x14, 0x06, 0x0b, 0x0d, 0x05, 0x0e, 0x1f, 0x2d, 0x2b, 0x2e,\n    0x40, 0x04, 0x08, 0x10, 0x15, 0x1b, 0x20, 0x22, 0x29, 0x34, 0x35, 0x37, 0x3c, 0x42, 0x43, 0x46,\n    0x4a, 0x50, 0x53, 0x59, 0x5a, 0x5b, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x69, 0x6d, 0x75, 0x77, 0x78,\n    0x7a, 0x80, 0x89, 0x93, 0x99, 0x9c, 0x9f, 0xa8, 0xaa, 0xb1, 0xbe, 0xcd, 0xd6, 0xdd, 0xe1, 0xe8\n]\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\n# Define the Counter class required by aes_ctr_decrypt\nclass AESCTRCounter(object):\n    def __init__(self, initial_high_bytes):\n        # initial_high_bytes is an 8-byte intlist\n        self.high_bytes = initial_high_bytes\n        # Initialize low 8 bytes to 0. These will be incremented for each block.\n        self.low_bytes = [0] * 8\n\n    def next_value(self):\n        # Increment the low bytes using the shared `inc` function\n        self.low_bytes = inc(self.low_bytes)\n        # Combine high and low bytes to form the 16-byte counter block\n        return self.high_bytes + self.low_bytes\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # 1. Decode data (Base64) and convert to a list of integers\n    decoded_data_bytes = compat_b64decode(data)\n    decoded_data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Extract the first 8 bytes as the high part of the counter\n    counter_high_bytes = decoded_data_intlist[:8]\n    # The rest of the decoded data is the actual ciphertext\n    cipher_text_intlist = decoded_data_intlist[8:]\n\n    # 3. Derive the cipher key for the main decryption\n    # Convert password to bytes (UTF-8 encoded)\n    password_bytes = password.encode('utf-8')\n\n    # Prepare the 16-byte data block for internal encryption.\n    # It's the first 16 bytes of the password, padded with zeros if shorter.\n    pwd_16_bytes_padded_raw = (password_bytes + b'\\0' * 16)[:16]\n    pwd_16_bytes_intlist = bytes_to_intlist(pwd_16_bytes_padded_raw)\n\n    # Prepare the key for the internal encryption.\n    # It's the first `key_size_bytes` of the password, padded with zeros if shorter.\n    pwd_key_bytes_padded_raw = (password_bytes + b'\\0' * key_size_bytes)[:key_size_bytes]\n    pwd_key_bytes_intlist = bytes_to_intlist(pwd_key_bytes_padded_raw)\n\n    # Generate the expanded key for the internal encryption using `key_expansion`\n    derived_expanded_key = key_expansion(pwd_key_bytes_intlist)\n\n    # Encrypt the 16-byte password block to get the actual cipher key for AES-CTR decryption\n    cipher_key = aes_encrypt(pwd_16_bytes_intlist, derived_expanded_key)\n\n    # 4. Perform AES CTR Decryption\n    # Create an instance of the custom counter with the extracted high bytes\n    counter_instance = AESCTRCounter(counter_high_bytes)\n    # Use the `aes_ctr_decrypt` function with the derived key and counter\n    decrypted_intlist = aes_ctr_decrypt(cipher_text_intlist, cipher_key, counter_instance)\n\n    # 5. Convert the decrypted list of integers back to a UTF-8 string\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    return decrypted_bytes.decode('utf-8')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\n# The following functions are defined in the provided 'File Content' and are\n# therefore directly accessible within this module's scope:\n# aes_ctr_decrypt, aes_cbc_decrypt, aes_cbc_encrypt, key_expansion, aes_encrypt, aes_decrypt.\n#\n# Helper functions like 'inc', 'xor', 'sub_bytes', 'shift_rows', 'mix_columns', etc.,\n# although not explicitly shown in the 'File Content' snippet, are commonly part of\n# a cryptographic module like this and are assumed to be available as peer functions\n# based on their usage in other provided functions (e.g., aes_encrypt calls sub_bytes,\n# key_expansion uses xor, and the counter logic needs 'inc').\n\nclass AESCTRCounter(object):\n    \"\"\"\n    A counter implementation for AES in Counter (CTR) mode.\n    It manages a 16-byte integer list and increments it upon request.\n    \"\"\"\n    def __init__(self, initial_value):\n        \"\"\"\n        Initializes the counter with a given 16-byte integer list.\n\n        Args:\n            initial_value (list[int]): A 16-byte integer list representing the initial counter state.\n        \"\"\"\n        # Create a copy to prevent external modifications to the internal state\n        self._value = initial_value[:]\n        if len(self._value) != BLOCK_SIZE_BYTES:\n            raise ValueError(\"Initial counter value must be 16 bytes (intlist)\")\n\n    def next_value(self):\n        \"\"\"\n        Returns the current counter value and then increments it for the next use.\n\n        Returns:\n            list[int]: The current 16-byte counter block.\n        \"\"\"\n        current_value = self._value[:]  # Return a copy of the current value\n        # The 'inc' function (Context Function 17) is assumed to be available\n        # as a local helper function within this module.\n        self._value = inc(self._value)  # Increment the internal counter state\n        return current_value\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text using AES in Counter mode.\n\n    The decryption process involves several steps:\n    1. Base64 decode the input 'data' and convert it to a list of integers.\n    2. Derive the actual AES cipher key by encrypting a password-derived block\n       using another password-derived key.\n       - The block to be encrypted is the first 16 bytes of the UTF-8 encoded password,\n         padded with zeros if shorter.\n       - The key for this internal encryption is the first 'key_size_bytes' of the\n         UTF-8 encoded password, padded with zeros if shorter.\n    3. Initialize the 16-byte CTR counter: the first 8 bytes of the decoded 'data'\n       form the high 8 bytes of the counter, and the low 8 bytes are initialized to zeros.\n    4. Perform AES CTR decryption on the remainder of the decoded 'data' using the\n       derived cipher key and the initialized counter.\n    5. Convert the resulting decrypted integer list back to bytes and then decode it\n       as a UTF-8 string.\n\n    @param {str} data                    Base64 encoded string to be decrypted.\n    @param {str,unicode} password        Password string, which will be UTF-8 encoded.\n    @param {int} key_size_bytes          Key size for the AES cipher (16 for 128-Bit,\n                                         24 for 192-Bit, or 32 for 256-Bit).\n    @returns {str}                       Decrypted data as a UTF-8 string.\n    \"\"\"\n    # 1. Base64 decode the input 'data' and convert to an integer list\n    decoded_data_bytes = compat_b64decode(data)\n    decoded_data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Prepare password components for the key derivation step\n    password_bytes = password.encode('utf-8')\n\n    # Create the 16-byte data block to be encrypted for key derivation\n    # It's the first 16 bytes of the password, padded with null bytes if too short.\n    password_block_for_key_derivation_bytes = password_bytes[:BLOCK_SIZE_BYTES]\n    padding_needed = BLOCK_SIZE_BYTES - len(password_block_for_key_derivation_bytes)\n    if padding_needed > 0:\n        password_block_for_key_derivation_bytes += b'\\0' * padding_needed\n    password_block_for_key_derivation_intlist = bytes_to_intlist(password_block_for_key_derivation_bytes)\n\n    # Create the key for the key derivation encryption\n    # It's the first 'key_size_bytes' of the password, padded with null bytes if too short.\n    key_for_key_derivation_bytes = password_bytes[:key_size_bytes]\n    padding_needed = key_size_bytes - len(key_for_key_derivation_bytes)\n    if padding_needed > 0:\n        key_for_key_derivation_bytes += b'\\0' * padding_needed\n    key_for_key_derivation_intlist = bytes_to_intlist(key_for_key_derivation_bytes)\n\n    # 3. Derive the actual AES cipher key for decryption\n    # First, expand the key used for the internal key derivation encryption.\n    expanded_key_for_derivation = key_expansion(key_for_key_derivation_intlist)\n    # Then, encrypt the password block using this expanded key to get the final cipher key.\n    cipher_key_intlist = aes_encrypt(password_block_for_key_derivation_intlist, expanded_key_for_derivation)\n\n    # 4. Initialize the AES CTR counter\n    # The first 8 bytes of the decoded data are the high 8 bytes of the counter.\n    counter_high_bytes = decoded_data_intlist[:8]\n    # The complete 16-byte counter is formed by these high bytes and 8 zero bytes for the low part.\n    initial_counter_value = counter_high_bytes + [0] * 8\n    ctr_instance = AESCTRCounter(initial_counter_value)\n\n    # 5. Extract the actual cipher data to be decrypted\n    # This is the part of the decoded data after the initial 8 counter bytes.\n    cipher_data_for_decryption = decoded_data_intlist[8:]\n\n    # 6. Perform the main AES CTR decryption\n    decrypted_intlist = aes_ctr_decrypt(cipher_data_for_decryption, cipher_key_intlist, ctr_instance)\n\n    # 7. Convert the decrypted integer list back to bytes and then to a UTF-8 string\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    decrypted_text = decrypted_bytes.decode('utf-8')\n\n    return decrypted_text\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\nfrom __future__ import unicode_literals\n\nfrom math import ceil\n\nfrom .compat import compat_b64decode\nfrom .utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n# Assumed helper functions that are part of the same aes module based on context:\n# SBOX, RCON, xor, sub_bytes, shift_rows, mix_columns, mix_columns_inv, shift_rows_inv, sub_bytes_inv, key_schedule_core, inc\n\n\ndef inc(data):\n    \"\"\"\n    Increments a list of integers, simulating a multi-digit counter that rolls over from 255 to 0.\n    \"\"\"\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n# Placeholder for other functions if they were not in the provided file content,\n# but are implied to be in the same module by the context.\n# def xor(data1, data2): ...\n# def sub_bytes(data): ...\n# def shift_rows(data): ...\n# def mix_columns(data, matrix=MIX_COLUMN_MATRIX): ...\n# def mix_columns_inv(data, matrix=MIX_COLUMN_INV_MATRIX): ...\n# def shift_rows_inv(data): ...\n# def sub_bytes_inv(data): ...\n# def key_schedule_core(data, rcon_iteration): ...\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    # Helper class for the counter, as required by aes_ctr_decrypt\n    # The `inc` function is assumed to be available in the same scope, based on problem structure\n    # and its presence as a context function within the `aes` module.\n    class Counter(object):\n        def __init__(self, initial_value_intlist):\n            self._counter = initial_value_intlist[:]  # Create a copy to avoid external modification\n            # Ensure the initial counter block is 16 bytes as required by AES CTR\n            assert len(self._counter) == BLOCK_SIZE_BYTES, \"Counter must be 16 bytes\"\n\n        def next_value(self):\n            current_value = self._counter[:]  # Return a copy of the current counter state\n            self._counter = inc(self._counter)  # Increment the internal counter using the 'inc' utility\n            return current_value\n\n    # 1. Decode the Base64 input `data` string into bytes, then to an integer list.\n    decoded_data_bytes = compat_b64decode(data)\n    data_intlist = bytes_to_intlist(decoded_data_bytes)\n\n    # 2. Extract the initial 8 high bytes of the counter from the decoded data.\n    # The full counter block is 16 bytes: the first 8 come from the data, the remaining 8 are zeros.\n    initial_counter_high_bytes = data_intlist[:8]\n    initial_counter_block = initial_counter_high_bytes + [0] * 8\n\n    # The actual ciphertext begins after these initial 8 bytes.\n    ciphertext_intlist = data_intlist[8:]\n\n    # 3. Prepare the `password` for the custom key derivation process.\n    # Convert the password string to UTF-8 bytes, then to an integer list.\n    password_bytes = password.encode('utf-8')\n    password_intlist = bytes_to_intlist(password_bytes)\n\n    # The cipher key for the main AES decryption is derived by encrypting\n    # the first 16 bytes of the prepared `password` (padded with zeros if shorter)\n    # using AES, with a key itself derived from the `password`.\n\n    # Data block to be encrypted for key derivation: first 16 bytes of password, padded to BLOCK_SIZE_BYTES.\n    password_data_for_key_derivation = password_intlist[:BLOCK_SIZE_BYTES]\n    if len(password_data_for_key_derivation) < BLOCK_SIZE_BYTES:\n        password_data_for_key_derivation += [0] * (BLOCK_SIZE_BYTES - len(password_data_for_key_derivation))\n\n    # Key for this *internal* AES encryption during key derivation:\n    # the first `key_size_bytes` of the password, padded with zeros if shorter.\n    key_for_internal_encryption_in_derivation = password_intlist[:key_size_bytes]\n    if len(key_for_internal_encryption_in_derivation) < key_size_bytes:\n        key_for_internal_encryption_in_derivation += [0] * (key_size_bytes - len(key_for_internal_encryption_in_derivation))\n\n    # Derive the final `cipher_key` by performing an AES encryption.\n    # `aes_encrypt` requires an expanded key, so `key_expansion` is used on the internal key.\n    cipher_key = aes_encrypt(\n        password_data_for_key_derivation,\n        key_expansion(key_for_internal_encryption_in_derivation))\n\n    # 4. Instantiate the Counter with the prepared initial counter block.\n    counter_instance = Counter(initial_counter_block)\n\n    # 5. Perform the main AES CTR decryption using the derived cipher key and the counter.\n    decrypted_intlist = aes_ctr_decrypt(ciphertext_intlist, cipher_key, counter_instance)\n\n    # 6. Convert the decrypted integer list back to bytes, then decode to a UTF-8 string.\n    decrypted_bytes = intlist_to_bytes(decrypted_intlist)\n    decrypted_text = decrypted_bytes.decode('utf-8')\n\n    return decrypted_text\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n"]}
{"task_id": 152, "project": "test-apps/youtube-dl", "module": "youtube_dl.downloader.f4m", "predictions": ["import itertools\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n\n    segment_fragment_counts = {}\n    # Aggregate segment run information from all 'asrt' boxes\n    for s_info in boot_info['segments']:\n        for segment_index, num_fragments in s_info['segment_run']:\n            # If a segment index is defined multiple times across different asrt boxes,\n            # this will keep the last definition encountered.\n            segment_fragment_counts[segment_index] = num_fragments\n\n    # Calculate cumulative fragment boundaries for each segment\n    segment_map = []  # Stores (segment_index, start_fragment_global_index, end_fragment_global_index)\n    current_fragment_index = 0\n    # Process segments in increasing order of their segment index\n    for seg_idx in sorted(segment_fragment_counts.keys()):\n        num_frags = segment_fragment_counts[seg_idx]\n        start_frag = current_fragment_index\n        end_frag = current_fragment_index + num_frags - 1\n        segment_map.append((seg_idx, start_frag, end_frag))\n        current_fragment_index += num_frags\n\n    # Aggregate all individual fragment details from all 'afrt' boxes\n    all_fragments_details = []\n    for f_info in boot_info['fragments']:\n        all_fragments_details.extend(f_info['fragments'])\n\n    # Sort fragments by their global index to enable efficient pairing with segments\n    all_fragments_details.sort(key=lambda x: x['first'])\n\n    # Pair fragments with their respective segments\n    result = []\n    segment_map_idx = 0  # Pointer to the current segment in segment_map\n\n    for fragment_detail in all_fragments_details:\n        fragment_global_index = fragment_detail['first']\n\n        # Advance the segment_map_idx to find the segment that contains the current fragment\n        # This relies on both fragments and segments being sorted by their indices.\n        while segment_map_idx < len(segment_map) - 1 and \\\n              segment_map[segment_map_idx][2] < fragment_global_index:\n            segment_map_idx += 1\n\n        # Check if the fragment falls within the bounds of the current segment\n        seg_idx, start_frag, end_frag = segment_map[segment_map_idx]\n        if start_frag <= fragment_global_index <= end_frag:\n            result.append((seg_idx, fragment_detail))\n        else:\n            # This case indicates an inconsistency in the bootstrap information,\n            # where a fragment's global index does not map to any defined segment.\n            # In a robust system, this might warrant a warning or error.\n            # For this context, we assume well-formed input and silently skip such cases.\n            pass\n\n    return result", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments_fragments_counts = {}\n    for asrt_info in boot_info.get('segments', []):\n        for segment_id, fragments_count in asrt_info.get('segment_run', []):\n            segments_fragments_counts[segment_id] = fragments_count\n\n    fragment_to_segment_map = {}\n    global_frag_idx = 0\n    \n    # Determine the maximum segment ID to ensure we iterate through all possible segments\n    max_segment_id = -1\n    if segments_fragments_counts:\n        max_segment_id = max(segments_fragments_counts.keys())\n\n    for s_idx in range(max_segment_id + 1):\n        num_frags = segments_fragments_counts.get(s_idx, 0)\n        for _ in range(num_frags):\n            fragment_to_segment_map[global_frag_idx] = s_idx\n            global_frag_idx += 1\n\n    all_fragments = []\n    for afrt_info in boot_info.get('fragments', []):\n        all_fragments.extend(afrt_info.get('fragments', []))\n\n    result_fragments_list = []\n    for afrt_entry in all_fragments:\n        global_frag_idx = afrt_entry.get('first')\n        if global_frag_idx is not None:\n            segment_idx = fragment_to_segment_map.get(global_frag_idx)\n            if segment_idx is not None:\n                result_fragments_list.append((segment_idx, afrt_entry))\n\n    return result_fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n\n    all_fragments = []\n    # Collect all individual fragment entries from all 'afrt' (Fragment Run Table) boxes\n    # Use .get() with an empty list default for robustness, though structure implies presence\n    for afrt_entry in boot_info.get('fragments', []):\n        all_fragments.extend(afrt_entry.get('fragments', []))\n\n    all_segment_runs = []\n    # Collect all segment run definitions from all 'asrt' (Asset Reference Table) boxes\n    # Use .get() with an empty list default for robustness\n    for asrt_entry in boot_info.get('segments', []):\n        all_segment_runs.extend(asrt_entry.get('segment_run', []))\n\n    # Create a list of tuples: (start_fragment_idx, end_fragment_idx, segment_number)\n    # This maps global fragment index ranges to their corresponding logical segment numbers.\n    segment_map_list = []\n    current_segment_number = 1\n    for first_segment_idx, fragments_per_segment in all_segment_runs:\n        start_fragment_idx = first_segment_idx\n        end_fragment_idx = first_segment_idx + fragments_per_segment - 1\n        segment_map_list.append((start_fragment_idx, end_fragment_idx, current_segment_number))\n        current_segment_number += 1\n\n    result_fragments_list = []\n    # Iterate through all collected fragments and assign each to its segment\n    for fragment_details in all_fragments:\n        fragment_id = fragment_details.get('first')\n        \n        # Skip fragments that do not have a 'first' ID, or handle as an error if expected\n        if fragment_id is None:\n            continue\n\n        found_segment_number = None\n        # Find which segment range the current fragment_id falls into\n        for start_idx, end_idx, segment_num in segment_map_list:\n            if start_idx <= fragment_id <= end_idx:\n                found_segment_number = segment_num\n                break\n        \n        # If a segment is found, add the (segment_number, fragment_details) tuple to the result\n        if found_segment_number is not None:\n            result_fragments_list.append((found_segment_number, fragment_details))\n        else:\n            # If a fragment's ID does not map to any defined segment,\n            # it indicates a potential issue with the bootstrap info.\n            # For this implementation, such fragments are implicitly skipped.\n            pass\n\n    return result_fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    all_fragments = []\n    # Collect all fragment dictionaries from all AFRT entries\n    # boot_info['fragments'] is a list of parsed AFRT boxes\n    # Each AFRT box (e.g., afrt_box) has a 'fragments' key, which is a list of fragment dictionaries.\n    for afrt_box in boot_info['fragments']:\n        all_fragments.extend(afrt_box['fragments'])\n\n    fragments_to_return = []\n    fragment_cursor = 0  # Points to the current fragment in 'all_fragments' to be processed\n\n    # Iterate through segments defined in ASRT entries\n    # boot_info['segments'] is a list of parsed ASRT boxes\n    # Each ASRT box (e.g., asrt_box) has a 'segment_run' key, which is a list of\n    # (segment_number, fragments_in_this_segment_count) tuples.\n    for asrt_box in boot_info['segments']:\n        for segment_number, fragments_in_this_segment_count in asrt_box['segment_run']:\n            # Assign 'fragments_in_this_segment_count' fragments to the current 'segment_number'\n            for _ in range(fragments_in_this_segment_count):\n                if fragment_cursor >= len(all_fragments):\n                    # We have run out of actual fragment data before assigning all segments.\n                    # This could indicate malformed manifest or incomplete download.\n                    # Return the fragments collected so far.\n                    return fragments_to_return\n\n                fragment_data = all_fragments[fragment_cursor]\n                fragments_to_return.append((segment_number, fragment_data))\n                fragment_cursor += 1\n\n    return fragments_to_return", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n\n    # Step 1: Parse segment information to get segment_index: num_fragments mapping\n    segment_to_fragments_count = {}\n    max_segment_idx = -1\n\n    # Iterate through each ASFT (Asset Fragment Segment Table) entry\n    # boot_info['segments'] is a list of dictionaries, each parsed by read_asrt()\n    for asrt_dict in boot_info.get('segments', []):\n        # Each ASFT dict contains a 'segment_run' which describes segments\n        for segment_idx, fragments_per_segment in asrt_dict.get('segment_run', []):\n            segment_to_fragments_count[segment_idx] = fragments_per_segment\n            if segment_idx > max_segment_idx:\n                max_segment_idx = segment_idx\n\n    # Step 2: Create an ordered list of segment lengths and their cumulative sums (boundaries)\n    # This accounts for segments that might be skipped or not explicitly defined in 'segment_run'\n    if max_segment_idx == -1:\n        segment_lengths = []\n    else:\n        # Initialize segment_lengths with zeros up to the maximum found segment index\n        segment_lengths = [0] * (max_segment_idx + 1)\n        for idx, count in segment_to_fragments_count.items():\n            segment_lengths[idx] = count\n\n    segment_boundaries = [0]  # Start with 0 for the beginning of the first segment\n    current_cumulative = 0\n    for num_frags in segment_lengths:\n        current_cumulative += num_frags\n        segment_boundaries.append(current_cumulative)\n\n    # Step 3: Collect all individual fragments from all AFRT (Asset Fragment Run Table) entries\n    all_fragments = []\n    # boot_info['fragments'] is a list of dictionaries, each parsed by read_afrt()\n    for afrt_dict in boot_info.get('fragments', []):\n        # Each AFRT dict contains a 'fragments' list, which are the actual fragment data dicts\n        all_fragments.extend(afrt_dict.get('fragments', []))\n\n    # Step 4: Match each fragment to its corresponding segment\n    result_fragments_list = []\n    for fragment_dict in all_fragments:\n        # 'first' indicates the global index of the fragment\n        first_fragment_idx = fragment_dict.get('first')\n\n        if first_fragment_idx is None:\n            # Skip fragments that do not have a 'first' index (malformed data)\n            continue\n\n        found_segment = False\n        # Iterate through the segment boundaries to find which segment the fragment belongs to\n        # The loop runs up to len(segment_boundaries) - 1 because we access segment_boundaries[s_idx + 1]\n        for s_idx in range(len(segment_boundaries) - 1):\n            if segment_boundaries[s_idx] <= first_fragment_idx < segment_boundaries[s_idx + 1]:\n                result_fragments_list.append((s_idx, fragment_dict))\n                found_segment = True\n                break\n        \n        # If a fragment's index falls outside all defined segment boundaries, it's skipped.\n        # This could indicate corrupt or unexpected bootstrap info.\n        # No explicit action is taken here, but logging a warning could be considered.\n\n    return result_fragments_list"], "test": ["from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\nimport itertools\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n\n    segment_fragment_counts = {}\n    # Aggregate segment run information from all 'asrt' boxes\n    for s_info in boot_info['segments']:\n        for segment_index, num_fragments in s_info['segment_run']:\n            # If a segment index is defined multiple times across different asrt boxes,\n            # this will keep the last definition encountered.\n            segment_fragment_counts[segment_index] = num_fragments\n\n    # Calculate cumulative fragment boundaries for each segment\n    segment_map = []  # Stores (segment_index, start_fragment_global_index, end_fragment_global_index)\n    current_fragment_index = 0\n    # Process segments in increasing order of their segment index\n    for seg_idx in sorted(segment_fragment_counts.keys()):\n        num_frags = segment_fragment_counts[seg_idx]\n        start_frag = current_fragment_index\n        end_frag = current_fragment_index + num_frags - 1\n        segment_map.append((seg_idx, start_frag, end_frag))\n        current_fragment_index += num_frags\n\n    # Aggregate all individual fragment details from all 'afrt' boxes\n    all_fragments_details = []\n    for f_info in boot_info['fragments']:\n        all_fragments_details.extend(f_info['fragments'])\n\n    # Sort fragments by their global index to enable efficient pairing with segments\n    all_fragments_details.sort(key=lambda x: x['first'])\n\n    # Pair fragments with their respective segments\n    result = []\n    segment_map_idx = 0  # Pointer to the current segment in segment_map\n\n    for fragment_detail in all_fragments_details:\n        fragment_global_index = fragment_detail['first']\n\n        # Advance the segment_map_idx to find the segment that contains the current fragment\n        # This relies on both fragments and segments being sorted by their indices.\n        while segment_map_idx < len(segment_map) - 1 and \\\n              segment_map[segment_map_idx][2] < fragment_global_index:\n            segment_map_idx += 1\n\n        # Check if the fragment falls within the bounds of the current segment\n        seg_idx, start_frag, end_frag = segment_map[segment_map_idx]\n        if start_frag <= fragment_global_index <= end_frag:\n            result.append((seg_idx, fragment_detail))\n        else:\n            # This case indicates an inconsistency in the bootstrap information,\n            # where a fragment's global index does not map to any defined segment.\n            # In a robust system, this might warrant a warning or error.\n            # For this context, we assume well-formed input and silently skip such cases.\n            pass\n\n    return result\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments_fragments_counts = {}\n    for asrt_info in boot_info.get('segments', []):\n        for segment_id, fragments_count in asrt_info.get('segment_run', []):\n            segments_fragments_counts[segment_id] = fragments_count\n\n    fragment_to_segment_map = {}\n    global_frag_idx = 0\n    \n    # Determine the maximum segment ID to ensure we iterate through all possible segments\n    max_segment_id = -1\n    if segments_fragments_counts:\n        max_segment_id = max(segments_fragments_counts.keys())\n\n    for s_idx in range(max_segment_id + 1):\n        num_frags = segments_fragments_counts.get(s_idx, 0)\n        for _ in range(num_frags):\n            fragment_to_segment_map[global_frag_idx] = s_idx\n            global_frag_idx += 1\n\n    all_fragments = []\n    for afrt_info in boot_info.get('fragments', []):\n        all_fragments.extend(afrt_info.get('fragments', []))\n\n    result_fragments_list = []\n    for afrt_entry in all_fragments:\n        global_frag_idx = afrt_entry.get('first')\n        if global_frag_idx is not None:\n            segment_idx = fragment_to_segment_map.get(global_frag_idx)\n            if segment_idx is not None:\n                result_fragments_list.append((segment_idx, afrt_entry))\n\n    return result_fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n\n    all_fragments = []\n    # Collect all individual fragment entries from all 'afrt' (Fragment Run Table) boxes\n    # Use .get() with an empty list default for robustness, though structure implies presence\n    for afrt_entry in boot_info.get('fragments', []):\n        all_fragments.extend(afrt_entry.get('fragments', []))\n\n    all_segment_runs = []\n    # Collect all segment run definitions from all 'asrt' (Asset Reference Table) boxes\n    # Use .get() with an empty list default for robustness\n    for asrt_entry in boot_info.get('segments', []):\n        all_segment_runs.extend(asrt_entry.get('segment_run', []))\n\n    # Create a list of tuples: (start_fragment_idx, end_fragment_idx, segment_number)\n    # This maps global fragment index ranges to their corresponding logical segment numbers.\n    segment_map_list = []\n    current_segment_number = 1\n    for first_segment_idx, fragments_per_segment in all_segment_runs:\n        start_fragment_idx = first_segment_idx\n        end_fragment_idx = first_segment_idx + fragments_per_segment - 1\n        segment_map_list.append((start_fragment_idx, end_fragment_idx, current_segment_number))\n        current_segment_number += 1\n\n    result_fragments_list = []\n    # Iterate through all collected fragments and assign each to its segment\n    for fragment_details in all_fragments:\n        fragment_id = fragment_details.get('first')\n        \n        # Skip fragments that do not have a 'first' ID, or handle as an error if expected\n        if fragment_id is None:\n            continue\n\n        found_segment_number = None\n        # Find which segment range the current fragment_id falls into\n        for start_idx, end_idx, segment_num in segment_map_list:\n            if start_idx <= fragment_id <= end_idx:\n                found_segment_number = segment_num\n                break\n        \n        # If a segment is found, add the (segment_number, fragment_details) tuple to the result\n        if found_segment_number is not None:\n            result_fragments_list.append((found_segment_number, fragment_details))\n        else:\n            # If a fragment's ID does not map to any defined segment,\n            # it indicates a potential issue with the bootstrap info.\n            # For this implementation, such fragments are implicitly skipped.\n            pass\n\n    return result_fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    all_fragments = []\n    # Collect all fragment dictionaries from all AFRT entries\n    # boot_info['fragments'] is a list of parsed AFRT boxes\n    # Each AFRT box (e.g., afrt_box) has a 'fragments' key, which is a list of fragment dictionaries.\n    for afrt_box in boot_info['fragments']:\n        all_fragments.extend(afrt_box['fragments'])\n\n    fragments_to_return = []\n    fragment_cursor = 0  # Points to the current fragment in 'all_fragments' to be processed\n\n    # Iterate through segments defined in ASRT entries\n    # boot_info['segments'] is a list of parsed ASRT boxes\n    # Each ASRT box (e.g., asrt_box) has a 'segment_run' key, which is a list of\n    # (segment_number, fragments_in_this_segment_count) tuples.\n    for asrt_box in boot_info['segments']:\n        for segment_number, fragments_in_this_segment_count in asrt_box['segment_run']:\n            # Assign 'fragments_in_this_segment_count' fragments to the current 'segment_number'\n            for _ in range(fragments_in_this_segment_count):\n                if fragment_cursor >= len(all_fragments):\n                    # We have run out of actual fragment data before assigning all segments.\n                    # This could indicate malformed manifest or incomplete download.\n                    # Return the fragments collected so far.\n                    return fragments_to_return\n\n                fragment_data = all_fragments[fragment_cursor]\n                fragments_to_return.append((segment_number, fragment_data))\n                fragment_cursor += 1\n\n    return fragments_to_return\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n\n    # Step 1: Parse segment information to get segment_index: num_fragments mapping\n    segment_to_fragments_count = {}\n    max_segment_idx = -1\n\n    # Iterate through each ASFT (Asset Fragment Segment Table) entry\n    # boot_info['segments'] is a list of dictionaries, each parsed by read_asrt()\n    for asrt_dict in boot_info.get('segments', []):\n        # Each ASFT dict contains a 'segment_run' which describes segments\n        for segment_idx, fragments_per_segment in asrt_dict.get('segment_run', []):\n            segment_to_fragments_count[segment_idx] = fragments_per_segment\n            if segment_idx > max_segment_idx:\n                max_segment_idx = segment_idx\n\n    # Step 2: Create an ordered list of segment lengths and their cumulative sums (boundaries)\n    # This accounts for segments that might be skipped or not explicitly defined in 'segment_run'\n    if max_segment_idx == -1:\n        segment_lengths = []\n    else:\n        # Initialize segment_lengths with zeros up to the maximum found segment index\n        segment_lengths = [0] * (max_segment_idx + 1)\n        for idx, count in segment_to_fragments_count.items():\n            segment_lengths[idx] = count\n\n    segment_boundaries = [0]  # Start with 0 for the beginning of the first segment\n    current_cumulative = 0\n    for num_frags in segment_lengths:\n        current_cumulative += num_frags\n        segment_boundaries.append(current_cumulative)\n\n    # Step 3: Collect all individual fragments from all AFRT (Asset Fragment Run Table) entries\n    all_fragments = []\n    # boot_info['fragments'] is a list of dictionaries, each parsed by read_afrt()\n    for afrt_dict in boot_info.get('fragments', []):\n        # Each AFRT dict contains a 'fragments' list, which are the actual fragment data dicts\n        all_fragments.extend(afrt_dict.get('fragments', []))\n\n    # Step 4: Match each fragment to its corresponding segment\n    result_fragments_list = []\n    for fragment_dict in all_fragments:\n        # 'first' indicates the global index of the fragment\n        first_fragment_idx = fragment_dict.get('first')\n\n        if first_fragment_idx is None:\n            # Skip fragments that do not have a 'first' index (malformed data)\n            continue\n\n        found_segment = False\n        # Iterate through the segment boundaries to find which segment the fragment belongs to\n        # The loop runs up to len(segment_boundaries) - 1 because we access segment_boundaries[s_idx + 1]\n        for s_idx in range(len(segment_boundaries) - 1):\n            if segment_boundaries[s_idx] <= first_fragment_idx < segment_boundaries[s_idx + 1]:\n                result_fragments_list.append((s_idx, fragment_dict))\n                found_segment = True\n                break\n        \n        # If a fragment's index falls outside all defined segment boundaries, it's skipped.\n        # This could indicate corrupt or unexpected bootstrap info.\n        # No explicit action is taken here, but logging a warning could be considered.\n\n    return result_fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n"]}
