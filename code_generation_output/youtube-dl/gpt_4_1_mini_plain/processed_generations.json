{"task_id": 146, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["def aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)", "def aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)", "def aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n\n    # Remove PKCS#7 padding\n    pad_len = decrypted[-1]\n    if pad_len < 1 or pad_len > 16:\n        raise ValueError(\"Invalid padding\")\n    if decrypted[-pad_len:] != bytes([pad_len]) * pad_len:\n        raise ValueError(\"Invalid padding\")\n\n    return list(decrypted[:-pad_len])", "def aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)", "def aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n\n    # Remove PKCS#7 padding\n    pad_len = decrypted[-1]\n    if pad_len < 1 or pad_len > 16:\n        raise ValueError(\"Invalid padding\")\n    if decrypted[-pad_len:] != bytes([pad_len]) * pad_len:\n        raise ValueError(\"Invalid padding\")\n\n    return list(decrypted[:-pad_len])\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    decrypted = cipher.decrypt(bytes(data))\n    return list(decrypted)\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        bytes_to_intlist(compat_b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\\n            aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\\\n            dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\\\n            YnkK\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\")),\n        bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\\n\\\n    aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdMOHYmIpIGMpIHgpIHkpIHkpIHkpIGJ \\n\\\n    AaGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC92Mi9hY2Nlc3MvMzg0NS9jaXMvOS9yYmIvM2IxY2Jm\\n\\\n    ZS12ZTMyM2YwM2U4MzQzMi8wIGMpIGYgc3RvcnJvY2sgaGFzIGJlZW4uDQoNCl0=\\n')),\n            bytes_to_intlist('YELLOW SUBMARINE'),\n            bytes_to_intlist('ICE ICE BABY\\x04\\x04\\x04\\x04')\n        ) == output\ntest_6()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_9()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt([1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18], \n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18],\n                            [1, 4, 7, 7, 13, 15, 18, 15, 13, 4, 1, 7, 7, 13, 15, 18]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n            [67, 84, 66, 76, 85, 68, 84, 80, 49, 48, 67, 84, 73, 76, 68, 84],\n            [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n            [123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123]) == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode('0z8VzZcJNVfj1fqY66qs7Q==')),\n            bytes_to_intlist(compat_b64decode('wgMxajNkhGNEA7wneZmCZw==')),\n            bytes_to_intlist(compat_b64decode('27pVaFAXBGssBkYcJ0x03w==')))) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(\n        [214, 193, 137, 106, 215, 193, 139, 102, 215, 197, 139, 105],\n        [112, 34, 245, 185, 146, 85, 0, 134, 124, 172, 190, 239, 203, 171, 4, 157],\n        [214, 193, 137, 106, 215, 193, 139, 102]\n    ) == output\ntest_18()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')),\n            bytes_to_intlist(compat_b64decode('A45D6674248A32A830794C923C66B884')), \n            bytes_to_intlist(compat_b64decode('AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlYKZ0puZXQvdXRpbHMtMw=='))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_decrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_decrypt(bytes_to_intlist(compat_b64decode(\"DmE3Vl9xbGtOZmFtZXJpKCJNaXQoJFJBTlRFUg==\")),\n                    bytes_to_intlist(compat_b64decode(\"11111111111111111111111111111111\")),\n                    bytes_to_intlist(compat_b64decode(\"1234567890123456\"))) == output\ntest_25()\n\n\n"]}
{"task_id": 147, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    # Convert list of ints to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    pad_len = 16 - (len(data_bytes) % 16)\n    padding = bytes([pad_len] * pad_len)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted = cipher.encrypt(padded_data)\n\n    return list(encrypted)", "def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    block_size = 16\n    # PKCS#7 padding\n    padding_len = block_size - (len(data) % block_size)\n    padded_data = data + [padding_len] * padding_len\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    encrypted = cipher.encrypt(bytes(padded_data))\n\n    return list(encrypted)", "def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    block_size = 16\n    # Convert data, key, iv to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    padding_len = block_size - (len(data_bytes) % block_size)\n    padding = bytes([padding_len] * padding_len)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted = cipher.encrypt(padded_data)\n\n    return list(encrypted)", "def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    block_size = 16\n\n    # Convert data, key, iv to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    padding_len = block_size - (len(data_bytes) % block_size)\n    padding = bytes([padding_len] * padding_len)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted = cipher.encrypt(padded_data)\n\n    return list(encrypted)", "def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    # Convert input lists to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    block_size = 16\n    padding_length = block_size - (len(data_bytes) % block_size)\n    padding = bytes([padding_length] * padding_length)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted_bytes = cipher.encrypt(padded_data)\n\n    return list(encrypted_bytes)"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    # Convert list of ints to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    pad_len = 16 - (len(data_bytes) % 16)\n    padding = bytes([pad_len] * pad_len)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted = cipher.encrypt(padded_data)\n\n    return list(encrypted)\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    block_size = 16\n    # PKCS#7 padding\n    padding_len = block_size - (len(data) % block_size)\n    padded_data = data + [padding_len] * padding_len\n\n    cipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n    encrypted = cipher.encrypt(bytes(padded_data))\n\n    return list(encrypted)\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    block_size = 16\n    # Convert data, key, iv to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    padding_len = block_size - (len(data_bytes) % block_size)\n    padding = bytes([padding_len] * padding_len)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted = cipher.encrypt(padded_data)\n\n    return list(encrypted)\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    block_size = 16\n\n    # Convert data, key, iv to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    padding_len = block_size - (len(data_bytes) % block_size)\n    padding = bytes([padding_len] * padding_len)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted = cipher.encrypt(padded_data)\n\n    return list(encrypted)\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    from Crypto.Cipher import AES\n\n    # Convert input lists to bytes\n    data_bytes = bytes(data)\n    key_bytes = bytes(key)\n    iv_bytes = bytes(iv)\n\n    # PKCS#7 padding\n    block_size = 16\n    padding_length = block_size - (len(data_bytes) % block_size)\n    padding = bytes([padding_length] * padding_length)\n    padded_data = data_bytes + padding\n\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n    encrypted_bytes = cipher.encrypt(padded_data)\n\n    return list(encrypted_bytes)\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_0():\n    assert 16 == len(aes_cbc_encrypt([1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\ntest_0()\n\ndef test_23():\n    assert aes_cbc_encrypt([1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4]\ntest_23()\n\ndef test_28():\n    assert aes_cbc_encrypt([1, 2, 3, 4, 1, 2, 3, 4], [1] * 16, [0] * 16) != [1, 2, 3, 4, 1, 2, 3, 4]\ntest_28()\n\ndef test_38():\n    assert aes_cbc_encrypt([], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == []\ntest_38()\n\ndef test_44():\n    assert aes_cbc_encrypt([], [0] * 32, [0] * 16) == []\ntest_44()\n\ndef test_48():\n    assert aes_cbc_encrypt([], [0x00] * 16, [0x00] * 16) == []\ntest_48()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n                bytes_to_intlist(b\"This is a test. This is only a test.\"),\n                bytes_to_intlist(b\"YELLOW SUBMARINE\"),\n                bytes_to_intlist(b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\")\n            ) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_5()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'A' * 16),\n                                             bytes_to_intlist(b'B' * 16))) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(\n        bytes_to_intlist(\"Hello World!\"),\n        bytes_to_intlist(\"Secret Key123\"),\n        bytes_to_intlist(\"Initialization V3\")\n    )) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 32, [0] * 16) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(\"VIGENERE CIPHER\"), bytes_to_intlist(\"0123456789ABCDEF\"), bytes_to_intlist(\"0123456789ABCDEF\")) == output\ntest_19()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'This is a test!'), bytes_to_intlist(b'This is a key123'), bytes_to_intlist(b'This is an IV456')) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_cbc_encrypt(bytes_to_intlist(\"test\"),\n                                             bytes_to_intlist(\"secretkey\"),\n                                             bytes_to_intlist(\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"))) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(b'ICE ICE BABY\\x04\\x04\\x04\\x04'), bytes_to_intlist(b'YELLOW SUBMARINE'), bytes_to_intlist(b'ICE ICE ICE ICE ICE ICE ICE ICE ICE ')) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(bytes_to_intlist(\"Cryptography is cool\"), bytes_to_intlist(\"AAAAAAAAAAAAAAAA\"), bytes_to_intlist(\"1234567890123456\"))) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([],\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_cbc_encrypt(\n        bytes_to_intlist(compat_b64decode(\"53616C7465645F5F5F5F3030313233343536\")),\n        bytes_to_intlist(compat_b64decode(\"2B7E151628AED2A6ABF7158809CF4F3C\")),\n        bytes_to_intlist(compat_b64decode(\"00000000000000000000000000000000\"))\n    )) == output\ntest_32()\n\ndef test_39():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4], [0] * 16, [0] * 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1,2,3,4,5,6,7,8,9,10,11],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) == output\ntest_42()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0x00] * 16, [0x00] * 16, [0x00] * 16) == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(\n        bytes_to_intlist(b\"This is a secret message\"),\n        bytes_to_intlist(compat_b64decode(\"58QjGzeAhgwIJ7nUF2SsQw==\")),\n        bytes_to_intlist(compat_b64decode(\"Y7i7oCnvU4+1UdIjV4nPog==\"))\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt(bytes_to_intlist(compat_b64decode('jgj5lXftMPkbjHn0xOAQCg==')),\n        bytes_to_intlist(compat_b64decode('hvIrGHqpOVu4/39sBRU6Sg==')),\n        bytes_to_intlist(compat_b64decode('5m2Y0J6ScxX7f8u8+8fzeQ=='))\n    ) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(aes_cbc_encrypt([1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8], \n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n                                     [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])) == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_cbc_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_cbc_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_57()\n\n\n"]}
{"task_id": 148, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["def key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Constants for key expansion\n    Rcon = [\n        0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36,\n        0x6C,0xD8,0xAB,0x4D,0x9A,0x2F,0x5E,0xBC,0x63,0xC6,0x97,\n        0x35,0x6A,0xD4,0xB3,0x7D,0xFA,0xEF,0xC5,0x91\n    ]\n\n    # S-box for substitution in key expansion\n    s_box = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    def sub_word(word):\n        return [s_box[b] for b in word]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    key_len = len(data)  # either 16, 24, or 32\n    assert key_len in (16, 24, 32), \"Invalid key length\"\n\n    Nb = 4\n    Nk = key_len // 4\n    Nr = {4:10, 6:12, 8:14}[Nk]\n\n    w = [0] * (Nb * (Nr + 1) * 4)\n    for i in range(key_len):\n        w[i] = data[i]\n\n    for i in range(Nk, Nb * (Nr + 1)):\n        temp = w[(i-1)*4:(i-1)*4+4]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp))\n            temp[0] ^= Rcon[i//Nk]\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n        for j in range(4):\n            w[i*4+j] = w[(i-Nk)*4+j] ^ temp[j]\n\n    return w", "def key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    nbr_of_bytes = len(data)\n    if nbr_of_bytes not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # Nb is fixed for AES\n    Nb = 4\n    # Nk depends on key size\n    Nk = nbr_of_bytes // 4\n    # Nr (number of rounds) depends on Nk\n    Nr = {4: 10, 6: 12, 8: 14}[Nk]\n\n    # Rcon as defined in AES standard (enough values for max 14 rounds)\n    Rcon = [\n        0x00,\n        0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36,\n        0x6C,0xD8,0xAB,0x4D,0x9A\n    ]\n\n    def sub_word(word):\n        sbox = [\n            # 256-byte S-box table used in AES\n            0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\n            0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\n            0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\n            0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\n            0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\n            0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\n            0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\n            0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\n            0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\n            0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\n            0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\n            0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\n            0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\n            0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\n            0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\n            0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16,\n        ]\n        return [sbox[b] for b in word]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    w = []\n    # First Nk words are just the key\n    for i in range(Nk):\n        w.append(data[4*i:4*i+4])\n\n    # Generate words for all rounds\n    for i in range(Nk, Nb*(Nr+1)):\n        temp = w[i-1]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp))\n            temp[0] ^= Rcon[i//Nk]\n        elif Nk > 6 and (i % Nk) == 4:\n            temp = sub_word(temp)\n        w.append([w[i-Nk][j] ^ temp[j] for j in range(4)])\n\n    # Flatten the list of words into bytes\n    expanded_key = []\n    for word in w:\n        expanded_key.extend(word)\n\n    return expanded_key", "def key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Rijndael S-box\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    rcon = [\n        0x00,\n        0x01, 0x02, 0x04, 0x08,\n        0x10, 0x20, 0x40, 0x80,\n        0x1B, 0x36, 0x6C, 0xD8,\n        0xAB, 0x4D, 0x9A, 0x2F,\n        0x5E, 0xBC, 0x63, 0xC6,\n        0x97, 0x35, 0x6A, 0xD4,\n        0xB3, 0x7D, 0xFA, 0xEF,\n        0xC5, 0x91\n    ]\n\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key size must be 16, 24, or 32 bytes\")\n\n    # Nk = number of 32-bit words comprising the cipher key\n    Nk = key_size // 4\n    # Nb = number of columns (32-bit words) comprising the State, fixed at 4 for AES\n    Nb = 4\n    # Nr = number of rounds, depends on Nk\n    Nr = {4:10, 6:12, 8:14}[Nk]\n\n    # Expanded key length in 32-bit words\n    expanded_key_words = Nb * (Nr + 1)\n\n    # Convert input key bytes into words (4-byte chunks)\n    key_words = []\n    for i in range(Nk):\n        word = (data[4*i] << 24) | (data[4*i+1] << 16) | (data[4*i+2] << 8) | data[4*i+3]\n        key_words.append(word)\n\n    def sub_word(word):\n        return (\n            (sbox[(word >> 24) & 0xFF] << 24) |\n            (sbox[(word >> 16) & 0xFF] << 16) |\n            (sbox[(word >> 8) & 0xFF] << 8) |\n            (sbox[word & 0xFF])\n        )\n\n    def rot_word(word):\n        return ((word << 8) & 0xFFFFFFFF) | (word >> 24)\n\n    w = key_words[:]\n    for i in range(Nk, expanded_key_words):\n        temp = w[i-1]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp)) ^ (rcon[i//Nk] << 24)\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n        w.append(w[i - Nk] ^ temp)\n\n    expanded_key_bytes = []\n    for word in w:\n        expanded_key_bytes.append((word >> 24) & 0xFF)\n        expanded_key_bytes.append((word >> 16) & 0xFF)\n        expanded_key_bytes.append((word >> 8) & 0xFF)\n        expanded_key_bytes.append(word & 0xFF)\n\n    return expanded_key_bytes", "def key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Rijndael S-box\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    # Rcon\n    rcon = [\n        0x00,\n        0x01, 0x02, 0x04, 0x08,\n        0x10, 0x20, 0x40, 0x80,\n        0x1B, 0x36, 0x6C, 0xD8,\n        0xAB, 0x4D, 0x9A, 0x2F,\n        0x5E, 0xBC, 0x63, 0xC6,\n        0x97, 0x35, 0x6A, 0xD4,\n        0xB3, 0x7D, 0xFA, 0xEF,\n        0xC5, 0x91\n    ]\n\n    key_len = len(data)\n    if key_len == 16:\n        Nk = 4\n        Nr = 10\n    elif key_len == 24:\n        Nk = 6\n        Nr = 12\n    elif key_len == 32:\n        Nk = 8\n        Nr = 14\n    else:\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    Nb = 4\n    w = [0] * (Nb * (Nr + 1) * 4)\n    for i in range(key_len):\n        w[i] = data[i]\n\n    def sub_word(word):\n        return [sbox[b] for b in word]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    i = Nk\n    while i < Nb * (Nr + 1):\n        temp = w[(i - 1)*4:(i - 1)*4 + 4]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp))\n            temp[0] ^= rcon[i // Nk]\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n\n        for j in range(4):\n            w[i*4 + j] = w[(i - Nk)*4 + j] ^ temp[j]\n        i += 1\n\n    return w", "def key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Constants\n    Nb = 4  # block size in 32-bit words\n    Nk = len(data) // 4  # key length in 32-bit words (4, 6, 8)\n    Nr = Nk + 6  # number of rounds\n\n    # Rcon array: round constants\n    Rcon = [\n        0x00000000,\n        0x01000000,\n        0x02000000,\n        0x04000000,\n        0x08000000,\n        0x10000000,\n        0x20000000,\n        0x40000000,\n        0x80000000,\n        0x1b000000,\n        0x36000000,\n    ]\n\n    # Helper functions\n\n    def sub_word(word):\n        # AES S-box\n        s_box = [\n            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n            0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n            0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n            0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n            0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n            0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n            0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n            0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n            0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n            0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n            0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n            0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n            0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n            0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n            0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n            0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n            0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n        ]\n        return (\n            (s_box[(word >> 24) & 0xFF] << 24)\n            | (s_box[(word >> 16) & 0xFF] << 16)\n            | (s_box[(word >> 8) & 0xFF] << 8)\n            | s_box[word & 0xFF]\n        )\n\n    def rot_word(word):\n        return ((word << 8) & 0xFFFFFFFF) | ((word >> 24) & 0xFF)\n\n    # Convert input byte list to 32-bit words\n    key_words = []\n    for i in range(Nk):\n        word = (data[4 * i] << 24) | (data[4 * i + 1] << 16) | (data[4 * i + 2] << 8) | data[4 * i + 3]\n        key_words.append(word)\n\n    expanded_key_words = key_words[:]\n    i = Nk\n    while i < Nb * (Nr + 1):\n        temp = expanded_key_words[i - 1]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp)) ^ Rcon[i // Nk]\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n\n        expanded_key_words.append(expanded_key_words[i - Nk] ^ temp)\n        i += 1\n\n    # Convert expanded key words back to bytes\n    expanded_key = []\n    for word in expanded_key_words:\n        expanded_key.append((word >> 24) & 0xFF)\n        expanded_key.append((word >> 16) & 0xFF)\n        expanded_key.append((word >> 8) & 0xFF)\n        expanded_key.append(word & 0xFF)\n\n    return expanded_key"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Constants for key expansion\n    Rcon = [\n        0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36,\n        0x6C,0xD8,0xAB,0x4D,0x9A,0x2F,0x5E,0xBC,0x63,0xC6,0x97,\n        0x35,0x6A,0xD4,0xB3,0x7D,0xFA,0xEF,0xC5,0x91\n    ]\n\n    # S-box for substitution in key expansion\n    s_box = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    def sub_word(word):\n        return [s_box[b] for b in word]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    key_len = len(data)  # either 16, 24, or 32\n    assert key_len in (16, 24, 32), \"Invalid key length\"\n\n    Nb = 4\n    Nk = key_len // 4\n    Nr = {4:10, 6:12, 8:14}[Nk]\n\n    w = [0] * (Nb * (Nr + 1) * 4)\n    for i in range(key_len):\n        w[i] = data[i]\n\n    for i in range(Nk, Nb * (Nr + 1)):\n        temp = w[(i-1)*4:(i-1)*4+4]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp))\n            temp[0] ^= Rcon[i//Nk]\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n        for j in range(4):\n            w[i*4+j] = w[(i-Nk)*4+j] ^ temp[j]\n\n    return w\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    nbr_of_bytes = len(data)\n    if nbr_of_bytes not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # Nb is fixed for AES\n    Nb = 4\n    # Nk depends on key size\n    Nk = nbr_of_bytes // 4\n    # Nr (number of rounds) depends on Nk\n    Nr = {4: 10, 6: 12, 8: 14}[Nk]\n\n    # Rcon as defined in AES standard (enough values for max 14 rounds)\n    Rcon = [\n        0x00,\n        0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36,\n        0x6C,0xD8,0xAB,0x4D,0x9A\n    ]\n\n    def sub_word(word):\n        sbox = [\n            # 256-byte S-box table used in AES\n            0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\n            0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\n            0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\n            0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\n            0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\n            0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\n            0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\n            0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\n            0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\n            0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\n            0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\n            0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\n            0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\n            0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\n            0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\n            0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16,\n        ]\n        return [sbox[b] for b in word]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    w = []\n    # First Nk words are just the key\n    for i in range(Nk):\n        w.append(data[4*i:4*i+4])\n\n    # Generate words for all rounds\n    for i in range(Nk, Nb*(Nr+1)):\n        temp = w[i-1]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp))\n            temp[0] ^= Rcon[i//Nk]\n        elif Nk > 6 and (i % Nk) == 4:\n            temp = sub_word(temp)\n        w.append([w[i-Nk][j] ^ temp[j] for j in range(4)])\n\n    # Flatten the list of words into bytes\n    expanded_key = []\n    for word in w:\n        expanded_key.extend(word)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Rijndael S-box\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    rcon = [\n        0x00,\n        0x01, 0x02, 0x04, 0x08,\n        0x10, 0x20, 0x40, 0x80,\n        0x1B, 0x36, 0x6C, 0xD8,\n        0xAB, 0x4D, 0x9A, 0x2F,\n        0x5E, 0xBC, 0x63, 0xC6,\n        0x97, 0x35, 0x6A, 0xD4,\n        0xB3, 0x7D, 0xFA, 0xEF,\n        0xC5, 0x91\n    ]\n\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key size must be 16, 24, or 32 bytes\")\n\n    # Nk = number of 32-bit words comprising the cipher key\n    Nk = key_size // 4\n    # Nb = number of columns (32-bit words) comprising the State, fixed at 4 for AES\n    Nb = 4\n    # Nr = number of rounds, depends on Nk\n    Nr = {4:10, 6:12, 8:14}[Nk]\n\n    # Expanded key length in 32-bit words\n    expanded_key_words = Nb * (Nr + 1)\n\n    # Convert input key bytes into words (4-byte chunks)\n    key_words = []\n    for i in range(Nk):\n        word = (data[4*i] << 24) | (data[4*i+1] << 16) | (data[4*i+2] << 8) | data[4*i+3]\n        key_words.append(word)\n\n    def sub_word(word):\n        return (\n            (sbox[(word >> 24) & 0xFF] << 24) |\n            (sbox[(word >> 16) & 0xFF] << 16) |\n            (sbox[(word >> 8) & 0xFF] << 8) |\n            (sbox[word & 0xFF])\n        )\n\n    def rot_word(word):\n        return ((word << 8) & 0xFFFFFFFF) | (word >> 24)\n\n    w = key_words[:]\n    for i in range(Nk, expanded_key_words):\n        temp = w[i-1]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp)) ^ (rcon[i//Nk] << 24)\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n        w.append(w[i - Nk] ^ temp)\n\n    expanded_key_bytes = []\n    for word in w:\n        expanded_key_bytes.append((word >> 24) & 0xFF)\n        expanded_key_bytes.append((word >> 16) & 0xFF)\n        expanded_key_bytes.append((word >> 8) & 0xFF)\n        expanded_key_bytes.append(word & 0xFF)\n\n    return expanded_key_bytes\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Rijndael S-box\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    # Rcon\n    rcon = [\n        0x00,\n        0x01, 0x02, 0x04, 0x08,\n        0x10, 0x20, 0x40, 0x80,\n        0x1B, 0x36, 0x6C, 0xD8,\n        0xAB, 0x4D, 0x9A, 0x2F,\n        0x5E, 0xBC, 0x63, 0xC6,\n        0x97, 0x35, 0x6A, 0xD4,\n        0xB3, 0x7D, 0xFA, 0xEF,\n        0xC5, 0x91\n    ]\n\n    key_len = len(data)\n    if key_len == 16:\n        Nk = 4\n        Nr = 10\n    elif key_len == 24:\n        Nk = 6\n        Nr = 12\n    elif key_len == 32:\n        Nk = 8\n        Nr = 14\n    else:\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    Nb = 4\n    w = [0] * (Nb * (Nr + 1) * 4)\n    for i in range(key_len):\n        w[i] = data[i]\n\n    def sub_word(word):\n        return [sbox[b] for b in word]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    i = Nk\n    while i < Nb * (Nr + 1):\n        temp = w[(i - 1)*4:(i - 1)*4 + 4]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp))\n            temp[0] ^= rcon[i // Nk]\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n\n        for j in range(4):\n            w[i*4 + j] = w[(i - Nk)*4 + j] ^ temp[j]\n        i += 1\n\n    return w\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Constants\n    Nb = 4  # block size in 32-bit words\n    Nk = len(data) // 4  # key length in 32-bit words (4, 6, 8)\n    Nr = Nk + 6  # number of rounds\n\n    # Rcon array: round constants\n    Rcon = [\n        0x00000000,\n        0x01000000,\n        0x02000000,\n        0x04000000,\n        0x08000000,\n        0x10000000,\n        0x20000000,\n        0x40000000,\n        0x80000000,\n        0x1b000000,\n        0x36000000,\n    ]\n\n    # Helper functions\n\n    def sub_word(word):\n        # AES S-box\n        s_box = [\n            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n            0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n            0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n            0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n            0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n            0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n            0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n            0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n            0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n            0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n            0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n            0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n            0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n            0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n            0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n            0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n            0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n        ]\n        return (\n            (s_box[(word >> 24) & 0xFF] << 24)\n            | (s_box[(word >> 16) & 0xFF] << 16)\n            | (s_box[(word >> 8) & 0xFF] << 8)\n            | s_box[word & 0xFF]\n        )\n\n    def rot_word(word):\n        return ((word << 8) & 0xFFFFFFFF) | ((word >> 24) & 0xFF)\n\n    # Convert input byte list to 32-bit words\n    key_words = []\n    for i in range(Nk):\n        word = (data[4 * i] << 24) | (data[4 * i + 1] << 16) | (data[4 * i + 2] << 8) | data[4 * i + 3]\n        key_words.append(word)\n\n    expanded_key_words = key_words[:]\n    i = Nk\n    while i < Nb * (Nr + 1):\n        temp = expanded_key_words[i - 1]\n        if i % Nk == 0:\n            temp = sub_word(rot_word(temp)) ^ Rcon[i // Nk]\n        elif Nk > 6 and i % Nk == 4:\n            temp = sub_word(temp)\n\n        expanded_key_words.append(expanded_key_words[i - Nk] ^ temp)\n        i += 1\n\n    # Convert expanded key words back to bytes\n    expanded_key = []\n    for word in expanded_key_words:\n        expanded_key.append((word >> 24) & 0xFF)\n        expanded_key.append((word >> 16) & 0xFF)\n        expanded_key.append((word >> 8) & 0xFF)\n        expanded_key.append(word & 0xFF)\n\n    return expanded_key\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert 240 == len(key_expansion([0] * 32))\ntest_2()\n\ndef test_6():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"WmZeqoc4omTliC9OGcQJzQ==\"))))\ntest_6()\n\ndef test_18():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"iRQaLBzUf14gDRXaJy8HYw==\"))))\ntest_18()\n\ndef test_36():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode('Mu+eYQhP9RdYgPcGlSzb5qg=='))))\ntest_36()\n\ndef test_43():\n    assert 176 == len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]))\ntest_43()\n\ndef test_70():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"qkV1uwegl+ZCw0SJuh1zxA==\"))))\ntest_70()\n\ndef test_72():\n    assert 208 == len(key_expansion([0] * 24))\ntest_72()\n\ndef test_79():\n    assert 176 == len(key_expansion(bytes_to_intlist(compat_b64decode(\"AQIDBAUGBwgJCgsMDQ4PAAE=\"))))\ntest_79()\n\ndef test_87():\n    assert 176 == len(key_expansion([0] * 16))\ntest_87()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"9b7e16924b93d8f849e1d9342a096157\")))) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('PNWdRNYqshmP27Z8FiYdTg==')))) == output\ntest_3()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(b'MTIzNDU2Nzg=')))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"zXWsl1pSgDjR2f5OwWOmAw==\")))) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"PVRwXkZSMzY=\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"47uZ9nUgVlZM\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAA\")))) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"5O/r191p/DvBq0RZYIJ93A==\")))) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0] * 16)) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([int(x) for x in '00 01 02 03 04 05 06 07'.split(' ')])) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"AAAAAAAAAAAAAAAAAAAB\")))) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(b'0123456789abcdeffedcba9876543210'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Yk9MPnZuYyA=')))) == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"ZJve42C0dA==\")))) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhz\"))) ) == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('oTqsJ6V3XaC4wLGJN0zDVs86CjHXBWKK')))) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhz\"))) ) == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('qp4rguG3hC44qib7A4Fs5uP2PQMsy23y')))) == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"SwIoVj+yCkLy69ujM8g6Eg==\")))) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\n        'Cj2tX/OUYAjrWyb7jP5UyGjG3JPW4J8q')))) == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('XvB54dO5O2+o6x3Z/J2X9w==')))) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                    0x28, 0xae, 0xd2, 0xa6,\n                                    0xab, 0xf7, 0x15, 0x88,\n                                    0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"1VwT0MGlXd/sxX98+GZhSw==\")))) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"0YWVjZHVtbXk=\")))) == output\ntest_50()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"VuK8gP2hRfZBdseFRqJI1g==\")))) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([164, 175, 255, 102, 164, 168, 194, 141, 217, 185, 232, 101, 103, 164, 172, 142])) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_56()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('DH193Y1RDt18gtCvYzg8xQ==')))) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([2, 15, 32, 239, 113, 142, 210, 103, 210, 136, 103, 112, 145, 125, 231, 231])) == output\ntest_61()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('Sz4Ijyc25fP8tSOxJ4B2ZaXAeOEZ38NK')))) == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('JCqdN5Sfgf8=')))) == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('bXlDbGFzczEyMzQ1Njc4OTA=')))) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"M2cOQ1g21i3e\")))) == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode('0123456789ABCDEF')))) == output\ntest_74()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c,\n                                     0x2b, 0x7e, 0x15, 0x16,\n                                     0x28, 0xae, 0xd2, 0xa6,\n                                     0xab, 0xf7, 0x15, 0x88,\n                                     0x09, 0xcf, 0x4f, 0x3c])) == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"dGhsdGhsdGhsdGhz\"))) ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion([0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, 0x02, 0x01, 0x01, 0x03, 0x00, 0x02, 0x03, 0x01])) == output\ntest_81()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/key_expansion/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(key_expansion(bytes_to_intlist(compat_b64decode(\"eJaS7K7bYVxS85sMvj928w==\")))) == output\ntest_86()\n\n\n"]}
{"task_id": 149, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # AES constants\n    Nb = 4  # block size in 32-bit words\n    Nr = (len(expanded_key) // 4) // Nb - 1  # number of rounds\n    # S-box\n    sbox = [\n        # 0     1      2      3      4      5      6      7      8      9      A      B      C      D      E      F\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    # Helper functions\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is 16 bytes; 4 rows of Nb bytes\n        # shift rows: row 0 shift 0, row 1 shift 1 left, row 2 shift 2 left, row 3 shift 3 left\n        t = state[:]\n        # row 1\n        t[1], t[5], t[9], t[13] = state[5], state[9], state[13], state[1]\n        # row 2\n        t[2], t[6], t[10], t[14] = state[10], state[14], state[2], state[6]\n        # row 3\n        t[3], t[7], t[11], t[15] = state[15], state[3], state[7], state[11]\n        return t\n\n    def xtime(a):\n        return ((a << 1) & 0xff) ^ (0x1b if (a & 0x80) else 0)\n\n    def mix_single_column(a):\n        # Mix one column for MixColumns\n        t = a[0] ^ a[1] ^ a[2] ^ a[3]\n        u = a[0]\n        a[0] ^= t ^ xtime(a[0] ^ a[1])\n        a[1] ^= t ^ xtime(a[1] ^ a[2])\n        a[2] ^= t ^ xtime(a[2] ^ a[3])\n        a[3] ^= t ^ xtime(a[3] ^ u)\n        return a\n\n    def mix_columns(state):\n        # state is length 16; 4 columns\n        res = state[:]\n        for i in range(4):\n            col = [res[i], res[i+4], res[i+8], res[i+12]]\n            col = mix_single_column(col)\n            res[i], res[i+4], res[i+8], res[i+12] = col[0], col[1], col[2], col[3]\n        return res\n\n    def add_round_key(state, round_key):\n        return [b ^ rk for b, rk in zip(state, round_key)]\n\n    # Begin encryption\n\n    state = add_round_key(data, expanded_key[:16])\n\n    for round in range(1, Nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[round*16:(round+1)*16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[Nr*16:(Nr+1)*16])\n\n    return state", "def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # S-box used in SubBytes step\n    s_box = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n    ]\n\n    def add_round_key(state, round_key):\n        return [s ^ k for s, k in zip(state, round_key)]\n\n    def sub_bytes(state):\n        return [s_box[b] for b in state]\n\n    def shift_rows(state):\n        # state is a list of 16 bytes arranged column-wise:\n        # Columns: [0,4,8,12], [1,5,9,13], [2,6,10,14], [3,7,11,15]\n        # Actually AES arranges state as 4x4 bytes: state[row][column].\n        # Our list is likely arranged in row-major order:\n        # We'll assume data is a list with 16 bytes where indices are:\n        # [ 0  1  2  3 ]\n        # [ 4  5  6  7 ]\n        # [ 8  9 10 11 ]\n        # [12 13 14 15 ]\n        # Shift rows as AES standard:\n        s = state[:]\n        # Row 1 shift left by 1\n        s[1], s[5], s[9], s[13] = state[5], state[9], state[13], state[1]\n        # Row 2 shift left by 2\n        s[2], s[6], s[10], s[14] = state[10], state[14], state[2], state[6]\n        # Row 3 shift left by 3 (or right by 1)\n        s[3], s[7], s[11], s[15] = state[15], state[3], state[7], state[11]\n        return s\n\n    def xtime(a):\n        # multiply by 0x02 in GF(2^8)\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_columns(state):\n        res = [0] * 16\n        for c in range(4):\n            i = c * 4\n            a0 = state[i]\n            a1 = state[i+1]\n            a2 = state[i+2]\n            a3 = state[i+3]\n\n            # mix columns:\n            res[i]   = xtime(a0) ^ (xtime(a1) ^ a1) ^ a2 ^ a3\n            res[i+1] = a0 ^ xtime(a1) ^ (xtime(a2) ^ a2) ^ a3\n            res[i+2] = a0 ^ a1 ^ xtime(a2) ^ (xtime(a3) ^ a3)\n            res[i+3] = (xtime(a0) ^ a0) ^ a1 ^ a2 ^ xtime(a3)\n\n            res[i]   &= 0xff\n            res[i+1] &= 0xff\n            res[i+2] &= 0xff\n            res[i+3] &= 0xff\n        return res\n\n    # Determine Nr (number of rounds) from expanded_key length\n    Nk = len(expanded_key) // 4 // 4  # number of 32-bit words in key\n    if Nk == 4:\n        Nr = 10\n    elif Nk == 6:\n        Nr = 12\n    elif Nk == 8:\n        Nr = 14\n    else:\n        raise ValueError(\"Invalid expanded key size\")\n\n    # Initial round key addition\n    state = add_round_key(data, expanded_key[0:16])\n\n    # Nr-1 rounds\n    for r in range(1, Nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[r*16:(r+1)*16])\n\n    # Final round (no mix columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[Nr*16:(Nr+1)*16])\n\n    return state", "def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # AES S-box\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is a list of 16\n        # row 0: no shift\n        # row 1: shift left by 1\n        # row 2: shift left by 2\n        # row 3: shift left by 3\n        new_state = [0]*16\n        for r in range(4):\n            for c in range(4):\n                new_state[4*r + c] = state[4*r + ((c + r) % 4)]\n        return new_state\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_single_column(a):\n        # see FIPS-197 for matrix multiplication\n        t = a[0] ^ a[1] ^ a[2] ^ a[3]\n        u = a[0]\n        a[0] ^= t ^ xtime(a[0] ^ a[1])\n        a[1] ^= t ^ xtime(a[1] ^ a[2])\n        a[2] ^= t ^ xtime(a[2] ^ a[3])\n        a[3] ^= t ^ xtime(a[3] ^ u)\n        return a\n\n    def mix_columns(state):\n        for c in range(4):\n            col = state[c*4:c*4+4]\n            col = mix_single_column(col)\n            state[c*4:c*4+4] = col\n        return state\n\n    def add_round_key(state, rk):\n        return [b ^ rk[i] for i, b in enumerate(state)]\n\n    Nk = len(expanded_key) // 4 // 4  # 4 bytes per word, words per key\n    Nr = Nk + 6\n\n    state = add_round_key(data, expanded_key[:16])\n\n    for round in range(1, Nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[16*round:16*(round+1)])\n\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[16*Nr:16*(Nr+1)])\n\n    return state", "def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n\n    # S-box table\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n    ]\n\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is a 16-byte list representing 4x4 matrix column-major\n        # In AES state:\n        # Row 0: indices 0,4,8,12\n        # Row 1: 1,5,9,13\n        # Row 2: 2,6,10,14\n        # Row 3: 3,7,11,15\n        # ShiftRow operation shifts each row cyclically left by row number\n        new_state = state[:]\n        # Row 1 shift by 1\n        new_state[1], new_state[5], new_state[9], new_state[13] = \\\n            state[5], state[9], state[13], state[1]\n        # Row 2 shift by 2\n        new_state[2], new_state[6], new_state[10], new_state[14] = \\\n            state[10], state[14], state[2], state[6]\n        # Row 3 shift by 3 (or right by 1)\n        new_state[3], new_state[7], new_state[11], new_state[15] = \\\n            state[15], state[3], state[7], state[11]\n        return new_state\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_single_column(a):\n        # a is a list of 4 bytes (one column)\n        t = a[0] ^ a[1] ^ a[2] ^ a[3]\n        u = a[0]\n        a[0] ^= t ^ xtime(a[0] ^ a[1])\n        a[1] ^= t ^ xtime(a[1] ^ a[2])\n        a[2] ^= t ^ xtime(a[2] ^ a[3])\n        a[3] ^= t ^ xtime(a[3] ^ u)\n        return a\n\n    def mix_columns(state):\n        # state is flat 16 bytes column-major\n        # Process each column\n        new_state = state[:]\n        for i in range(4):\n            col = [state[i + 4 * j] for j in range(4)]\n            mixed = mix_single_column(col)\n            for j in range(4):\n                new_state[i + 4 * j] = mixed[j]\n        return new_state\n\n    def add_round_key(state, round_key):\n        return [b ^ rk for b, rk in zip(state, round_key)]\n\n    # Determine number of rounds based on key size\n    key_length = len(expanded_key)\n    if key_length == 176:  # 128-bit key, 10 rounds\n        rounds = 10\n    elif key_length == 208:  # 192-bit key, 12 rounds\n        rounds = 12\n    elif key_length == 240:  # 256-bit key, 14 rounds\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded key length\")\n\n    # initial round key addition\n    state = add_round_key(data, expanded_key[0:16])\n\n    # rounds except last\n    for round_i in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key = expanded_key[16 * round_i: 16 * (round_i +1)]\n        state = add_round_key(state, round_key)\n\n    # final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[16 * rounds: 16 * (rounds + 1)]\n    state = add_round_key(state, round_key)\n\n    return state", "def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    sbox = [\n        # 256 values of the AES S-box\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,\n        0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,\n        0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,\n        0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,\n        0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,\n        0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n        0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,\n        0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,\n        0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,\n        0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,\n        0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,\n        0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is 16 byte array\n        # row 0 -> no shift\n        # row 1 -> shift left 1\n        # row 2 -> shift left 2\n        # row 3 -> shift left 3\n        # The state is in column-major order for AES usually,\n        # but here we assume input as a flat 16 bytes.\n        # To be consistent, we treat:\n        # state index = row + 4*col\n        # We rearrange by rows:\n        rows = [\n            [state[i] for i in range(r, 16, 4)]\n            for r in range(4)\n        ]\n        # shift rows\n        for r in range(1,4):\n            rows[r] = rows[r][r:] + rows[r][:r]\n        # rebuild state in column major order\n        new_state = []\n        for c in range(4):\n            for r in range(4):\n                new_state.append(rows[r][c])\n        return new_state\n\n    def xtime(a):\n        # multiply by 2 in GF(2^8)\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_single_column(col):\n        # mix one column for MixColumns\n        t = col[0] ^ col[1] ^ col[2] ^ col[3]\n        u = col[0]\n        col0 = col[0] ^ t ^ xtime(col[0] ^ col[1])\n        col1 = col[1] ^ t ^ xtime(col[1] ^ col[2])\n        col2 = col[2] ^ t ^ xtime(col[2] ^ col[3])\n        col3 = col[3] ^ t ^ xtime(col[3] ^ u)\n        return [col0 & 0xff, col1 & 0xff, col2 & 0xff, col3 & 0xff]\n\n    def mix_columns(state):\n        # state is 16 byte array in column-major order\n        # process each column\n        new_state = []\n        for c in range(4):\n            col = state[c*4:c*4+4]\n            mixed = mix_single_column(col)\n            new_state.extend(mixed)\n        return new_state\n\n    def add_round_key(state, round_key):\n        return [b ^ k for b, k in zip(state, round_key)]\n\n    # Determine number of rounds from expanded_key length:\n    # AES-128 -> 176 bytes -> 11 round keys (16 bytes each)\n    # AES-192 -> 208 bytes -> 13 round keys\n    # AES-256 -> 240 bytes -> 15 round keys\n    nk_bytes = len(expanded_key)\n    if nk_bytes == 176:\n        nr = 10\n    elif nk_bytes == 208:\n        nr = 12\n    elif nk_bytes == 240:\n        nr = 14\n    else:\n        raise ValueError(\"Invalid expanded key length\")\n\n    # Initial round key is first 16 bytes of expanded key\n    state = add_round_key(data, expanded_key[0:16])\n\n    # Middle rounds\n    for round in range(1, nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[round*16:(round+1)*16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[nr*16:(nr+1)*16])\n\n    return state"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # AES constants\n    Nb = 4  # block size in 32-bit words\n    Nr = (len(expanded_key) // 4) // Nb - 1  # number of rounds\n    # S-box\n    sbox = [\n        # 0     1      2      3      4      5      6      7      8      9      A      B      C      D      E      F\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    # Helper functions\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is 16 bytes; 4 rows of Nb bytes\n        # shift rows: row 0 shift 0, row 1 shift 1 left, row 2 shift 2 left, row 3 shift 3 left\n        t = state[:]\n        # row 1\n        t[1], t[5], t[9], t[13] = state[5], state[9], state[13], state[1]\n        # row 2\n        t[2], t[6], t[10], t[14] = state[10], state[14], state[2], state[6]\n        # row 3\n        t[3], t[7], t[11], t[15] = state[15], state[3], state[7], state[11]\n        return t\n\n    def xtime(a):\n        return ((a << 1) & 0xff) ^ (0x1b if (a & 0x80) else 0)\n\n    def mix_single_column(a):\n        # Mix one column for MixColumns\n        t = a[0] ^ a[1] ^ a[2] ^ a[3]\n        u = a[0]\n        a[0] ^= t ^ xtime(a[0] ^ a[1])\n        a[1] ^= t ^ xtime(a[1] ^ a[2])\n        a[2] ^= t ^ xtime(a[2] ^ a[3])\n        a[3] ^= t ^ xtime(a[3] ^ u)\n        return a\n\n    def mix_columns(state):\n        # state is length 16; 4 columns\n        res = state[:]\n        for i in range(4):\n            col = [res[i], res[i+4], res[i+8], res[i+12]]\n            col = mix_single_column(col)\n            res[i], res[i+4], res[i+8], res[i+12] = col[0], col[1], col[2], col[3]\n        return res\n\n    def add_round_key(state, round_key):\n        return [b ^ rk for b, rk in zip(state, round_key)]\n\n    # Begin encryption\n\n    state = add_round_key(data, expanded_key[:16])\n\n    for round in range(1, Nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[round*16:(round+1)*16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[Nr*16:(Nr+1)*16])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # S-box used in SubBytes step\n    s_box = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n    ]\n\n    def add_round_key(state, round_key):\n        return [s ^ k for s, k in zip(state, round_key)]\n\n    def sub_bytes(state):\n        return [s_box[b] for b in state]\n\n    def shift_rows(state):\n        # state is a list of 16 bytes arranged column-wise:\n        # Columns: [0,4,8,12], [1,5,9,13], [2,6,10,14], [3,7,11,15]\n        # Actually AES arranges state as 4x4 bytes: state[row][column].\n        # Our list is likely arranged in row-major order:\n        # We'll assume data is a list with 16 bytes where indices are:\n        # [ 0  1  2  3 ]\n        # [ 4  5  6  7 ]\n        # [ 8  9 10 11 ]\n        # [12 13 14 15 ]\n        # Shift rows as AES standard:\n        s = state[:]\n        # Row 1 shift left by 1\n        s[1], s[5], s[9], s[13] = state[5], state[9], state[13], state[1]\n        # Row 2 shift left by 2\n        s[2], s[6], s[10], s[14] = state[10], state[14], state[2], state[6]\n        # Row 3 shift left by 3 (or right by 1)\n        s[3], s[7], s[11], s[15] = state[15], state[3], state[7], state[11]\n        return s\n\n    def xtime(a):\n        # multiply by 0x02 in GF(2^8)\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_columns(state):\n        res = [0] * 16\n        for c in range(4):\n            i = c * 4\n            a0 = state[i]\n            a1 = state[i+1]\n            a2 = state[i+2]\n            a3 = state[i+3]\n\n            # mix columns:\n            res[i]   = xtime(a0) ^ (xtime(a1) ^ a1) ^ a2 ^ a3\n            res[i+1] = a0 ^ xtime(a1) ^ (xtime(a2) ^ a2) ^ a3\n            res[i+2] = a0 ^ a1 ^ xtime(a2) ^ (xtime(a3) ^ a3)\n            res[i+3] = (xtime(a0) ^ a0) ^ a1 ^ a2 ^ xtime(a3)\n\n            res[i]   &= 0xff\n            res[i+1] &= 0xff\n            res[i+2] &= 0xff\n            res[i+3] &= 0xff\n        return res\n\n    # Determine Nr (number of rounds) from expanded_key length\n    Nk = len(expanded_key) // 4 // 4  # number of 32-bit words in key\n    if Nk == 4:\n        Nr = 10\n    elif Nk == 6:\n        Nr = 12\n    elif Nk == 8:\n        Nr = 14\n    else:\n        raise ValueError(\"Invalid expanded key size\")\n\n    # Initial round key addition\n    state = add_round_key(data, expanded_key[0:16])\n\n    # Nr-1 rounds\n    for r in range(1, Nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[r*16:(r+1)*16])\n\n    # Final round (no mix columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[Nr*16:(Nr+1)*16])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # AES S-box\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is a list of 16\n        # row 0: no shift\n        # row 1: shift left by 1\n        # row 2: shift left by 2\n        # row 3: shift left by 3\n        new_state = [0]*16\n        for r in range(4):\n            for c in range(4):\n                new_state[4*r + c] = state[4*r + ((c + r) % 4)]\n        return new_state\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_single_column(a):\n        # see FIPS-197 for matrix multiplication\n        t = a[0] ^ a[1] ^ a[2] ^ a[3]\n        u = a[0]\n        a[0] ^= t ^ xtime(a[0] ^ a[1])\n        a[1] ^= t ^ xtime(a[1] ^ a[2])\n        a[2] ^= t ^ xtime(a[2] ^ a[3])\n        a[3] ^= t ^ xtime(a[3] ^ u)\n        return a\n\n    def mix_columns(state):\n        for c in range(4):\n            col = state[c*4:c*4+4]\n            col = mix_single_column(col)\n            state[c*4:c*4+4] = col\n        return state\n\n    def add_round_key(state, rk):\n        return [b ^ rk[i] for i, b in enumerate(state)]\n\n    Nk = len(expanded_key) // 4 // 4  # 4 bytes per word, words per key\n    Nr = Nk + 6\n\n    state = add_round_key(data, expanded_key[:16])\n\n    for round in range(1, Nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[16*round:16*(round+1)])\n\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[16*Nr:16*(Nr+1)])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n\n    # S-box table\n    sbox = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n    ]\n\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is a 16-byte list representing 4x4 matrix column-major\n        # In AES state:\n        # Row 0: indices 0,4,8,12\n        # Row 1: 1,5,9,13\n        # Row 2: 2,6,10,14\n        # Row 3: 3,7,11,15\n        # ShiftRow operation shifts each row cyclically left by row number\n        new_state = state[:]\n        # Row 1 shift by 1\n        new_state[1], new_state[5], new_state[9], new_state[13] = \\\n            state[5], state[9], state[13], state[1]\n        # Row 2 shift by 2\n        new_state[2], new_state[6], new_state[10], new_state[14] = \\\n            state[10], state[14], state[2], state[6]\n        # Row 3 shift by 3 (or right by 1)\n        new_state[3], new_state[7], new_state[11], new_state[15] = \\\n            state[15], state[3], state[7], state[11]\n        return new_state\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_single_column(a):\n        # a is a list of 4 bytes (one column)\n        t = a[0] ^ a[1] ^ a[2] ^ a[3]\n        u = a[0]\n        a[0] ^= t ^ xtime(a[0] ^ a[1])\n        a[1] ^= t ^ xtime(a[1] ^ a[2])\n        a[2] ^= t ^ xtime(a[2] ^ a[3])\n        a[3] ^= t ^ xtime(a[3] ^ u)\n        return a\n\n    def mix_columns(state):\n        # state is flat 16 bytes column-major\n        # Process each column\n        new_state = state[:]\n        for i in range(4):\n            col = [state[i + 4 * j] for j in range(4)]\n            mixed = mix_single_column(col)\n            for j in range(4):\n                new_state[i + 4 * j] = mixed[j]\n        return new_state\n\n    def add_round_key(state, round_key):\n        return [b ^ rk for b, rk in zip(state, round_key)]\n\n    # Determine number of rounds based on key size\n    key_length = len(expanded_key)\n    if key_length == 176:  # 128-bit key, 10 rounds\n        rounds = 10\n    elif key_length == 208:  # 192-bit key, 12 rounds\n        rounds = 12\n    elif key_length == 240:  # 256-bit key, 14 rounds\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded key length\")\n\n    # initial round key addition\n    state = add_round_key(data, expanded_key[0:16])\n\n    # rounds except last\n    for round_i in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key = expanded_key[16 * round_i: 16 * (round_i +1)]\n        state = add_round_key(state, round_key)\n\n    # final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[16 * rounds: 16 * (rounds + 1)]\n    state = add_round_key(state, round_key)\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    sbox = [\n        # 256 values of the AES S-box\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,\n        0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,\n        0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,\n        0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,\n        0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,\n        0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,\n        0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,\n        0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,\n        0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,\n        0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,\n        0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,\n        0xb0, 0x54, 0xbb, 0x16\n    ]\n\n    def sub_bytes(state):\n        return [sbox[b] for b in state]\n\n    def shift_rows(state):\n        # state is 16 byte array\n        # row 0 -> no shift\n        # row 1 -> shift left 1\n        # row 2 -> shift left 2\n        # row 3 -> shift left 3\n        # The state is in column-major order for AES usually,\n        # but here we assume input as a flat 16 bytes.\n        # To be consistent, we treat:\n        # state index = row + 4*col\n        # We rearrange by rows:\n        rows = [\n            [state[i] for i in range(r, 16, 4)]\n            for r in range(4)\n        ]\n        # shift rows\n        for r in range(1,4):\n            rows[r] = rows[r][r:] + rows[r][:r]\n        # rebuild state in column major order\n        new_state = []\n        for c in range(4):\n            for r in range(4):\n                new_state.append(rows[r][c])\n        return new_state\n\n    def xtime(a):\n        # multiply by 2 in GF(2^8)\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mix_single_column(col):\n        # mix one column for MixColumns\n        t = col[0] ^ col[1] ^ col[2] ^ col[3]\n        u = col[0]\n        col0 = col[0] ^ t ^ xtime(col[0] ^ col[1])\n        col1 = col[1] ^ t ^ xtime(col[1] ^ col[2])\n        col2 = col[2] ^ t ^ xtime(col[2] ^ col[3])\n        col3 = col[3] ^ t ^ xtime(col[3] ^ u)\n        return [col0 & 0xff, col1 & 0xff, col2 & 0xff, col3 & 0xff]\n\n    def mix_columns(state):\n        # state is 16 byte array in column-major order\n        # process each column\n        new_state = []\n        for c in range(4):\n            col = state[c*4:c*4+4]\n            mixed = mix_single_column(col)\n            new_state.extend(mixed)\n        return new_state\n\n    def add_round_key(state, round_key):\n        return [b ^ k for b, k in zip(state, round_key)]\n\n    # Determine number of rounds from expanded_key length:\n    # AES-128 -> 176 bytes -> 11 round keys (16 bytes each)\n    # AES-192 -> 208 bytes -> 13 round keys\n    # AES-256 -> 240 bytes -> 15 round keys\n    nk_bytes = len(expanded_key)\n    if nk_bytes == 176:\n        nr = 10\n    elif nk_bytes == 208:\n        nr = 12\n    elif nk_bytes == 240:\n        nr = 14\n    else:\n        raise ValueError(\"Invalid expanded key length\")\n\n    # Initial round key is first 16 bytes of expanded key\n    state = add_round_key(data, expanded_key[0:16])\n\n    # Middle rounds\n    for round in range(1, nr):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[round*16:(round+1)*16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[nr*16:(nr+1)*16])\n\n    return state\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_42():\n    assert 16 == len(aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))\ntest_42()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000002\"))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"1234567890123456\"))) == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'\\x00' * 16), bytes_to_intlist(b'\\x00' * 32))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000001\"))) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ''.join('{:02x}'.format(b) for b in aes_encrypt(bytes.fromhex('00000000000000000000000000000000'), bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000000'))) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([105, 110, 116, 101, 103, 114, 105, 116, 121, 32, 77, 97, 103, 101, 32, 60]), intlist_to_bytes(b\"foobar\" * 3)) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(\n        bytes_to_intlist(b'test string'),\n        bytes_to_intlist(compat_b64decode(\"528016e106d2a0d979b28b8bf73e933d\")))) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996993'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1] * 88) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(\n        intlist_to_bytes([17, 254, 3, 14, 228, 62, 96, 35, 187, 55, 136, 43, 90, 201, 18, 235]),\n        bytes_to_intlist(b'YELLOW SUBMARINE') + [0] * 16)) == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 176) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0] * 240) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(bytes_to_intlist(\"6bc1bee22e409f96e93d7e117393172a\"), bytes_to_intlist(\n        \"2b7e151628aed2a6abf7158809cf4f3c\")) == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996994'))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(compat_b64decode(\"76e90f9e1fb784a1e99508bb3ec58281\")), bytes_to_intlist(compat_b64decode(\"2b7e151628aed2a6abf7158809cf4f3c\")))).hex() == output\ntest_22()\n\ndef test_25():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(\n        intlist_to_bytes([\n            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]),\n        bytes_to_intlist(compat_b64decode(\n            'aRuXDkZyb3J4dXRheXBhZ2VlZA=='))) == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'dddddddddddddddd'), bytes_to_intlist(b'DDDDDDDDDDDDDDDD'))) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1] * 176) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([\n        0x48, 0x38, 0x89, 0x7f, 0x0b, 0x69, 0xe8, 0x96,\n        0x75, 0x88, 0x00, 0xd3, 0x4d, 0x16, 0x61, 0xb2],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] * 17\n    ) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(b'0000000000000000', b'00000000000000000000000000000000') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'testing123456'), bytes_to_intlist(b'key1234567890123456'))) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"abcdefghijklmnop\"),  bytes_to_intlist(b\"0\" * 32))) == output\ntest_35()\n\ndef test_37():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'eeeeeeeeeeeeeeee'), bytes_to_intlist(b'EEEEEEEEEEEEEEEE'))) == output\ntest_37()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0000000000000000'), bytes_to_intlist(b'4060C8EE015169A86E06D743E0996995'))) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1] * 16, [0] * 176) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0] * 16, [0] * 176) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'aaaaaaaaaaaaaaaa'), bytes_to_intlist(b'AAAAAAAAAAAAAAAA'))) == output\ntest_44()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([0x00, 0x11, 0x22, 0x33,\n                                          0x44, 0x55, 0x66, 0x77,\n                                          0x88, 0x99, 0xaa, 0xbb,\n                                          0xcc, 0xdd, 0xee, 0xff]),\n                       compat_b64decode('VEhBQ0hfTEVNQVJST1VTQQ==')) == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1] * 88) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_encrypt(intlist_to_bytes([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),\n                        compat_b64decode('l0FMTz2gNpHKQJb2ZV37XnU5qTLm+OQnm7QWMybM6uI=')) == output\ntest_52()\n\ndef test_55():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'ffffffffffffffff'), bytes_to_intlist(b'FFFFFFFFFFFFFFFF'))) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'0123456789abcdef'), bytes_to_intlist(b'0123456789abcdef'))) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b\"0123456789abcdef\"), bytes_to_intlist(b\"00000000000000000000000000000000\"))) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(b'hello world'), bytes_to_intlist(b'YELLOW SUBMARINE'))) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'cccccccccccccccc'), bytes_to_intlist(b'CCCCCCCCCCCCCCCC'))) == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt([1 for i in range(16)], [1 for i in range(240)])) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_encrypt(bytes_to_intlist(\"4142434445464748494a4b4c4d4e4f\"), bytes_to_intlist(\"00000000000000000000000000000000\"))) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_encrypt/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_encrypt(bytes_to_intlist(b'bbbbbbbbbbbbbbbb'), bytes_to_intlist(b'BBBBBBBBBBBBBBBB'))) == output\ntest_62()\n\n\n"]}
{"task_id": 150, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["def aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # Constants\n    Nb = 4  # block size (in words): no of columns (32-bit words) comprising the State; always 4 for AES\n    Nk = len(expanded_key) // 4 // Nb  # key length in 32-bit words\n    Nr = Nk + 6  # number of rounds\n\n    # Helper functions\n    def sub_word(word):\n        sbox = [\n            # 0    1    2    3     4    5    6    7     8    9    a    b     c    d    e    f\n            0x63, 0x7c, 0x77, 0x7b,  0xf2, 0x6b, 0x6f, 0xc5,  0x30, 0x01, 0x67, 0x2b,  0xfe, 0xd7, 0xab, 0x76,\n            0xca, 0x82, 0xc9, 0x7d,  0xfa, 0x59, 0x47, 0xf0,  0xad, 0xd4, 0xa2, 0xaf,  0x9c, 0xa4, 0x72, 0xc0,\n            0xb7, 0xfd, 0x93, 0x26,  0x36, 0x3f, 0xf7, 0xcc,  0x34, 0xa5, 0xe5, 0xf1,  0x71, 0xd8, 0x31, 0x15,\n            0x04, 0xc7, 0x23, 0xc3,  0x18, 0x96, 0x05, 0x9a,  0x07, 0x12, 0x80, 0xe2,  0xeb, 0x27, 0xb2, 0x75,\n            0x09, 0x83, 0x2c, 0x1a,  0x1b, 0x6e, 0x5a, 0xa0,  0x52, 0x3b, 0xd6, 0xb3,  0x29, 0xe3, 0x2f, 0x84,\n            0x53, 0xd1, 0x00, 0xed,  0x20, 0xfc, 0xb1, 0x5b,  0x6a, 0xcb, 0xbe, 0x39,  0x4a, 0x4c, 0x58, 0xcf,\n            0xd0, 0xef, 0xaa, 0xfb,  0x43, 0x4d, 0x33, 0x85,  0x45, 0xf9, 0x02, 0x7f,  0x50, 0x3c, 0x9f, 0xa8,\n            0x51, 0xa3, 0x40, 0x8f,  0x92, 0x9d, 0x38, 0xf5,  0xbc, 0xb6, 0xda, 0x21,  0x10, 0xff, 0xf3, 0xd2,\n            0xcd, 0x0c, 0x13, 0xec,  0x5f, 0x97, 0x44, 0x17,  0xc4, 0xa7, 0x7e, 0x3d,  0x64, 0x5d, 0x19, 0x73,\n            0x60, 0x81, 0x4f, 0xdc,  0x22, 0x2a, 0x90, 0x88,  0x46, 0xee, 0xb8, 0x14,  0xde, 0x5e, 0x0b, 0xdb,\n            0xe0, 0x32, 0x3a, 0x0a,  0x49, 0x06, 0x24, 0x5c,  0xc2, 0xd3, 0xac, 0x62,  0x91, 0x95, 0xe4, 0x79,\n            0xe7, 0xc8, 0x37, 0x6d,  0x8d, 0xd5, 0x4e, 0xa9,  0x6c, 0x56, 0xf4, 0xea,  0x65, 0x7a, 0xae, 0x08,\n            0xba, 0x78, 0x25, 0x2e,  0x1c, 0xa6, 0xb4, 0xc6,  0xe8, 0xdd, 0x74, 0x1f,  0x4b, 0xbd, 0x8b, 0x8a,\n            0x70, 0x3e, 0xb5, 0x66,  0x48, 0x03, 0xf6, 0x0e,  0x61, 0x35, 0x57, 0xb9,  0x86, 0xc1, 0x1d, 0x9e,\n            0xe1, 0xf8, 0x98, 0x11,  0x69, 0xd9, 0x8e, 0x94,  0x9b, 0x1e, 0x87, 0xe9,  0xce, 0x55, 0x28, 0xdf,\n            0x8c, 0xa1, 0x89, 0x0d,  0xbf, 0xe6, 0x42, 0x68,  0x41, 0x99, 0x2d, 0x0f,  0xb0, 0x54, 0xbb, 0x16\n        ]\n        return [sbox[b] for b in word]\n\n    def inv_sub_bytes(state):\n        inv_sbox = [\n            0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n            0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n            0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n            0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n            0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n            0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n            0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n            0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n            0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n            0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n            0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n            0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n            0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n            0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n            0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n            0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n        ]\n        return [inv_sbox[b] for b in state]\n\n    def inv_shift_rows(state):\n        # State is a list of 16 bytes\n        # Convert to 4x4 matrix (column-major order)\n        m = [list(state[i:i+4]) for i in range(0,16,4)]\n        # m[row][col] but AES state is column-major, so taking columns as bytes\n        # Let's rearrange bytes to a matrix row-major for easier manipulation:\n        # AES uses state as columns (4 bytes each), but stored linear as:\n        # state[0],State[1],... state[15] = column0,row0; column0,row1; column0,row2; column0,row3; col1,row0; col1,row1; ...\n        # The data in 'state' is column-major order:\n        # To do shifts on rows, reconstruct rows explicitly:\n        rows = [[state[col+4*row] for col in range(4)] for row in range(4)]\n        # Inverse shift rows: row 0 no shift\n        # row1 shift right by 1\n        rows[1] = rows[1][-1:] + rows[1][:-1]\n        # row2 shift right by 2\n        rows[2] = rows[2][-2:] + rows[2][:-2]\n        # row3 shift right by 3 (or left by 1)\n        rows[3] = rows[3][-3:] + rows[3][:-3]\n        # Convert back to column-major state\n        new_state = []\n        for col in range(4):\n            for row in range(4):\n                new_state.append(rows[row][col])\n        return new_state\n\n    def add_round_key(state, round_key):\n        return [s ^ k for s, k in zip(state, round_key)]\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mul_bytes(a, b):\n        # Multiply two bytes in GF(2^8)\n        res = 0\n        for i in range(8):\n            if b & 1:\n                res ^= a\n            high_bit = a & 0x80\n            a = (a << 1) & 0xff\n            if high_bit:\n                a ^= 0x1b\n            b >>= 1\n        return res\n\n    def inv_mix_columns(state):\n        # operates on columns of 4 bytes\n        new_state = []\n        for c in range(4):\n            col = state[4*c:4*c+4]\n            s0 = mul_bytes(col[0], 0x0e) ^ mul_bytes(col[1], 0x0b) ^ mul_bytes(col[2], 0x0d) ^ mul_bytes(col[3], 0x09)\n            s1 = mul_bytes(col[0], 0x09) ^ mul_bytes(col[1], 0x0e) ^ mul_bytes(col[2], 0x0b) ^ mul_bytes(col[3], 0x0d)\n            s2 = mul_bytes(col[0], 0x0d) ^ mul_bytes(col[1], 0x09) ^ mul_bytes(col[2], 0x0e) ^ mul_bytes(col[3], 0x0b)\n            s3 = mul_bytes(col[0], 0x0b) ^ mul_bytes(col[1], 0x0d) ^ mul_bytes(col[2], 0x09) ^ mul_bytes(col[3], 0x0e)\n            new_state.extend([s0, s1, s2, s3])\n        return new_state\n\n    # Convert expanded_key bytes to round keys (list of lists of 16 bytes)\n    round_keys = [expanded_key[16*i:16*(i+1)] for i in range(Nr+1)]\n\n    # Start decrypt\n    state = data[:]\n\n    state = add_round_key(state, round_keys[Nr])\n\n    for round in range(Nr-1, 0, -1):\n        state = inv_shift_rows(state)\n        state = inv_sub_bytes(state)\n        state = add_round_key(state, round_keys[round])\n        state = inv_mix_columns(state)\n\n    # Final round (no InvMixColumns)\n    state = inv_shift_rows(state)\n    state = inv_sub_bytes(state)\n    state = add_round_key(state, round_keys[0])\n\n    return state", "def aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    Nb = 4\n    Nr = len(expanded_key) // 4 - Nb\n\n    def sub_word(word):\n        sbox = [\n            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n            0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n            0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n            0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n            0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n            0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n            0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n            0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n            0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n            0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n            0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n            0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n            0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n            0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n            0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n            0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n            0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n        ]\n        return [sbox[b] for b in word]\n\n    def inv_sub_bytes(s):\n        inv_sbox = [\n            0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,\n            0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n            0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,\n            0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n            0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,\n            0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n            0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,\n            0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n            0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,\n            0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n            0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,\n            0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n            0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,\n            0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n            0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,\n            0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n            0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,\n            0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n            0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,\n            0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n            0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,\n            0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n            0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,\n            0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n            0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,\n            0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n            0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,\n            0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n            0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,\n            0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n            0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,\n            0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n        ]\n        return [inv_sbox[b] for b in s]\n\n    def add_round_key(state, key):\n        return [s ^ k for s, k in zip(state, key)]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mul(a, b):\n        p = 0\n        for i in range(8):\n            if b & 1:\n                p ^= a\n            high_bit_set = a & 0x80\n            a = (a << 1) & 0xff\n            if high_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p & 0xff\n\n    def inv_mix_columns(state):\n        # state is 16 bytes - 4 columns of 4 bytes each\n        s = list(state)\n        for i in range(4):\n            col = s[i*4:(i+1)*4]\n            s[i*4+0] = mul(col[0], 0x0e) ^ mul(col[1], 0x0b) ^ mul(col[2], 0x0d) ^ mul(col[3], 0x09)\n            s[i*4+1] = mul(col[0], 0x09) ^ mul(col[1], 0x0e) ^ mul(col[2], 0x0b) ^ mul(col[3], 0x0d)\n            s[i*4+2] = mul(col[0], 0x0d) ^ mul(col[1], 0x09) ^ mul(col[2], 0x0e) ^ mul(col[3], 0x0b)\n            s[i*4+3] = mul(col[0], 0x0b) ^ mul(col[1], 0x0d) ^ mul(col[2], 0x09) ^ mul(col[3], 0x0e)\n        return s\n\n    def inv_shift_rows(state):\n        # state is a list of 16 bytes: row0[row0,row4,row8,row12], row1[row1,...] etc as matrix column major\n        s = list(state)\n        # Row 1 shift right by 1\n        s[1], s[5], s[9], s[13] = s[13], s[1], s[5], s[9]\n        # Row 2 shift right by 2\n        s[2], s[6], s[10], s[14] = s[10], s[14], s[2], s[6]\n        # Row 3 shift right by 3 (left by 1)\n        s[3], s[7], s[11], s[15] = s[7], s[11], s[15], s[3]\n        return s\n\n    # Setup state\n    state = list(data)\n\n    # Initial add round key\n    round_key = expanded_key[Nr*4*4:(Nr+1)*4*4]\n    state = add_round_key(state, round_key)\n\n    # main rounds\n    for round in range(Nr-1, 0, -1):\n        state = inv_shift_rows(state)\n        state = inv_sub_bytes(state)\n        round_key = expanded_key[round*4*4:(round+1)*4*4]\n        state = add_round_key(state, round_key)\n        state = inv_mix_columns(state)\n\n    # final round\n    state = inv_shift_rows(state)\n    state = inv_sub_bytes(state)\n    round_key = expanded_key[0:4*4]\n    state = add_round_key(state, round_key)\n\n    return state", "def aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # S-box inverse\n    inv_sbox = [\n        0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n        0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n        0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n        0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n        0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n        0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n        0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n        0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n        0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n        0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n        0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n        0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n        0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n        0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n        0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n        0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n    ]\n\n    def add_round_key(state, round_key):\n        for i in range(16):\n            state[i] ^= round_key[i]\n\n    def inv_sub_bytes(state):\n        for i in range(16):\n            state[i] = inv_sbox[state[i]]\n\n    def inv_shift_rows(state):\n        # Row 0: no shift\n        # Row 1: shift right by 1\n        state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]\n        # Row 2: shift right by 2\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        # Row 3: shift right by 3 (left by 1)\n        state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]\n\n    def gmul(a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi_bit_set = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def inv_mix_columns(state):\n        for i in range(4):\n            s0 = state[i*4]\n            s1 = state[i*4+1]\n            s2 = state[i*4+2]\n            s3 = state[i*4+3]\n\n            state[i*4]   = gmul(s0, 0x0e) ^ gmul(s1, 0x0b) ^ gmul(s2, 0x0d) ^ gmul(s3, 0x09)\n            state[i*4+1] = gmul(s0, 0x09) ^ gmul(s1, 0x0e) ^ gmul(s2, 0x0b) ^ gmul(s3, 0x0d)\n            state[i*4+2] = gmul(s0, 0x0d) ^ gmul(s1, 0x09) ^ gmul(s2, 0x0e) ^ gmul(s3, 0x0b)\n            state[i*4+3] = gmul(s0, 0x0b) ^ gmul(s1, 0x0d) ^ gmul(s2, 0x09) ^ gmul(s3, 0x0e)\n\n    # Determine number of rounds from expanded key length\n    nk = len(expanded_key) // 4  # number of 32-bit words in key\n    nb = 4  # block size in 32-bit words\n    nr = nk + 6\n\n    state = data[:]\n\n    # initial AddRoundKey\n    add_round_key(state, expanded_key[-16:])\n\n    for round in range(nr-1, 0, -1):\n        inv_shift_rows(state)\n        inv_sub_bytes(state)\n        add_round_key(state, expanded_key[round*16:(round+1)*16])\n        inv_mix_columns(state)\n\n    inv_shift_rows(state)\n    inv_sub_bytes(state)\n    add_round_key(state, expanded_key[0:16])\n\n    return state", "def aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # AES constants\n    Nb = 4\n    Nr = len(expanded_key) // 4 - 1  # Number of rounds: key length-dependent\n\n    # Helper inverse S-box\n    inv_sbox = [\n        0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n        0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n        0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n        0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n        0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n        0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n        0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n        0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n        0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n        0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n        0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n        0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n        0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n        0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n        0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n        0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n    ]\n\n    # Multiply in GF(2^8)\n    def gmul(a, b):\n        p = 0\n        for i in range(8):\n            if b & 1:\n                p ^= a\n            hi_bit_set = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def add_round_key(state, round_key):\n        for i in range(16):\n            state[i] ^= round_key[i]\n        return state\n\n    def inv_sub_bytes(state):\n        for i in range(16):\n            state[i] = inv_sbox[state[i]]\n        return state\n\n    def inv_shift_rows(state):\n        # state is 4x4 column major, indexed as state[col*4 + row]\n        # Row 0: no shift\n        # Row 1: shift right 1\n        # Row 2: shift right 2\n        # Row 3: shift right 3\n        # So we do inverse of shiftrows (which does left shifts)\n        # We'll do per row operates on the 4 elements at [0+row,4+row,8+row,12+row]\n        def rotate_right(row, n):\n            return row[-n:] + row[:-n]\n        for r in range(1, 4):\n            row = [state[c * 4 + r] for c in range(4)]\n            row = rotate_right(row, r)\n            for c in range(4):\n                state[c * 4 + r] = row[c]\n        return state\n\n    def inv_mix_columns(state):\n        # each column is 4 bytes\n        for c in range(4):\n            i = c * 4\n            s0 = state[i]\n            s1 = state[i+1]\n            s2 = state[i+2]\n            s3 = state[i+3]\n            state[i] = gmul(s0,0x0e) ^ gmul(s1,0x0b) ^ gmul(s2,0x0d) ^ gmul(s3,0x09)\n            state[i+1] = gmul(s0,0x09) ^ gmul(s1,0x0e) ^ gmul(s2,0x0b) ^ gmul(s3,0x0d)\n            state[i+2] = gmul(s0,0x0d) ^ gmul(s1,0x09) ^ gmul(s2,0x0e) ^ gmul(s3,0x0b)\n            state[i+3] = gmul(s0,0x0b) ^ gmul(s1,0x0d) ^ gmul(s2,0x09) ^ gmul(s3,0x0e)\n        return state\n\n    # Copy data for state\n    state = data[:]\n\n    round_keys = [ expanded_key[i*16:(i+1)*16] for i in range(Nr+1) ]\n\n    state = add_round_key(state, round_keys[Nr])\n\n    for round in range(Nr-1, 0, -1):\n        state = inv_shift_rows(state)\n        state = inv_sub_bytes(state)\n        state = add_round_key(state, round_keys[round])\n        state = inv_mix_columns(state)\n\n    state = inv_shift_rows(state)\n    state = inv_sub_bytes(state)\n    state = add_round_key(state, round_keys[0])\n\n    return state", "def aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # AES parameters\n    Nb = 4\n    Nr = len(expanded_key) // 16 - 1\n\n    # Inverse S-box\n    inv_sbox = [\n        0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n        0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n        0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n        0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n        0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n        0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n        0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n        0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n        0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n        0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n        0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n        0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n        0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n        0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n        0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n        0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n    ]\n\n    # Helper for multiplication in GF(2^8)\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mul(a, b):\n        p = 0\n        for i in range(8):\n            if b & 1:\n                p ^= a\n            high_bit_set = a & 0x80\n            a = (a << 1) & 0xFF\n            if high_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    # Inverse MixColumns matrix multiply\n    def inv_mix_columns(s):\n        for i in range(4):\n            col = s[i*4:i*4+4]\n            s[i*4+0] = mul(0x0e, col[0]) ^ mul(0x0b, col[1]) ^ mul(0x0d, col[2]) ^ mul(0x09, col[3])\n            s[i*4+1] = mul(0x09, col[0]) ^ mul(0x0e, col[1]) ^ mul(0x0b, col[2]) ^ mul(0x0d, col[3])\n            s[i*4+2] = mul(0x0d, col[0]) ^ mul(0x09, col[1]) ^ mul(0x0e, col[2]) ^ mul(0x0b, col[3])\n            s[i*4+3] = mul(0x0b, col[0]) ^ mul(0x0d, col[1]) ^ mul(0x09, col[2]) ^ mul(0x0e, col[3])\n\n    # AddRoundKey step\n    def add_round_key(s, k):\n        for i in range(16):\n            s[i] ^= k[i]\n\n    # Inverse ShiftRows\n    def inv_shift_rows(s):\n        s[1], s[5], s[9], s[13] = s[13], s[1], s[5], s[9]\n        s[2], s[6], s[10], s[14] = s[10], s[14], s[2], s[6]\n        s[3], s[7], s[11], s[15] = s[7], s[11], s[15], s[3]\n\n    # Inverse SubBytes\n    def inv_sub_bytes(s):\n        for i in range(16):\n            s[i] = inv_sbox[s[i]]\n\n    # Convert data to a mutable list\n    state = list(data)\n\n    # Initial AddRoundKey\n    add_round_key(state, expanded_key[Nr*16:(Nr+1)*16])\n\n    for round in range(Nr - 1, 0, -1):\n        inv_shift_rows(state)\n        inv_sub_bytes(state)\n        add_round_key(state, expanded_key[round*16:(round+1)*16])\n        inv_mix_columns(state)\n\n    # Final round (no InvMixColumns)\n    inv_shift_rows(state)\n    inv_sub_bytes(state)\n    add_round_key(state, expanded_key[0:16])\n\n    return state"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # Constants\n    Nb = 4  # block size (in words): no of columns (32-bit words) comprising the State; always 4 for AES\n    Nk = len(expanded_key) // 4 // Nb  # key length in 32-bit words\n    Nr = Nk + 6  # number of rounds\n\n    # Helper functions\n    def sub_word(word):\n        sbox = [\n            # 0    1    2    3     4    5    6    7     8    9    a    b     c    d    e    f\n            0x63, 0x7c, 0x77, 0x7b,  0xf2, 0x6b, 0x6f, 0xc5,  0x30, 0x01, 0x67, 0x2b,  0xfe, 0xd7, 0xab, 0x76,\n            0xca, 0x82, 0xc9, 0x7d,  0xfa, 0x59, 0x47, 0xf0,  0xad, 0xd4, 0xa2, 0xaf,  0x9c, 0xa4, 0x72, 0xc0,\n            0xb7, 0xfd, 0x93, 0x26,  0x36, 0x3f, 0xf7, 0xcc,  0x34, 0xa5, 0xe5, 0xf1,  0x71, 0xd8, 0x31, 0x15,\n            0x04, 0xc7, 0x23, 0xc3,  0x18, 0x96, 0x05, 0x9a,  0x07, 0x12, 0x80, 0xe2,  0xeb, 0x27, 0xb2, 0x75,\n            0x09, 0x83, 0x2c, 0x1a,  0x1b, 0x6e, 0x5a, 0xa0,  0x52, 0x3b, 0xd6, 0xb3,  0x29, 0xe3, 0x2f, 0x84,\n            0x53, 0xd1, 0x00, 0xed,  0x20, 0xfc, 0xb1, 0x5b,  0x6a, 0xcb, 0xbe, 0x39,  0x4a, 0x4c, 0x58, 0xcf,\n            0xd0, 0xef, 0xaa, 0xfb,  0x43, 0x4d, 0x33, 0x85,  0x45, 0xf9, 0x02, 0x7f,  0x50, 0x3c, 0x9f, 0xa8,\n            0x51, 0xa3, 0x40, 0x8f,  0x92, 0x9d, 0x38, 0xf5,  0xbc, 0xb6, 0xda, 0x21,  0x10, 0xff, 0xf3, 0xd2,\n            0xcd, 0x0c, 0x13, 0xec,  0x5f, 0x97, 0x44, 0x17,  0xc4, 0xa7, 0x7e, 0x3d,  0x64, 0x5d, 0x19, 0x73,\n            0x60, 0x81, 0x4f, 0xdc,  0x22, 0x2a, 0x90, 0x88,  0x46, 0xee, 0xb8, 0x14,  0xde, 0x5e, 0x0b, 0xdb,\n            0xe0, 0x32, 0x3a, 0x0a,  0x49, 0x06, 0x24, 0x5c,  0xc2, 0xd3, 0xac, 0x62,  0x91, 0x95, 0xe4, 0x79,\n            0xe7, 0xc8, 0x37, 0x6d,  0x8d, 0xd5, 0x4e, 0xa9,  0x6c, 0x56, 0xf4, 0xea,  0x65, 0x7a, 0xae, 0x08,\n            0xba, 0x78, 0x25, 0x2e,  0x1c, 0xa6, 0xb4, 0xc6,  0xe8, 0xdd, 0x74, 0x1f,  0x4b, 0xbd, 0x8b, 0x8a,\n            0x70, 0x3e, 0xb5, 0x66,  0x48, 0x03, 0xf6, 0x0e,  0x61, 0x35, 0x57, 0xb9,  0x86, 0xc1, 0x1d, 0x9e,\n            0xe1, 0xf8, 0x98, 0x11,  0x69, 0xd9, 0x8e, 0x94,  0x9b, 0x1e, 0x87, 0xe9,  0xce, 0x55, 0x28, 0xdf,\n            0x8c, 0xa1, 0x89, 0x0d,  0xbf, 0xe6, 0x42, 0x68,  0x41, 0x99, 0x2d, 0x0f,  0xb0, 0x54, 0xbb, 0x16\n        ]\n        return [sbox[b] for b in word]\n\n    def inv_sub_bytes(state):\n        inv_sbox = [\n            0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n            0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n            0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n            0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n            0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n            0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n            0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n            0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n            0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n            0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n            0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n            0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n            0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n            0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n            0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n            0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n        ]\n        return [inv_sbox[b] for b in state]\n\n    def inv_shift_rows(state):\n        # State is a list of 16 bytes\n        # Convert to 4x4 matrix (column-major order)\n        m = [list(state[i:i+4]) for i in range(0,16,4)]\n        # m[row][col] but AES state is column-major, so taking columns as bytes\n        # Let's rearrange bytes to a matrix row-major for easier manipulation:\n        # AES uses state as columns (4 bytes each), but stored linear as:\n        # state[0],State[1],... state[15] = column0,row0; column0,row1; column0,row2; column0,row3; col1,row0; col1,row1; ...\n        # The data in 'state' is column-major order:\n        # To do shifts on rows, reconstruct rows explicitly:\n        rows = [[state[col+4*row] for col in range(4)] for row in range(4)]\n        # Inverse shift rows: row 0 no shift\n        # row1 shift right by 1\n        rows[1] = rows[1][-1:] + rows[1][:-1]\n        # row2 shift right by 2\n        rows[2] = rows[2][-2:] + rows[2][:-2]\n        # row3 shift right by 3 (or left by 1)\n        rows[3] = rows[3][-3:] + rows[3][:-3]\n        # Convert back to column-major state\n        new_state = []\n        for col in range(4):\n            for row in range(4):\n                new_state.append(rows[row][col])\n        return new_state\n\n    def add_round_key(state, round_key):\n        return [s ^ k for s, k in zip(state, round_key)]\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mul_bytes(a, b):\n        # Multiply two bytes in GF(2^8)\n        res = 0\n        for i in range(8):\n            if b & 1:\n                res ^= a\n            high_bit = a & 0x80\n            a = (a << 1) & 0xff\n            if high_bit:\n                a ^= 0x1b\n            b >>= 1\n        return res\n\n    def inv_mix_columns(state):\n        # operates on columns of 4 bytes\n        new_state = []\n        for c in range(4):\n            col = state[4*c:4*c+4]\n            s0 = mul_bytes(col[0], 0x0e) ^ mul_bytes(col[1], 0x0b) ^ mul_bytes(col[2], 0x0d) ^ mul_bytes(col[3], 0x09)\n            s1 = mul_bytes(col[0], 0x09) ^ mul_bytes(col[1], 0x0e) ^ mul_bytes(col[2], 0x0b) ^ mul_bytes(col[3], 0x0d)\n            s2 = mul_bytes(col[0], 0x0d) ^ mul_bytes(col[1], 0x09) ^ mul_bytes(col[2], 0x0e) ^ mul_bytes(col[3], 0x0b)\n            s3 = mul_bytes(col[0], 0x0b) ^ mul_bytes(col[1], 0x0d) ^ mul_bytes(col[2], 0x09) ^ mul_bytes(col[3], 0x0e)\n            new_state.extend([s0, s1, s2, s3])\n        return new_state\n\n    # Convert expanded_key bytes to round keys (list of lists of 16 bytes)\n    round_keys = [expanded_key[16*i:16*(i+1)] for i in range(Nr+1)]\n\n    # Start decrypt\n    state = data[:]\n\n    state = add_round_key(state, round_keys[Nr])\n\n    for round in range(Nr-1, 0, -1):\n        state = inv_shift_rows(state)\n        state = inv_sub_bytes(state)\n        state = add_round_key(state, round_keys[round])\n        state = inv_mix_columns(state)\n\n    # Final round (no InvMixColumns)\n    state = inv_shift_rows(state)\n    state = inv_sub_bytes(state)\n    state = add_round_key(state, round_keys[0])\n\n    return state\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    Nb = 4\n    Nr = len(expanded_key) // 4 - Nb\n\n    def sub_word(word):\n        sbox = [\n            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n            0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n            0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n            0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n            0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n            0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n            0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n            0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n            0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n            0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n            0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n            0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n            0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n            0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n            0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n            0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n            0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n        ]\n        return [sbox[b] for b in word]\n\n    def inv_sub_bytes(s):\n        inv_sbox = [\n            0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,\n            0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n            0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,\n            0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n            0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,\n            0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n            0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,\n            0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n            0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,\n            0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n            0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,\n            0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n            0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,\n            0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n            0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,\n            0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n            0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,\n            0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n            0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,\n            0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n            0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,\n            0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n            0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,\n            0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n            0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,\n            0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n            0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,\n            0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n            0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,\n            0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n            0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,\n            0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n        ]\n        return [inv_sbox[b] for b in s]\n\n    def add_round_key(state, key):\n        return [s ^ k for s, k in zip(state, key)]\n\n    def rot_word(word):\n        return word[1:] + word[:1]\n\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mul(a, b):\n        p = 0\n        for i in range(8):\n            if b & 1:\n                p ^= a\n            high_bit_set = a & 0x80\n            a = (a << 1) & 0xff\n            if high_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p & 0xff\n\n    def inv_mix_columns(state):\n        # state is 16 bytes - 4 columns of 4 bytes each\n        s = list(state)\n        for i in range(4):\n            col = s[i*4:(i+1)*4]\n            s[i*4+0] = mul(col[0], 0x0e) ^ mul(col[1], 0x0b) ^ mul(col[2], 0x0d) ^ mul(col[3], 0x09)\n            s[i*4+1] = mul(col[0], 0x09) ^ mul(col[1], 0x0e) ^ mul(col[2], 0x0b) ^ mul(col[3], 0x0d)\n            s[i*4+2] = mul(col[0], 0x0d) ^ mul(col[1], 0x09) ^ mul(col[2], 0x0e) ^ mul(col[3], 0x0b)\n            s[i*4+3] = mul(col[0], 0x0b) ^ mul(col[1], 0x0d) ^ mul(col[2], 0x09) ^ mul(col[3], 0x0e)\n        return s\n\n    def inv_shift_rows(state):\n        # state is a list of 16 bytes: row0[row0,row4,row8,row12], row1[row1,...] etc as matrix column major\n        s = list(state)\n        # Row 1 shift right by 1\n        s[1], s[5], s[9], s[13] = s[13], s[1], s[5], s[9]\n        # Row 2 shift right by 2\n        s[2], s[6], s[10], s[14] = s[10], s[14], s[2], s[6]\n        # Row 3 shift right by 3 (left by 1)\n        s[3], s[7], s[11], s[15] = s[7], s[11], s[15], s[3]\n        return s\n\n    # Setup state\n    state = list(data)\n\n    # Initial add round key\n    round_key = expanded_key[Nr*4*4:(Nr+1)*4*4]\n    state = add_round_key(state, round_key)\n\n    # main rounds\n    for round in range(Nr-1, 0, -1):\n        state = inv_shift_rows(state)\n        state = inv_sub_bytes(state)\n        round_key = expanded_key[round*4*4:(round+1)*4*4]\n        state = add_round_key(state, round_key)\n        state = inv_mix_columns(state)\n\n    # final round\n    state = inv_shift_rows(state)\n    state = inv_sub_bytes(state)\n    round_key = expanded_key[0:4*4]\n    state = add_round_key(state, round_key)\n\n    return state\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # S-box inverse\n    inv_sbox = [\n        0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n        0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n        0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n        0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n        0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n        0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n        0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n        0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n        0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n        0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n        0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n        0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n        0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n        0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n        0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n        0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n    ]\n\n    def add_round_key(state, round_key):\n        for i in range(16):\n            state[i] ^= round_key[i]\n\n    def inv_sub_bytes(state):\n        for i in range(16):\n            state[i] = inv_sbox[state[i]]\n\n    def inv_shift_rows(state):\n        # Row 0: no shift\n        # Row 1: shift right by 1\n        state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]\n        # Row 2: shift right by 2\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        # Row 3: shift right by 3 (left by 1)\n        state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]\n\n    def gmul(a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi_bit_set = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def inv_mix_columns(state):\n        for i in range(4):\n            s0 = state[i*4]\n            s1 = state[i*4+1]\n            s2 = state[i*4+2]\n            s3 = state[i*4+3]\n\n            state[i*4]   = gmul(s0, 0x0e) ^ gmul(s1, 0x0b) ^ gmul(s2, 0x0d) ^ gmul(s3, 0x09)\n            state[i*4+1] = gmul(s0, 0x09) ^ gmul(s1, 0x0e) ^ gmul(s2, 0x0b) ^ gmul(s3, 0x0d)\n            state[i*4+2] = gmul(s0, 0x0d) ^ gmul(s1, 0x09) ^ gmul(s2, 0x0e) ^ gmul(s3, 0x0b)\n            state[i*4+3] = gmul(s0, 0x0b) ^ gmul(s1, 0x0d) ^ gmul(s2, 0x09) ^ gmul(s3, 0x0e)\n\n    # Determine number of rounds from expanded key length\n    nk = len(expanded_key) // 4  # number of 32-bit words in key\n    nb = 4  # block size in 32-bit words\n    nr = nk + 6\n\n    state = data[:]\n\n    # initial AddRoundKey\n    add_round_key(state, expanded_key[-16:])\n\n    for round in range(nr-1, 0, -1):\n        inv_shift_rows(state)\n        inv_sub_bytes(state)\n        add_round_key(state, expanded_key[round*16:(round+1)*16])\n        inv_mix_columns(state)\n\n    inv_shift_rows(state)\n    inv_sub_bytes(state)\n    add_round_key(state, expanded_key[0:16])\n\n    return state\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # AES constants\n    Nb = 4\n    Nr = len(expanded_key) // 4 - 1  # Number of rounds: key length-dependent\n\n    # Helper inverse S-box\n    inv_sbox = [\n        0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n        0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n        0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n        0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n        0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n        0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n        0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n        0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n        0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n        0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n        0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n        0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n        0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n        0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n        0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n        0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n    ]\n\n    # Multiply in GF(2^8)\n    def gmul(a, b):\n        p = 0\n        for i in range(8):\n            if b & 1:\n                p ^= a\n            hi_bit_set = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def add_round_key(state, round_key):\n        for i in range(16):\n            state[i] ^= round_key[i]\n        return state\n\n    def inv_sub_bytes(state):\n        for i in range(16):\n            state[i] = inv_sbox[state[i]]\n        return state\n\n    def inv_shift_rows(state):\n        # state is 4x4 column major, indexed as state[col*4 + row]\n        # Row 0: no shift\n        # Row 1: shift right 1\n        # Row 2: shift right 2\n        # Row 3: shift right 3\n        # So we do inverse of shiftrows (which does left shifts)\n        # We'll do per row operates on the 4 elements at [0+row,4+row,8+row,12+row]\n        def rotate_right(row, n):\n            return row[-n:] + row[:-n]\n        for r in range(1, 4):\n            row = [state[c * 4 + r] for c in range(4)]\n            row = rotate_right(row, r)\n            for c in range(4):\n                state[c * 4 + r] = row[c]\n        return state\n\n    def inv_mix_columns(state):\n        # each column is 4 bytes\n        for c in range(4):\n            i = c * 4\n            s0 = state[i]\n            s1 = state[i+1]\n            s2 = state[i+2]\n            s3 = state[i+3]\n            state[i] = gmul(s0,0x0e) ^ gmul(s1,0x0b) ^ gmul(s2,0x0d) ^ gmul(s3,0x09)\n            state[i+1] = gmul(s0,0x09) ^ gmul(s1,0x0e) ^ gmul(s2,0x0b) ^ gmul(s3,0x0d)\n            state[i+2] = gmul(s0,0x0d) ^ gmul(s1,0x09) ^ gmul(s2,0x0e) ^ gmul(s3,0x0b)\n            state[i+3] = gmul(s0,0x0b) ^ gmul(s1,0x0d) ^ gmul(s2,0x09) ^ gmul(s3,0x0e)\n        return state\n\n    # Copy data for state\n    state = data[:]\n\n    round_keys = [ expanded_key[i*16:(i+1)*16] for i in range(Nr+1) ]\n\n    state = add_round_key(state, round_keys[Nr])\n\n    for round in range(Nr-1, 0, -1):\n        state = inv_shift_rows(state)\n        state = inv_sub_bytes(state)\n        state = add_round_key(state, round_keys[round])\n        state = inv_mix_columns(state)\n\n    state = inv_shift_rows(state)\n    state = inv_sub_bytes(state)\n    state = add_round_key(state, round_keys[0])\n\n    return state\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    # AES parameters\n    Nb = 4\n    Nr = len(expanded_key) // 16 - 1\n\n    # Inverse S-box\n    inv_sbox = [\n        0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n        0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n        0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n        0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n        0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n        0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n        0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n        0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n        0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n        0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n        0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n        0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n        0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n        0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n        0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n        0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d,\n    ]\n\n    # Helper for multiplication in GF(2^8)\n    def xtime(a):\n        return ((a << 1) ^ 0x1b) & 0xff if (a & 0x80) else (a << 1)\n\n    def mul(a, b):\n        p = 0\n        for i in range(8):\n            if b & 1:\n                p ^= a\n            high_bit_set = a & 0x80\n            a = (a << 1) & 0xFF\n            if high_bit_set:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    # Inverse MixColumns matrix multiply\n    def inv_mix_columns(s):\n        for i in range(4):\n            col = s[i*4:i*4+4]\n            s[i*4+0] = mul(0x0e, col[0]) ^ mul(0x0b, col[1]) ^ mul(0x0d, col[2]) ^ mul(0x09, col[3])\n            s[i*4+1] = mul(0x09, col[0]) ^ mul(0x0e, col[1]) ^ mul(0x0b, col[2]) ^ mul(0x0d, col[3])\n            s[i*4+2] = mul(0x0d, col[0]) ^ mul(0x09, col[1]) ^ mul(0x0e, col[2]) ^ mul(0x0b, col[3])\n            s[i*4+3] = mul(0x0b, col[0]) ^ mul(0x0d, col[1]) ^ mul(0x09, col[2]) ^ mul(0x0e, col[3])\n\n    # AddRoundKey step\n    def add_round_key(s, k):\n        for i in range(16):\n            s[i] ^= k[i]\n\n    # Inverse ShiftRows\n    def inv_shift_rows(s):\n        s[1], s[5], s[9], s[13] = s[13], s[1], s[5], s[9]\n        s[2], s[6], s[10], s[14] = s[10], s[14], s[2], s[6]\n        s[3], s[7], s[11], s[15] = s[7], s[11], s[15], s[3]\n\n    # Inverse SubBytes\n    def inv_sub_bytes(s):\n        for i in range(16):\n            s[i] = inv_sbox[s[i]]\n\n    # Convert data to a mutable list\n    state = list(data)\n\n    # Initial AddRoundKey\n    add_round_key(state, expanded_key[Nr*16:(Nr+1)*16])\n\n    for round in range(Nr - 1, 0, -1):\n        inv_shift_rows(state)\n        inv_sub_bytes(state)\n        add_round_key(state, expanded_key[round*16:(round+1)*16])\n        inv_mix_columns(state)\n\n    # Final round (no InvMixColumns)\n    inv_shift_rows(state)\n    inv_sub_bytes(state)\n    add_round_key(state, expanded_key[0:16])\n\n    return state\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n      with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    NONCE_LENGTH_BYTES = 8\n\n    data = bytes_to_intlist(compat_b64decode(data))\n    password = bytes_to_intlist(password.encode('utf-8'))\n\n    key = password[:key_size_bytes] + [0] * (key_size_bytes - len(password))\n    key = aes_encrypt(key[:BLOCK_SIZE_BYTES], key_expansion(key)) * (key_size_bytes // BLOCK_SIZE_BYTES)\n\n    nonce = data[:NONCE_LENGTH_BYTES]\n    cipher = data[NONCE_LENGTH_BYTES:]\n\n    class Counter(object):\n        __value = nonce + [0] * (BLOCK_SIZE_BYTES - NONCE_LENGTH_BYTES)\n\n        def next_value(self):\n            temp = self.__value\n            self.__value = inc(self.__value)\n            return temp\n\n    decrypted_data = aes_ctr_decrypt(cipher, key, Counter())\n    plaintext = intlist_to_bytes(decrypted_data)\n\n    return plaintext\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_2():\n    assert aes_decrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == \\\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntest_2()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(bytes_to_intlist(intlist_to_bytes(bytes_to_intlist(\"00\" * 16))), bytes_to_intlist(compat_b64decode(\"MzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzIwMzI=\")))) == output\ntest_0()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([6, 8, 15, 15, 14, 11, 8, 15, 6, 8, 15, 15, 14, 11, 8, 5],\n                        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                         1, 6, 11, 10, 9, 5, 14, 15, 8, 0, 2, 7, 12, 13, 3, 4,\n                         3, 8, 13, 11, 6, 4, 9, 1, 10, 7, 0, 5, 14, 12, 15, 15,\n                         12, 5, 1, 15, 14, 13, 10, 0, 7, 8, 9, 2, 4, 6, 3, 11]) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(b'2\\x88\\x86\\xe9S\\xe2\\xd14\\xd0\\x11\\xdb\\xaf\\x95+\\x0b\\x82\\xee\\xa6', compat_b64decode('Y2Y3Y2Y1Y2Y1Y2Y4Y3Y2N7MDAwMDAwMDBAQk9PQ=='))) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt(intlist_to_bytes(aes_encrypt(b'hello', b'key')), b'key') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt([0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10], [0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10])) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff], [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]) == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(bytes_to_intlist(compat_b64decode('X4KgGl8K6J0u2VUzZHakWw==')), bytes_to_intlist(compat_b64decode('M21g1R/17Pf612GWlhXa8Q==')))\n        ) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bytes_to_intlist(aes_decrypt(\n                bytes_to_intlist(compat_b64decode(\"x37n3k9v27h1962517363b6855137174\")),\n                bytes_to_intlist(compat_b64decode(\"25c1f46cfb71c3d1a1749c16c35440b617425c2871f46cfb8671c3d1a1749c16c35440b6\")))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert intlist_to_bytes(aes_decrypt(\n        bytes_to_intlist(b'9b60087e323b9269'),\n        bytes_to_intlist(b'32189159c5947f40' * 4 + b'32189159c5947f40')\n    )) == output\ntest_13()\n\n\n"]}
{"task_id": 151, "project": "test-apps/youtube-dl", "module": "youtube_dl.aes", "predictions": ["def aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n\n    # Decode base64 data\n    decoded_data = base64.b64decode(data)\n\n    # Extract the first 8 bytes as the high part of the counter\n    counter_high = decoded_data[:8]\n\n    # The rest is the ciphertext\n    ciphertext = decoded_data[8:]\n\n    # Encode password to bytes\n    password_bytes = password.encode('utf-8')\n\n    # First 16 bytes of password (for key encryption)\n    password_16 = password_bytes[:16]\n    if len(password_16) < 16:\n        password_16 += b'\\x00' * (16 - len(password_16))\n\n    # Key base: first key_size_bytes of password padded with zeros if needed\n    key_base = password_bytes[:key_size_bytes]\n    if len(key_base) < key_size_bytes:\n        key_base += b'\\x00' * (key_size_bytes - len(key_base))\n\n    # Use AES ECB to encrypt password_16 with key_base to get cipher key\n    key_cipher = AES.new(key_base, AES.MODE_ECB)\n    cipher_key = key_cipher.encrypt(password_16)\n\n    # Construct counter: 8 bytes high + 8 bytes low counter starting at 0\n    # Counter is 16 bytes\n    from Crypto.Util import Counter\n    counter_int_high = int.from_bytes(counter_high, byteorder='big')\n    # Counter low initial value = 0\n    # Construct a 128-bit counter: top 64 bits = counter_int_high, bottom 64 bits = counter starting at 0\n    def ctr_builder():\n        # This generator yields successive counter blocks for AES CTR\n        ctr_val = 0\n        while True:\n            # Build 16-byte counter block\n            concatenated = counter_int_high.to_bytes(8, byteorder='big') + ctr_val.to_bytes(8, byteorder='big')\n            yield concatenated\n            ctr_val += 1\n\n    # Using PyCryptoDome's Counter utility to avoid manual counter management\n    # Since the counter high bytes are fixed, and low bytes start at zero\n    ctr = Counter.new(64, prefix=counter_high, initial_value=0, little_endian=False)\n\n    # Now create AES cipher in CTR mode with the cipher_key and counter\n    aes_ctr = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n\n    # Decrypt ciphertext\n    decrypted_bytes = aes_ctr.decrypt(ciphertext)\n\n    # Return decrypted text as utf-8 string, ignoring errors\n    return decrypted_bytes.decode('utf-8', errors='ignore')", "def aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n\n    # Decode base64 data\n    decoded_data = base64.b64decode(data)\n\n    # Extract the first 8 bytes (high bytes of the counter)\n    counter_high_bytes = decoded_data[:8]\n\n    # Extract the rest of the ciphertext\n    ciphertext = decoded_data[8:]\n\n    # Encode password to bytes\n    password_bytes = password.encode('utf-8')\n\n    # Prepare password key segment - pad with zeros if shorter than key_size_bytes\n    password_key_segment = password_bytes[:key_size_bytes].ljust(key_size_bytes, b'\\x00')\n\n    # First 16 bytes of password (if shorter pad with zeros)\n    password_first_16 = password_bytes[:16].ljust(16, b'\\x00')\n\n    # Use AES encryption on password_first_16 using password_key_segment as key to get the cipher key\n    cipher_key_cipher = AES.new(password_key_segment, AES.MODE_ECB)\n    cipher_key = cipher_key_cipher.encrypt(password_first_16)\n\n    # Build full 16-byte counter block:\n    # First 8 bytes from data (counter_high_bytes), last 8 bytes are zeros initially but will increment\n    # CTR mode requires a counter function; since the first 8 bytes are fixed, the counter increments the last 8 bytes\n    from Crypto.Util import Counter\n\n    # The 8 high bytes (most significant bytes)\n    prefix = counter_high_bytes\n\n    # The counter length is 16 bytes total, 8 high bytes fixed, 8 low bytes incrementing\n    # int.from_bytes for initial counter value: start with 0 for low 8 bytes\n    initial_value = 0\n\n    ctr = Counter.new(64, prefix=prefix, initial_value=initial_value, little_endian=False)\n\n    # Decrypt using AES in CTR mode with the derived key and constructed counter\n    cipher = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n\n    decrypted = cipher.decrypt(ciphertext)\n\n    # Return as UTF-8 string\n    return decrypted.decode('utf-8')", "def aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n    from Crypto.Util import Counter\n\n    raw_data = base64.b64decode(data)\n    ctr_high = raw_data[:8]\n    ciphertext = raw_data[8:]\n\n    password_bytes = password.encode('utf-8')\n\n    # Prepare key material from password\n    key_password = password_bytes[:key_size_bytes]\n    if len(key_password) < key_size_bytes:\n        key_password = key_password + b'\\x00' * (key_size_bytes - len(key_password))\n\n    to_encrypt = password_bytes[:16]\n    if len(to_encrypt) < 16:\n        to_encrypt = to_encrypt + b'\\x00' * (16 - len(to_encrypt))\n\n    # Encrypt to_encrypt with key_password in ECB mode to get the cipher key\n    cipher_ecb = AES.new(key_password, AES.MODE_ECB)\n    cipher_key = cipher_ecb.encrypt(to_encrypt)\n\n    # Construct 16 byte counter: ctr_high (8 bytes) + 8 bytes zero (low part)\n    # Counter is a little tricky - need to form the initial value as int from ctr_high + 8 zeros\n    # The counter function expects an int, so convert bytes to int.\n    # Note that ctr_high is the high bytes of counter, so together ctr_high+8 zero bytes is total 16 bytes\n    # int.from_bytes uses big endian by default, but verify: let's assume big endian\n    initial_value = int.from_bytes(ctr_high + b'\\x00'*8, byteorder='big')\n\n    ctr = Counter.new(128, initial_value=initial_value)\n    cipher_ctr = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n\n    decrypted = cipher_ctr.decrypt(ciphertext)\n\n    try:\n        return decrypted.decode('utf-8')\n    except UnicodeDecodeError:\n        # Return raw bytes if decoding fails\n        return decrypted", "def aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n    from Crypto.Util import Counter\n\n    data_bytes = base64.b64decode(data)\n    high_counter_bytes = data_bytes[:8]\n\n    password_bytes = password.encode('utf-8')\n    # Prepare key with length key_size_bytes, padded with zeros if needed\n    key = password_bytes[:key_size_bytes].ljust(key_size_bytes, b'\\0')\n    # First 16 bytes of password (or 16 zeros if shorter)\n    first16 = password_bytes[:16].ljust(16, b'\\0')\n\n    # Use AES ECB to encrypt first16 with key to get cipher key\n    cipher_ecb = AES.new(key, AES.MODE_ECB)\n    cipher_key = cipher_ecb.encrypt(first16)\n\n    # build 16-byte nonce/counter for CTR_mode: first 8 bytes = high_counter_bytes, last 8 bytes zero\n    # interpreted as a 128-bit integer, big endian (default)\n    initial_counter = int.from_bytes(high_counter_bytes + b'\\x00'*8, byteorder='big')\n\n    ctr = Counter.new(128, initial_value=initial_counter)\n    cipher_ctr = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n    plaintext_bytes = cipher_ctr.decrypt(data_bytes[8:])\n\n    return plaintext_bytes.decode('utf-8')", "def aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n    from Crypto.Util import Counter\n\n    decoded_data = base64.b64decode(data)\n\n    # The first 8 bytes of decoded_data are the high bytes of the counter\n    ctr_high = decoded_data[:8]\n\n    # Pad or truncate password bytes to key_size_bytes\n    password_bytes_full = password.encode('utf-8')\n    if len(password_bytes_full) < key_size_bytes:\n        key_bytes = password_bytes_full[:key_size_bytes] + b'\\x00'*(key_size_bytes - len(password_bytes_full))\n    else:\n        key_bytes = password_bytes_full[:key_size_bytes]\n\n    # The first 16 bytes of password are the cleartext to encrypt for key derivation\n    password_16 = password_bytes_full[:16]\n    if len(password_16) < 16:\n        password_16 += b'\\x00' * (16 - len(password_16))\n\n    # Derive the cipher key by encrypting password_16 with key_bytes\n    master_cipher = AES.new(key_bytes, AES.MODE_ECB)\n    derived_key = master_cipher.encrypt(password_16)\n\n    # Construct the counter\n    # The counter block is 16 bytes: first 8 bytes are ctr_high, last 8 bytes start at 0 and increment\n    # Counter is little-endian: int value counts the low 8 bytes\n    # ctr_high is the high 8 bytes of the counter (fixed)\n    initial_counter_value = 0\n    # convert ctr_high to int (big endian)\n    ctr_high_int = int.from_bytes(ctr_high, byteorder='big')\n    # Counter function accepts initial_value as integer, counter_len=16 means 128-bit\n    # We want the counter to be combined: upper 64 bits fixed (ctr_high_int), lower 64 bits count from zero\n    # So initial counter int should be (ctr_high_int << 64) + initial_counter_value\n    initial_counter_int = (ctr_high_int << 64) + initial_counter_value\n\n    ctr = Counter.new(128, initial_value=initial_counter_int, little_endian=False)\n\n    aes_cipher = AES.new(derived_key, AES.MODE_CTR, counter=ctr)\n\n    ciphertext = decoded_data[8:]  # after the 8 bytes for high ctr bytes\n\n    plaintext_bytes = aes_cipher.decrypt(ciphertext)\n\n    try:\n        return plaintext_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        # In case of binary data or incorrect decoding, return raw bytes string\n        return plaintext_bytes.decode('latin1')"], "test": ["from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n\n    # Decode base64 data\n    decoded_data = base64.b64decode(data)\n\n    # Extract the first 8 bytes as the high part of the counter\n    counter_high = decoded_data[:8]\n\n    # The rest is the ciphertext\n    ciphertext = decoded_data[8:]\n\n    # Encode password to bytes\n    password_bytes = password.encode('utf-8')\n\n    # First 16 bytes of password (for key encryption)\n    password_16 = password_bytes[:16]\n    if len(password_16) < 16:\n        password_16 += b'\\x00' * (16 - len(password_16))\n\n    # Key base: first key_size_bytes of password padded with zeros if needed\n    key_base = password_bytes[:key_size_bytes]\n    if len(key_base) < key_size_bytes:\n        key_base += b'\\x00' * (key_size_bytes - len(key_base))\n\n    # Use AES ECB to encrypt password_16 with key_base to get cipher key\n    key_cipher = AES.new(key_base, AES.MODE_ECB)\n    cipher_key = key_cipher.encrypt(password_16)\n\n    # Construct counter: 8 bytes high + 8 bytes low counter starting at 0\n    # Counter is 16 bytes\n    from Crypto.Util import Counter\n    counter_int_high = int.from_bytes(counter_high, byteorder='big')\n    # Counter low initial value = 0\n    # Construct a 128-bit counter: top 64 bits = counter_int_high, bottom 64 bits = counter starting at 0\n    def ctr_builder():\n        # This generator yields successive counter blocks for AES CTR\n        ctr_val = 0\n        while True:\n            # Build 16-byte counter block\n            concatenated = counter_int_high.to_bytes(8, byteorder='big') + ctr_val.to_bytes(8, byteorder='big')\n            yield concatenated\n            ctr_val += 1\n\n    # Using PyCryptoDome's Counter utility to avoid manual counter management\n    # Since the counter high bytes are fixed, and low bytes start at zero\n    ctr = Counter.new(64, prefix=counter_high, initial_value=0, little_endian=False)\n\n    # Now create AES cipher in CTR mode with the cipher_key and counter\n    aes_ctr = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n\n    # Decrypt ciphertext\n    decrypted_bytes = aes_ctr.decrypt(ciphertext)\n\n    # Return decrypted text as utf-8 string, ignoring errors\n    return decrypted_bytes.decode('utf-8', errors='ignore')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n\n    # Decode base64 data\n    decoded_data = base64.b64decode(data)\n\n    # Extract the first 8 bytes (high bytes of the counter)\n    counter_high_bytes = decoded_data[:8]\n\n    # Extract the rest of the ciphertext\n    ciphertext = decoded_data[8:]\n\n    # Encode password to bytes\n    password_bytes = password.encode('utf-8')\n\n    # Prepare password key segment - pad with zeros if shorter than key_size_bytes\n    password_key_segment = password_bytes[:key_size_bytes].ljust(key_size_bytes, b'\\x00')\n\n    # First 16 bytes of password (if shorter pad with zeros)\n    password_first_16 = password_bytes[:16].ljust(16, b'\\x00')\n\n    # Use AES encryption on password_first_16 using password_key_segment as key to get the cipher key\n    cipher_key_cipher = AES.new(password_key_segment, AES.MODE_ECB)\n    cipher_key = cipher_key_cipher.encrypt(password_first_16)\n\n    # Build full 16-byte counter block:\n    # First 8 bytes from data (counter_high_bytes), last 8 bytes are zeros initially but will increment\n    # CTR mode requires a counter function; since the first 8 bytes are fixed, the counter increments the last 8 bytes\n    from Crypto.Util import Counter\n\n    # The 8 high bytes (most significant bytes)\n    prefix = counter_high_bytes\n\n    # The counter length is 16 bytes total, 8 high bytes fixed, 8 low bytes incrementing\n    # int.from_bytes for initial counter value: start with 0 for low 8 bytes\n    initial_value = 0\n\n    ctr = Counter.new(64, prefix=prefix, initial_value=initial_value, little_endian=False)\n\n    # Decrypt using AES in CTR mode with the derived key and constructed counter\n    cipher = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n\n    decrypted = cipher.decrypt(ciphertext)\n\n    # Return as UTF-8 string\n    return decrypted.decode('utf-8')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n    from Crypto.Util import Counter\n\n    raw_data = base64.b64decode(data)\n    ctr_high = raw_data[:8]\n    ciphertext = raw_data[8:]\n\n    password_bytes = password.encode('utf-8')\n\n    # Prepare key material from password\n    key_password = password_bytes[:key_size_bytes]\n    if len(key_password) < key_size_bytes:\n        key_password = key_password + b'\\x00' * (key_size_bytes - len(key_password))\n\n    to_encrypt = password_bytes[:16]\n    if len(to_encrypt) < 16:\n        to_encrypt = to_encrypt + b'\\x00' * (16 - len(to_encrypt))\n\n    # Encrypt to_encrypt with key_password in ECB mode to get the cipher key\n    cipher_ecb = AES.new(key_password, AES.MODE_ECB)\n    cipher_key = cipher_ecb.encrypt(to_encrypt)\n\n    # Construct 16 byte counter: ctr_high (8 bytes) + 8 bytes zero (low part)\n    # Counter is a little tricky - need to form the initial value as int from ctr_high + 8 zeros\n    # The counter function expects an int, so convert bytes to int.\n    # Note that ctr_high is the high bytes of counter, so together ctr_high+8 zero bytes is total 16 bytes\n    # int.from_bytes uses big endian by default, but verify: let's assume big endian\n    initial_value = int.from_bytes(ctr_high + b'\\x00'*8, byteorder='big')\n\n    ctr = Counter.new(128, initial_value=initial_value)\n    cipher_ctr = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n\n    decrypted = cipher_ctr.decrypt(ciphertext)\n\n    try:\n        return decrypted.decode('utf-8')\n    except UnicodeDecodeError:\n        # Return raw bytes if decoding fails\n        return decrypted\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n    from Crypto.Util import Counter\n\n    data_bytes = base64.b64decode(data)\n    high_counter_bytes = data_bytes[:8]\n\n    password_bytes = password.encode('utf-8')\n    # Prepare key with length key_size_bytes, padded with zeros if needed\n    key = password_bytes[:key_size_bytes].ljust(key_size_bytes, b'\\0')\n    # First 16 bytes of password (or 16 zeros if shorter)\n    first16 = password_bytes[:16].ljust(16, b'\\0')\n\n    # Use AES ECB to encrypt first16 with key to get cipher key\n    cipher_ecb = AES.new(key, AES.MODE_ECB)\n    cipher_key = cipher_ecb.encrypt(first16)\n\n    # build 16-byte nonce/counter for CTR_mode: first 8 bytes = high_counter_bytes, last 8 bytes zero\n    # interpreted as a 128-bit integer, big endian (default)\n    initial_counter = int.from_bytes(high_counter_bytes + b'\\x00'*8, byteorder='big')\n\n    ctr = Counter.new(128, initial_value=initial_counter)\n    cipher_ctr = AES.new(cipher_key, AES.MODE_CTR, counter=ctr)\n    plaintext_bytes = cipher_ctr.decrypt(data_bytes[8:])\n\n    return plaintext_bytes.decode('utf-8')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n", "from __future__ import unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nfrom math import ceil\n\nfrom youtube_dl.compat import compat_b64decode\nfrom youtube_dl.utils import bytes_to_intlist, intlist_to_bytes\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_ctr_decrypt(data, key, counter):\n    \"\"\"\n    Decrypt with aes in counter mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {instance} counter  Instance whose next_value function (@returns {int[]}  16-Byte block)\n                               returns the next counter block\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    for i in range(block_count):\n        counter_block = counter.next_value()\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        cipher_counter_block = aes_encrypt(counter_block, expanded_key)\n        decrypted_data += xor(block, cipher_counter_block)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        decrypted_data += xor(decrypted_block, previous_cipher_block)\n        previous_cipher_block = block\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        remaining_length = BLOCK_SIZE_BYTES - len(block)\n        block += [remaining_length] * remaining_length\n        mixed_block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(mixed_block, expanded_key)\n        encrypted_data += encrypted_block\n\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data\n\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    data = data[:]  # copy\n    rcon_iteration = 1\n    key_size_bytes = len(data)\n    expanded_key_size_bytes = (key_size_bytes // 4 + 7) * BLOCK_SIZE_BYTES\n\n    while len(data) < expanded_key_size_bytes:\n        temp = data[-4:]\n        temp = key_schedule_core(temp, rcon_iteration)\n        rcon_iteration += 1\n        data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        if key_size_bytes == 32:\n            temp = data[-4:]\n            temp = sub_bytes(temp)\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n\n        for _ in range(3 if key_size_bytes == 32 else 2 if key_size_bytes == 24 else 0):\n            temp = data[-4:]\n            data += xor(temp, data[-key_size_bytes: 4 - key_size_bytes])\n    data = data[:expanded_key_size_bytes]\n\n    return data\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n    for i in range(1, rounds + 1):\n        data = sub_bytes(data)\n        data = shift_rows(data)\n        if i != rounds:\n            data = mix_columns(data)\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n    rounds = len(expanded_key) // BLOCK_SIZE_BYTES - 1\n\n    for i in range(rounds, 0, -1):\n        data = xor(data, expanded_key[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES])\n        if i != rounds:\n            data = mix_columns_inv(data)\n        data = shift_rows_inv(data)\n        data = sub_bytes_inv(data)\n    data = xor(data, expanded_key[:BLOCK_SIZE_BYTES])\n\n    return data\n\n\ndef aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n    import base64\n    from Crypto.Cipher import AES\n    from Crypto.Util import Counter\n\n    decoded_data = base64.b64decode(data)\n\n    # The first 8 bytes of decoded_data are the high bytes of the counter\n    ctr_high = decoded_data[:8]\n\n    # Pad or truncate password bytes to key_size_bytes\n    password_bytes_full = password.encode('utf-8')\n    if len(password_bytes_full) < key_size_bytes:\n        key_bytes = password_bytes_full[:key_size_bytes] + b'\\x00'*(key_size_bytes - len(password_bytes_full))\n    else:\n        key_bytes = password_bytes_full[:key_size_bytes]\n\n    # The first 16 bytes of password are the cleartext to encrypt for key derivation\n    password_16 = password_bytes_full[:16]\n    if len(password_16) < 16:\n        password_16 += b'\\x00' * (16 - len(password_16))\n\n    # Derive the cipher key by encrypting password_16 with key_bytes\n    master_cipher = AES.new(key_bytes, AES.MODE_ECB)\n    derived_key = master_cipher.encrypt(password_16)\n\n    # Construct the counter\n    # The counter block is 16 bytes: first 8 bytes are ctr_high, last 8 bytes start at 0 and increment\n    # Counter is little-endian: int value counts the low 8 bytes\n    # ctr_high is the high 8 bytes of the counter (fixed)\n    initial_counter_value = 0\n    # convert ctr_high to int (big endian)\n    ctr_high_int = int.from_bytes(ctr_high, byteorder='big')\n    # Counter function accepts initial_value as integer, counter_len=16 means 128-bit\n    # We want the counter to be combined: upper 64 bits fixed (ctr_high_int), lower 64 bits count from zero\n    # So initial counter int should be (ctr_high_int << 64) + initial_counter_value\n    initial_counter_int = (ctr_high_int << 64) + initial_counter_value\n\n    ctr = Counter.new(128, initial_value=initial_counter_int, little_endian=False)\n\n    aes_cipher = AES.new(derived_key, AES.MODE_CTR, counter=ctr)\n\n    ciphertext = decoded_data[8:]  # after the 8 bytes for high ctr bytes\n\n    plaintext_bytes = aes_cipher.decrypt(ciphertext)\n\n    try:\n        return plaintext_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        # In case of binary data or incorrect decoding, return raw bytes string\n        return plaintext_bytes.decode('latin1')\n\n\nRCON = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36)\nSBOX = (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16)\nSBOX_INV = (0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d)\nMIX_COLUMN_MATRIX = ((0x2, 0x3, 0x1, 0x1),\n                     (0x1, 0x2, 0x3, 0x1),\n                     (0x1, 0x1, 0x2, 0x3),\n                     (0x3, 0x1, 0x1, 0x2))\nMIX_COLUMN_MATRIX_INV = ((0xE, 0xB, 0xD, 0x9),\n                         (0x9, 0xE, 0xB, 0xD),\n                         (0xD, 0x9, 0xE, 0xB),\n                         (0xB, 0xD, 0x9, 0xE))\nRIJNDAEL_EXP_TABLE = (0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,\n                      0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,\n                      0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,\n                      0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,\n                      0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,\n                      0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,\n                      0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,\n                      0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,\n                      0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,\n                      0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,\n                      0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,\n                      0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,\n                      0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,\n                      0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,\n                      0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,\n                      0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01)\nRIJNDAEL_LOG_TABLE = (0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,\n                      0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,\n                      0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,\n                      0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,\n                      0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,\n                      0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,\n                      0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,\n                      0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,\n                      0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,\n                      0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,\n                      0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,\n                      0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,\n                      0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,\n                      0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,\n                      0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,\n                      0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07)\n\n\ndef sub_bytes(data):\n    return [SBOX[x] for x in data]\n\n\ndef sub_bytes_inv(data):\n    return [SBOX_INV[x] for x in data]\n\n\ndef rotate(data):\n    return data[1:] + [data[0]]\n\n\ndef key_schedule_core(data, rcon_iteration):\n    data = rotate(data)\n    data = sub_bytes(data)\n    data[0] = data[0] ^ RCON[rcon_iteration]\n\n    return data\n\n\ndef xor(data1, data2):\n    return [x ^ y for x, y in zip(data1, data2)]\n\n\ndef rijndael_mul(a, b):\n    if(a == 0 or b == 0):\n        return 0\n    return RIJNDAEL_EXP_TABLE[(RIJNDAEL_LOG_TABLE[a] + RIJNDAEL_LOG_TABLE[b]) % 0xFF]\n\n\ndef mix_column(data, matrix):\n    data_mixed = []\n    for row in range(4):\n        mixed = 0\n        for column in range(4):\n            # xor is (+) and (-)\n            mixed ^= rijndael_mul(data[column], matrix[row][column])\n        data_mixed.append(mixed)\n    return data_mixed\n\n\ndef mix_columns(data, matrix=MIX_COLUMN_MATRIX):\n    data_mixed = []\n    for i in range(4):\n        column = data[i * 4: (i + 1) * 4]\n        data_mixed += mix_column(column, matrix)\n    return data_mixed\n\n\ndef mix_columns_inv(data):\n    return mix_columns(data, MIX_COLUMN_MATRIX_INV)\n\n\ndef shift_rows(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column + row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef shift_rows_inv(data):\n    data_shifted = []\n    for column in range(4):\n        for row in range(4):\n            data_shifted.append(data[((column - row) & 0b11) * 4 + row])\n    return data_shifted\n\n\ndef inc(data):\n    data = data[:]  # copy\n    for i in range(len(data) - 1, -1, -1):\n        if data[i] == 255:\n            data[i] = 0\n        else:\n            data[i] = data[i] + 1\n            break\n    return data\n\n\n__all__ = ['aes_encrypt', 'key_expansion', 'aes_ctr_decrypt', 'aes_cbc_decrypt', 'aes_decrypt_text']\n\n\nimport pickle\ndef test_66():\n    assert aes_decrypt_text('', 'password', 16) == b''\ntest_66()\n\ndef test_102():\n    assert 16 == len(aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16))\ntest_102()\n\ndef test_1():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"U2FsdGVkX1+OTwGlq5bxHg==\", \"testpass\", 16) == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'c', 16) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 16) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"JXw0H3/e0qPx1qwBmCmVAZ1FXK5HgQWk4SzrMUi1f3U=\", \"test\", 16) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\n        \"UwgkVXA8IlJIMWllcnB6b251ciAqTG9yZSBjcmVhdGlvbiAxNDUgbWVzc2FnZSAtIGJ1dHRvbiAjMzIgLz4gZW5jb2RlZCAvdGhpcyAyNTYgaGVyZSAxMzMzNjc4NjU=\",\n        \"12345678901234567890123456789012\",\n        24\n    ) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 24) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 24) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 32) == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'd', 16) == output\ntest_18()\n\ndef test_28():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AQAAAI9RHQwA1s3G7yqUgAe0kR10QF07Z4jVkHU85s6lM/DlQhv0pRkxZsYM5KZ+uF8hX8u79Y6a+tQ==\", \"password\", 16) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'T3fLYdIrLKjU3bD6H6s9Jg==', '123456', 16) == output\ntest_30()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"QgvK1a7uQnFo\", \"password\", 24) == output\ntest_32()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'J9k_HKj-8j67aR0gAExL3w==', 'test', 32) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Ng6fzIvQwD02246dAHX5T3Bq1r5sIpH0xpsfGDc+54+iCzrXox3OzAiEA7nq2Pf3I061lJJ/c8qfG6GyyTzqXd6+4qQI3qhOJXgA=\", 'mypassword', 16) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"KYoqDQs2hSf910T731JP27Nx12Q1Tc2Ju6rDpI+fM1k=\", \"secret\", 32) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"Qg4YVz76qJKy/fhSs9tv5RxO290qTZJXnkUk6ttcoBc=\", \"supersecretpassword\", 16) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('W6TbkP+yP+NVGnwRx3k252a2RQv6d/N4ezb6nH47HlRg=', u'This is a test', 24) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'a', 16) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'e', 16) == output\ntest_44()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"TzB1Yi4+YmljZS5iZQo=\", \"secret\", 16) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"k7RDpJZ5j2sNuG0314H3J0m3l3/UrXtUvA+GzUzFB28=\", \"pass\", 16) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('OQYQ/1RB50tEA2ZfAqc6D/Vg=', 'aaaabbbb', 24) == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZGZmZA==', 'password', 16) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'h', 16) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 16) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'IhbVqkXlVmXUAj6l9YE7Rw==', 'test123', 16) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"QmFzZTY0IHN0cmluZwk=\", 'password', 16) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 24) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 32) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'g', 16) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"iVQEIyMRUoVy\", \"password\", 24) == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 24) == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('ZDVlNjIxMGQxZTU5NGU1YTJmMjNiZjY4ZTFiYmIyZDM=', 'password', 16) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('l8UYdV1XlYk3vSb5D1cizP261jvA33D6v1nR2eE/GKRk0/Bx/GyFhvA==', 'password', 16) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'lzx5qYxQ29HYGpYGJrD8IA==', 'test', 24) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'b', 16) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", \"test\", 32) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'L9qYQLm3jT6M7v2CB7XVEA==', 'a', 32) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'V15mfW0/JpzXU/J2lwJQ==', '123456', 24) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UFBKQDTC+18MU0UtLg==', 'Secret', 16) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 32) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('CfEuQhZ9ZhOo8k8HrA1OcwAZ1nUkDrRp', 'topsecret', 16) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'VjxjA97/nk8d+U591T99Vw==', '123456', 32) == output\ntest_87()\n\ndef test_88():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text('UwgL7gAAAAAAAABlAEX7VUA==', 'This is a secret message!', 16) == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 16) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"OZB7zzGJa1cY6u+kVc4mXw==\", \"123\", 16) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'qU9aBbejV91nAx06d20JNw==', 'test', 16) == output\ntest_96()\n\ndef test_100():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"LBBaQn9rkZuIREhW8/Uh8A==\", \"secret\", 16) == output\ntest_100()\n\ndef test_103():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"AM/w4XBmNpX2KAoCYz/8wCw==\", u\"test\", 32) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b\"jL5pA4w6qN9+Ik5JPqoEkH/AYBVo0fNjAAG4Ho6X+UcgAOQ715A90T0b4WuZ/ZvXQ4rSbJ+R5JorBs534nTg==\", \"0123456789abcdeffedcba9876543210\", 16) == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'EBmlzrVT3PVUlVMJhZLnhA==', 'a', 24) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(\"MzYwMDA0OTkzMw==-976a759449e0011c9d4987549b8b641c\", \"passwort\", 16) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+aes/aes_decrypt_text/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert aes_decrypt_text(b'DsYvN0PXr4UJL1YkP17c0A==', 'f', 16) == output\ntest_107()\n\n\n"]}
{"task_id": 152, "project": "test-apps/youtube-dl", "module": "youtube_dl.downloader.f4m", "predictions": ["def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    for segment_index, segment in enumerate(boot_info[\"segments\"]):\n        for fragment_index, fragment in enumerate(segment[\"fragments\"]):\n            fragments_list.append((segment_index, fragment_index))\n    return fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    for segment_index, segment in enumerate(boot_info['segments']):\n        for fragment_index, fragment in enumerate(segment['fragments']):\n            fragments_list.append((segment_index, fragment_index))\n    return fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    for segment_idx, segment in enumerate(boot_info.get('segments', [])):\n        for fragment_idx, fragment in enumerate(segment.get('fragments', [])):\n            fragments_list.append((segment_idx, fragment_idx))\n    return fragments_list", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments = []\n    for segment_index, segment in enumerate(boot_info.segments):\n        for fragment_index, fragment in enumerate(segment.fragments):\n            fragments.append((segment_index, fragment_index))\n    return fragments", "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments = []\n    for segment_index, segment in enumerate(boot_info.get('segments', [])):\n        for fragment_index, fragment in enumerate(segment.get('fragments', [])):\n            fragments.append((segment_index, fragment_index))\n    return fragments"], "test": ["from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    for segment_index, segment in enumerate(boot_info[\"segments\"]):\n        for fragment_index, fragment in enumerate(segment[\"fragments\"]):\n            fragments_list.append((segment_index, fragment_index))\n    return fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    for segment_index, segment in enumerate(boot_info['segments']):\n        for fragment_index, fragment in enumerate(segment['fragments']):\n            fragments_list.append((segment_index, fragment_index))\n    return fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    for segment_idx, segment in enumerate(boot_info.get('segments', [])):\n        for fragment_idx, fragment in enumerate(segment.get('fragments', [])):\n            fragments_list.append((segment_idx, fragment_idx))\n    return fragments_list\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments = []\n    for segment_index, segment in enumerate(boot_info.segments):\n        for fragment_index, fragment in enumerate(segment.fragments):\n            fragments.append((segment_index, fragment_index))\n    return fragments\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n", "from __future__ import division, unicode_literals\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport sys\nsys.path.insert(1, \"/input/test-apps/youtube-dl\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport io\nimport itertools\nimport time\n\nfrom youtube_dl.downloader.fragment import FragmentFD\nfrom youtube_dl.compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urlparse,\n    compat_urllib_error,\n    compat_urllib_parse_urlparse,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\nfrom youtube_dl.utils import (\n    fix_xml_ampersands,\n    xpath_text,\n)\n\n\nclass DataTruncatedError(Exception):\n    pass\n\n\nclass FlvReader(io.BytesIO):\n    \"\"\"\n    Reader for Flv files\n    The file format is documented in https://www.adobe.com/devnet/f4v.html\n    \"\"\"\n\n    def read_bytes(self, n):\n        data = self.read(n)\n        if len(data) < n:\n            raise DataTruncatedError(\n                'FlvReader error: need %d bytes while only %d bytes got' % (\n                    n, len(data)))\n        return data\n\n    # Utility functions for reading numbers and strings\n    def read_unsigned_long_long(self):\n        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n\n    def read_unsigned_int(self):\n        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n\n    def read_unsigned_char(self):\n        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n\n    def read_string(self):\n        res = b''\n        while True:\n            char = self.read_bytes(1)\n            if char == b'\\x00':\n                break\n            res += char\n        return res\n\n    def read_box_info(self):\n        \"\"\"\n        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n        \"\"\"\n        real_size = size = self.read_unsigned_int()\n        box_type = self.read_bytes(4)\n        header_end = 8\n        if size == 1:\n            real_size = self.read_unsigned_long_long()\n            header_end = 16\n        return real_size, box_type, self.read_bytes(real_size - header_end)\n\n    def read_asrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        quality_entry_count = self.read_unsigned_char()\n        # QualityEntryCount\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        segment_run_count = self.read_unsigned_int()\n        segments = []\n        for i in range(segment_run_count):\n            first_segment = self.read_unsigned_int()\n            fragments_per_segment = self.read_unsigned_int()\n            segments.append((first_segment, fragments_per_segment))\n\n        return {\n            'segment_run': segments,\n        }\n\n    def read_afrt(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n        # time scale\n        self.read_unsigned_int()\n\n        quality_entry_count = self.read_unsigned_char()\n        # QualitySegmentUrlModifiers\n        for i in range(quality_entry_count):\n            self.read_string()\n\n        fragments_count = self.read_unsigned_int()\n        fragments = []\n        for i in range(fragments_count):\n            first = self.read_unsigned_int()\n            first_ts = self.read_unsigned_long_long()\n            duration = self.read_unsigned_int()\n            if duration == 0:\n                discontinuity_indicator = self.read_unsigned_char()\n            else:\n                discontinuity_indicator = None\n            fragments.append({\n                'first': first,\n                'ts': first_ts,\n                'duration': duration,\n                'discontinuity_indicator': discontinuity_indicator,\n            })\n\n        return {\n            'fragments': fragments,\n        }\n\n    def read_abst(self):\n        # version\n        self.read_unsigned_char()\n        # flags\n        self.read_bytes(3)\n\n        self.read_unsigned_int()  # BootstrapinfoVersion\n        # Profile,Live,Update,Reserved\n        flags = self.read_unsigned_char()\n        live = flags & 0x20 != 0\n        # time scale\n        self.read_unsigned_int()\n        # CurrentMediaTime\n        self.read_unsigned_long_long()\n        # SmpteTimeCodeOffset\n        self.read_unsigned_long_long()\n\n        self.read_string()  # MovieIdentifier\n        server_count = self.read_unsigned_char()\n        # ServerEntryTable\n        for i in range(server_count):\n            self.read_string()\n        quality_count = self.read_unsigned_char()\n        # QualityEntryTable\n        for i in range(quality_count):\n            self.read_string()\n        # DrmData\n        self.read_string()\n        # MetaData\n        self.read_string()\n\n        segments_count = self.read_unsigned_char()\n        segments = []\n        for i in range(segments_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'asrt'\n            segment = FlvReader(box_data).read_asrt()\n            segments.append(segment)\n        fragments_run_count = self.read_unsigned_char()\n        fragments = []\n        for i in range(fragments_run_count):\n            box_size, box_type, box_data = self.read_box_info()\n            assert box_type == b'afrt'\n            fragments.append(FlvReader(box_data).read_afrt())\n\n        return {\n            'segments': segments,\n            'fragments': fragments,\n            'live': live,\n        }\n\n    def read_bootstrap_info(self):\n        total_size, box_type, box_data = self.read_box_info()\n        assert box_type == b'abst'\n        return FlvReader(box_data).read_abst()\n\n\ndef read_bootstrap_info(bootstrap_bytes):\n    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n\n\ndef build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments = []\n    for segment_index, segment in enumerate(boot_info.get('segments', [])):\n        for fragment_index, fragment in enumerate(segment.get('fragments', [])):\n            fragments.append((segment_index, fragment_index))\n    return fragments\n\n\ndef write_unsigned_int(stream, val):\n    stream.write(compat_struct_pack('!I', val))\n\n\ndef write_unsigned_int_24(stream, val):\n    stream.write(compat_struct_pack('!I', val)[1:])\n\n\ndef write_flv_header(stream):\n    \"\"\"Writes the FLV header to stream\"\"\"\n    # FLV header\n    stream.write(b'FLV\\x01')\n    stream.write(b'\\x05')\n    stream.write(b'\\x00\\x00\\x00\\x09')\n    stream.write(b'\\x00\\x00\\x00\\x00')\n\n\ndef write_metadata_tag(stream, metadata):\n    \"\"\"Writes optional metadata tag to stream\"\"\"\n    SCRIPT_TAG = b'\\x12'\n    FLV_TAG_HEADER_LEN = 11\n\n    if metadata:\n        stream.write(SCRIPT_TAG)\n        write_unsigned_int_24(stream, len(metadata))\n        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n        stream.write(metadata)\n        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n\n\ndef remove_encrypted_media(media):\n    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib\n                                 and 'drmAdditionalHeaderSetId' not in e.attrib,\n                       media))\n\n\ndef _add_ns(prop, ver=1):\n    return '{http://ns.adobe.com/f4m/%d.0}%s' % (ver, prop)\n\n\ndef get_base_url(manifest):\n    base_url = xpath_text(\n        manifest, [_add_ns('baseURL'), _add_ns('baseURL', 2)],\n        'base URL', default=None)\n    if base_url:\n        base_url = base_url.strip()\n    return base_url\n\n\nclass F4mFD(FragmentFD):\n    \"\"\"\n    A downloader for f4m manifests or AdobeHDS.\n    \"\"\"\n\n    FD_NAME = 'f4m'\n\n    def _get_unencrypted_media(self, doc):\n        media = doc.findall(_add_ns('media'))\n        if not media:\n            self.report_error('No media found')\n        for e in (doc.findall(_add_ns('drmAdditionalHeader'))\n                  + doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n            # If id attribute is missing it's valid for all media nodes\n            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n            if 'id' not in e.attrib:\n                self.report_error('Missing ID in f4m DRM')\n        media = remove_encrypted_media(media)\n        if not media:\n            self.report_error('Unsupported DRM')\n        return media\n\n    def _get_bootstrap_from_url(self, bootstrap_url):\n        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n        return read_bootstrap_info(bootstrap)\n\n    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n        fragments_list = []\n        retries = 30\n        while (not fragments_list) and (retries > 0):\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n            fragments_list = build_fragments_list(boot_info)\n            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n            if not fragments_list:\n                # Retry after a while\n                time.sleep(5.0)\n                retries -= 1\n\n        if not fragments_list:\n            self.report_error('Failed to update fragments')\n\n        return fragments_list\n\n    def _parse_bootstrap_node(self, node, base_url):\n        # Sometimes non empty inline bootstrap info can be specified along\n        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n        # contains whitespace characters in [1]). We will prefer bootstrap\n        # url over inline bootstrap info when present.\n        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n        bootstrap_url = node.get('url')\n        if bootstrap_url:\n            bootstrap_url = compat_urlparse.urljoin(\n                base_url, bootstrap_url)\n            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n        else:\n            bootstrap_url = None\n            bootstrap = compat_b64decode(node.text)\n            boot_info = read_bootstrap_info(bootstrap)\n        return boot_info, bootstrap_url\n\n    def real_download(self, filename, info_dict):\n        man_url = info_dict['url']\n        requested_bitrate = info_dict.get('tbr')\n        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n\n        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n        man_url = urlh.geturl()\n        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n        # (see https://github.com/ytdl-org/youtube-dl/issues/6215#issuecomment-121704244\n        # and https://github.com/ytdl-org/youtube-dl/issues/7823)\n        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n\n        doc = compat_etree_fromstring(manifest)\n        formats = [(int(f.attrib.get('bitrate', -1)), f)\n                   for f in self._get_unencrypted_media(doc)]\n        if requested_bitrate is None or len(formats) == 1:\n            # get the best format\n            formats = sorted(formats, key=lambda f: f[0])\n            rate, media = formats[-1]\n        else:\n            rate, media = list(filter(\n                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n\n        # Prefer baseURL for relative URLs as per 11.2 of F4M 3.0 spec.\n        man_base_url = get_base_url(doc) or man_url\n\n        base_url = compat_urlparse.urljoin(man_base_url, media.attrib['url'])\n        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n        boot_info, bootstrap_url = self._parse_bootstrap_node(\n            bootstrap_node, man_base_url)\n        live = boot_info['live']\n        metadata_node = media.find(_add_ns('metadata'))\n        if metadata_node is not None:\n            metadata = compat_b64decode(metadata_node.text)\n        else:\n            metadata = None\n\n        fragments_list = build_fragments_list(boot_info)\n        test = self.params.get('test', False)\n        if test:\n            # We only download the first fragment\n            fragments_list = fragments_list[:1]\n        total_frags = len(fragments_list)\n        # For some akamai manifests we'll need to add a query to the fragment url\n        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n\n        ctx = {\n            'filename': filename,\n            'total_frags': total_frags,\n            'live': live,\n        }\n\n        self._prepare_frag_download(ctx)\n\n        dest_stream = ctx['dest_stream']\n\n        if ctx['complete_frags_downloaded_bytes'] == 0:\n            write_flv_header(dest_stream)\n            if not live:\n                write_metadata_tag(dest_stream, metadata)\n\n        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n\n        self._start_frag_download(ctx)\n\n        frag_index = 0\n        while fragments_list:\n            seg_i, frag_i = fragments_list.pop(0)\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n            query = []\n            if base_url_parsed.query:\n                query.append(base_url_parsed.query)\n            if akamai_pv:\n                query.append(akamai_pv.strip(';'))\n            if info_dict.get('extra_param_to_segment_url'):\n                query.append(info_dict['extra_param_to_segment_url'])\n            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n            try:\n                success, down_data = self._download_fragment(ctx, url_parsed.geturl(), info_dict)\n                if not success:\n                    return False\n                reader = FlvReader(down_data)\n                while True:\n                    try:\n                        _, box_type, box_data = reader.read_box_info()\n                    except DataTruncatedError:\n                        if test:\n                            # In tests, segments may be truncated, and thus\n                            # FlvReader may not be able to parse the whole\n                            # chunk. If so, write the segment as is\n                            # See https://github.com/ytdl-org/youtube-dl/issues/9214\n                            dest_stream.write(down_data)\n                            break\n                        raise\n                    if box_type == b'mdat':\n                        self._append_fragment(ctx, box_data)\n                        break\n            except (compat_urllib_error.HTTPError, ) as err:\n                if live and (err.code == 404 or err.code == 410):\n                    # We didn't keep up with the live window. Continue\n                    # with the next available fragment.\n                    msg = 'Fragment %d unavailable' % frag_i\n                    self.report_warning(msg)\n                    fragments_list = []\n                else:\n                    raise\n\n            if not fragments_list and not test and live and bootstrap_url:\n                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n                total_frags += len(fragments_list)\n                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n                    self.report_warning(msg)\n\n        self._finish_frag_download(ctx)\n\n        return True\n\n\nimport pickle\ndef test_6():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 2]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': True}) == [(1, 1), (1, 2)]\ntest_6()\n\ndef test_12():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':False}) == [(1, 1), (1, 2), (1, 3)]\ntest_12()\n\ndef test_14():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}], 'live':True}) == [(1, 2), (1, 3)]\ntest_14()\n\ndef test_37():\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 1],\n            [2, 1],\n            [3, 1],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == [\n        (2, 2),\n        (3, 3),\n    ]\ntest_37()\n\ndef test_42():\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':False}) == [(1, 1), (1, 2), (3, 3), (3, 4), (3, 5)]\ntest_42()\n\ndef test_50():\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 5]]}], 'fragments': [{'fragments': [{'first': 1}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]\ntest_50()\n\ndef test_56():\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10],\n                [1, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": False\n    }) == [\n        (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10),\n        (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20)\n    ]\ntest_56()\n\ndef test_58():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 10)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}, {'first': 4}, {'first': 5}]}], 'live': True}) == [(1, 9), (1, 10)]\ntest_58()\n\ndef test_60():\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,2)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":1,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == [(0, 0), (0, 1)]\ntest_60()\n\ndef test_65():\n    assert build_fragments_list({\n        'segments': [{'segment_run': [[0, 4294967295]]}],\n        'fragments': [{'fragments': [{'first': 1}]}],\n        'live': True,\n    }) == [(0, 1), (0, 2)]\ntest_65()\n\ndef test_67():\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 4)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': False}) == [(1, 1), (1, 2), (1, 3), (1, 4)]\ntest_67()\n\ndef test_70():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":False\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_70()\n\ndef test_72():\n    assert build_fragments_list({\n            'segments': [{\n                'segment_run': [\n                    (0, 2), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1),\n                ]\n            }],\n            'fragments': [\n                {'fragments': [{'first': 0}, {'first': 2}]},\n                {'fragments': [{'first': 1}]},\n                {'fragments': [{'first': 2}]},\n                {'fragments': [{'first': 3}]},\n                {'fragments': [{'first': 4}]},\n                {'fragments': [{'first': 5}]},\n                {'fragments': [{'first': 6}]},\n                {'fragments': [{'first': 7}]},\n                {'fragments': [{'first': 8}]},\n            ],\n            'live': True\n        }) == [(7, 8), (8, 9)]\ntest_72()\n\ndef test_79():\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 1), (1, 1)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=False)) == [(0, 10), (1, 11)]\ntest_79()\n\ndef test_80():\n    assert build_fragments_list(\n        {\n        \"segments\":[\n            {\n                \"segment_run\":[\n                    [\n                        6965,\n                        2\n                    ]\n                ]\n            }\n        ],\n        \"fragments\":[\n            {\n                \"fragments\":[\n                    {\n                        \"first\":6965,\n                        \"last\":6966,\n                        \"time\":1036.8333333333333\n                    }\n                ]\n            }\n        ],\n        \"media\":{\n            \"duration\":1036.8333333333333,\n            \"id\":1418240\n        },\n        \"live\":True\n        }\n    ) == [(6965, 6965), (6965, 6966)]\ntest_80()\n\ndef test_0():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": False,\n    }) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':True}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{'segment_run': [(1, 120), (2, 120), (3, 120), (4, 120)]}],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}],\n        'live': True,\n    }) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": False\n    }) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':False}) == output\ntest_7()\n\ndef test_10():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': False}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': True\n    }) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"media\": {},\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        630,\n                        1\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url_transformation_template\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                \"byterange_start\": \"35597\",\n                \"byterange_length\": \"13999\",\n                \"fragments\": [\n                    {\n                        \"url\": \"http://api.filmon.com/hds/bb08254a-567b-4073-8c61-fa7fd19066ac/Seg1-Frag1.frag\",\n                        \"first\": 1,\n                        \"last\": 1,\n                        \"duration\": 10\n                    }\n                ],\n                \"fragment_duration\": 10\n            }\n        ],\n        \"media_found\": True,\n        \"live\": False,\n        \"bootstrap_start_time\": 1485537097.7719999\n    }) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':True}) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 4294967295)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"live\": True, \"version\": 4}) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': True}) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":True,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [69698, 3],\n                [69701, 4]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 482000,\n                'timescale': 48000,\n                'duration': 1500,\n            }, {\n                'first': 483500,\n                'duration': 1500,\n            }, {\n                'first': 485000,\n                'duration': 1500,\n            }]\n        }],\n        'live': True\n    }) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list(dict(segments=[dict(segment_run=[(0, 4294967295)]), dict(segment_run=[(1, 4294967295)])], fragments=[dict(fragments=[dict(first=10)]), dict(fragments=[dict(first=20)])], live=True)) == output\ntest_23()\n\ndef test_27():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[1, 3], [2, 1]]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 4}, {'first': 6}]}], 'live': False}) == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              1,\n              3\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 1,\n              'last': 5,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': False\n    }) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [0, 10]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [{\n                \"first\": 1\n            }]\n        }],\n        \"live\": True\n    }) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': True}) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': False\n    }) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[ (1, 3), (4, 6) ]}],\n                                  \"fragments\":[{\"fragments\":[{\"first\":0, \"last\":4},\n                                                              {\"first\":3, \"last\":5}]}],\n                                  \"live\": True}) == output\ntest_33()\n\ndef test_35():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': False}) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'fragments': [{'fragments': [{'first': 1}, {'first': 3}], 'last_fragment': 1}], 'segments': [{'segment_run': [(1, 2), (3, 1)]}], 'live': False}) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,4294967295)], 'total_duration':4071426786}],'fragments':[{'start_time':4071426786,'fragments':[{'first':3936907,'duration':900000,'url':''}]}],'media':{'duration':4071426786.0,'title':'Live','fragments_duration':900000,'vcodec':'H.264','acodec':'MPEG-4 AAC','width':720,'height':304,'metadata':{'is_live':True}},'live':True}) == output\ntest_38()\n\ndef test_40():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                (123, 5),\n                (456, 3)\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 1\n            }, {\n                'first': 2\n            }, {\n                'first': 3\n            }, {\n                'first': 4\n            }]\n        }],\n        'live': True\n    }) == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\"segment_run\": [(1, 2), (3, 3)]}],\n        \"fragments\": [{\"fragments\": [{\"first\": 4}, {\"first\": 10}]}],\n        \"live\": True,\n    }) == output\ntest_41()\n\ndef test_44():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [(1, 3), (2, 2), (3, 1)]\n        }],\n        'fragments': [{'fragments': [{'first': 1}, {'first': 2}, {'first': 3}]}],\n        'live': False\n    }) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\":[{\"segment_run\":[(0,4)],\"duration\":50.0,\"start_media_sequence\":0}],\"fragments\":[{\"url\":\"/\",\"fragments\":[{\"first\":0,\"last\":3,\"duration\":10.0,\"start\":0.0}]}],\"duration\":100.0,\"endList\":False,\"targetDuration\":10.0,\"mediaSequence\":0,\"live\":True}) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\"segments\": [{\"segment_run\": [(129985, 2)]}], \"fragments\": [{\"fragments\": [{\"first\": 33200}], \"duration\": 6, \"url\": \"\", \"byterange\": {\"offset\": 0, \"length\": 3000}}], \"media\": {\"id\": \"286047\"}, \"version\": 4, \"live\": True}) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{\n        \"segment_run\": [\n            [1, 4294967295],\n        ],\n    }], 'fragments': [\n        {'fragments': [\n            {'first': 1},\n            {'first': 2},\n            {'first': 3},\n        ]}\n    ], 'live': True}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n      'segments': [\n        {\n          'segment_run': [\n            [\n              60,\n              100\n            ]\n          ]\n        }\n      ],\n      'fragments': [\n        {\n          'fragments': [\n            {\n              'first': 4000,\n              'last': 4099,\n              'time': 0\n            }\n          ]\n        }\n      ],\n      'live': True\n    }) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        'segments': [{\n            'segment_run': [\n                [2131, 2],\n                [2133, 2]\n            ]\n        }],\n        'fragments': [{\n            'fragments': [{\n                'first': 130,\n                'last': 135,\n            }, {\n                'first': 136,\n                'last': 136,\n            }],\n            'timescale': 1000\n        }],\n        'live': True\n    }) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [\n            {\n                \"segment_run\": [\n                    [\n                        0,\n                        10\n                    ]\n                ]\n            }\n        ],\n        \"fragments\": [\n            {\n                \"url\": \"http://example.com\",\n                \"fragments\": [\n                    {\n                        \"first\": 0,\n                        \"last\": 10,\n                        \"time\": 0\n                    }\n                ]\n            }\n        ],\n        \"live\": True\n    }) == output\ntest_51()\n\ndef test_54():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1,2),(3,2)],'duration':4}],\n                                  'fragments':[{'fragments':[{'first':123,'last':123,'duration':4}],\n                                                'start_time':123}],\n                                  'duration':4,\n                                  'live':False}) == output\ntest_54()\n\ndef test_62():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [1, 7],\n                [2, 1]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 2, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 3, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 4, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 5, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 6, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n                {\"first\": 7, \"timescale\": 15, \"duration\": 1200, \"byte_range\": [313431, 15667]},\n            ]\n        }],\n        \"live\": True,\n    }) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 5]]}], 'fragments': [{'fragments': [{'first': 101}]}], 'live': True}) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 3)], 'fragments_per_segment':3}], 'fragments':[{'fragments':[{'first':1}, {'first':2}, {'first':3}]}, {'fragments':[{'first':3}, {'first':4}, {'first':5}]}], 'live':True}) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 2), (3, 5), (9, 3)]}],\n                                  'fragments': [{'fragments': [{'first': 11, 'timescale': 10}]}],\n                                  'live': False}) == output\ntest_68()\n\ndef test_71():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': True}) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [\n        (0, 1), (1, 1), (2, 1), (3, 2), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)\n    ] }], 'fragments': [{'fragments': [\n        {'first': 0, 'last': 0, 'time': 0},\n        {'first': 1, 'last': 1, 'time': 10},\n        {'first': 2, 'last': 2, 'time': 20},\n        {'first': 3, 'last': 5, 'time': 30},\n        {'first': 6, 'last': 7, 'time': 60},\n        {'first': 8, 'last': 8, 'time': 80},\n        {'first': 9, 'last': 9, 'time': 90},\n    ] }], 'id': 'test', 'live': True}) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 10), (1, 3), (3, 2), (6, 1), (7, 3), (10, 1)]}], \n                                 'fragments': [{'fragments': [{'first': 0, 'timescale': 1, 'duration': 1},\n                                                              {'first': 1, 'timescale': 1, 'duration': 1},\n                                                              {'first': 2, 'timescale': 1, 'duration': 1},\n                                                              {'first': 3, 'timescale': 1, 'duration': 1},\n                                                              {'first': 4, 'timescale': 1, 'duration': 1},\n                                                              {'first': 5, 'timescale': 1, 'duration': 1},\n                                                              {'first': 6, 'timescale': 1, 'duration': 1},\n                                                              {'first': 7, 'timescale': 1, 'duration': 1},\n                                                              {'first': 8, 'timescale': 1, 'duration': 1},\n                                                              {'first': 9, 'timescale': 1, 'duration': 1},\n                                                              {'first': 10, 'timescale': 1, 'duration': 1}]}],\n                                 'live': True\n                                 }) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 1)]}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}], 'live': True}) == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(1, 2), (3, 1), (4, 2)], 'timescale':10}], 'fragments':[{'start_time':100,'fragments':[{'first':0,'timescale':10,'duration':90}]}], 'media':{'start':0,'duration':0,'timescale':10}, 'version':0,'live':False}) == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n        \"segments\": [{\n            \"segment_run\": [\n                [2, 3],\n                [1, 3]\n            ]\n        }],\n        \"fragments\": [{\n            \"fragments\": [\n                {\"first\": 1, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 2, \"timescale\": 10, \"duration\": 1},\n                {\"first\": 3, \"timescale\": 10, \"duration\": 1},\n            ]\n        }],\n        \"media\": [{\n            \"url\": \"\",\n            \"metadata\": \"\",\n        }],\n        \"media_duration\": 20,\n        \"start_time\": 0,\n        \"live\": True,\n        \"end_time\": 100,\n        \"dvr_window_length\": 120,\n    }) == output\ntest_78()\n\ndef test_81():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments':[{'segment_run':[(0, 2), (2, 2), (4, 1)], 'duration':10}], 'fragments':[{'fragments':[{'first': 2, 'last': 3, 'duration': 10}], 'duration':20}], 'duration':100, 'end_seq':10, 'live':True}) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 2), (3, 4), (5, 6)], 'duration': 1}], 'fragments': [{'fragments': [{'first': 1}, {'first': 2}]}, {'fragments': [{'first': 3}, {'first': 4}]}, {'fragments': [{'first': 5}, {'first': 6}]}], 'media': {'duration': 1.0}, 'daterange': {}, 'T3': '', 'T2': '', 'T1': '', 'T0': '', 'bootstrap_info': {'value': ''}, 'live': False}) == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(0, 4)]}],\n                                  'fragments': [{'fragments': [{'first': 5, 'timescale': 10}]}],\n                                  'live': True}) == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [[0, 1], [1, 2], [2, 1], [3, 1]], 'segment_time_line': [5, 4, 3, 2] }], 'fragments': [{'start_time': 1585368119, 'fragments': [{'first': 338, 'last': 339, 'duration': 17.0, 'url': 'http://v14.lscdn.com/midnight-sky-tv/8d86686c/0389/49610241/038949610241-01-p0389-0338.ts'}]}], 'live': False}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({'segments': [{'segment_run': [(1, 3), (2, 2), (3, 1)], 'timescale': 44100}], 'fragments': [{'start_time': 0, 'fragments': [{'first': 3, 'timescale': 100000, 'duration': 100000}], 'start_time_discontinuity': False, 'discontinuity': False}], 'media': {'default_sample_duration': 653}, 'live': True}) == output\ntest_86()\n\ndef test_87():\n    with open(\"/output/test-apps+youtube-dl/test_output/youtube_dl+downloader+f4m/build_fragments_list/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert build_fragments_list({\n            'media': 'media',\n            'segments': [{'segment_run': [\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n                ({'media': 'media', 'duration': 60, 'start_index': 1}, 2),\n            ]}],\n            'fragments': [{'fragments': [\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n                {'first': 123, 'last': 123, 'duration': 10, 'url': 'url'},\n            ]}],\n            'live': True\n        }) == output\ntest_87()\n\n\n"]}
